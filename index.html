<!DOCTYPE html>
<html>
<head>
  <title>Web NFC</title>
  <meta charset="UTF-8">
  <link rel="icon" type="image/png" href="images/webnfc-favicon-simple.png">
  <script type="module" src="ndef-record.js"></script>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' async class=
  'remove'></script>
  <script class="remove">
    var respecConfig = {
      specStatus: "CG-DRAFT",
      shortName: "web-nfc",
      editors: [
        {
          name: "Kenneth Rohde Christiansen",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
        {
          name: "Zoltan Kis",
          company: "Intel",
          companyURL: "https://intel.com/"
        },
        {
          name: "Fran√ßois Beaufort",
          company: "Google LLC",
          companyURL: "https://google.com/"
        },
      ],
      formerEditors: [
        {
          name: "Alexander Shalamov",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
      ],
      logos: [
        {
          src: 'images/w3c-logo.svg',
          url: "https://w3.org",
          alt: "W3C logo",
          width: 95,
          height: 68,
          id: 'w3c-logo'
        },
        {
          src: 'images/webnfc-logo.svg',
          url: "https://w3c.github.io/web-nfc/",
          alt: "Web NFC logo",
          width: 95,
          height: 68,
          id: 'webnfc-logo'
        }
      ],
      testSuiteURI: "https://wpt.fyi/web-nfc/",
      wg: "Web NFC Community Group",
      wgURI: "https://www.w3.org/community/web-nfc/",
      github: "w3c/web-nfc",
      xref: "web-platform",
      localBiblio: {
        "NFC-SECURITY": {
          href: "https://github.com/w3c/web-nfc/security-privacy.html",
          title: "Web NFC Security and Privacy",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-USECASES": {
          href: "https://github.com/w3c/web-nfc/use-cases.html",
          title: "Web NFC Use Cases",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-STANDARDS": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Technical Specifications",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-NDEF": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Data Exchange Format (NDEF) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-RTD": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Record Type Definition (RTD) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NDEF-TEXT": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Text Record Type Definition",
          publisher: "NFC Forum",
          date: "14 August 2013",
        },
        "NDEF-URI": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum URI Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NDEF-SMARTPOSTER": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Smart Poster Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NDEF-SIGNATURE": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Signature Record Type Definition",
          publisher: "NFC Forum",
          date: "18 November 2010",
        },
        "NFC-HANDOVER": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Connection Handover Technical Specification",
          publisher: "NFC Forum",
          date: "16 January 2014",
        },
        "ISO-639.2": {
          href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
          title: "Codes for the Representation of Names of Languages",
          publisher: "ISO",
          date: "18 March 2014",
        },
      },
    };
  </script>
  <style>
    table.simple { border: 1px solid #000; }
    table.simple td { border-right: 1px solid #000; }
    img.illustration { width: 100%; height: auto }
  </style>
</head>

<body data-cite="MIMESNIFF SECURE-CONTEXTS PERMISSIONS ENCODING PAGE-VISIBILITY">

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz.
  </p>
  <p>
    The hardware standard is defined in [[[NFC-STANDARDS]]].
  </p>
  <p>
    This document defines an API to enable selected use cases based on
    NFC technology. The current scope of this specification is <a>NDEF</a>.
  </p>
  <p class="advisement">
    Low-level I/O operations (e.g. ISO-DEP, NFC-A/B, NFC-F) and Host-based Card
    Emulation (HCE) are <b>not</b> supported within the current scope.
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered
    unstable.
    Implementers who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This document defines conformance criteria that apply to a single
    product: the <dfn>UA</dfn> (user agent) that implements the interfaces it
    contains.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Origin Trial  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Origin Trial</h2>
  <p>An implementation (Chromium) of this specification is currently being tested
    in the wild to gather developer feedback. You can try out Web NFC in Chrome
    for Android by requesting an Origin Trial token and learn more about Origin
    Trials <a href="http://googlechrome.github.io/OriginTrials/developer-guide.html">
    here</a>.
  </p>
  <p>
    Feel free to send your feedback via GitHub or the Origin Trial process.
  </p>
  <p class="advisement">
    The Origin Trial feedback is reshaping parts of the API and an updated
    specification incorporating these changes can be found <a
    href="https://cdn.statically.io/gh/w3c/web-nfc/draft/index.html">
    here</a>.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <p>
    Web NFC user scenario is as follows: Hold a device in close proximity to a
    passively powered NFC tag, such as a plastic card or sticker, in order to
    read and/or write data.
  </p>
  <p>
    NFC works using magnetic induction, meaning that the reader (an active,
    powered device) will emit a small electric charge which then creates a
    magnetic field.
    This field powers the passive device which turns it into electrical impulses
    to communicate data. Thus, when the devices are within range, a read is
    always performed (see NFC Analog Specification and NFC Digital Protocol, NFC
    Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, then later to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As NFC is based on existing RFID standards, many NFC chipsets support
    reading RFID tags, but some of these are only supported by single
    vendors and not part of the NFC standards. As such, this document
    specifies ways to interact with the NFC Data Exchange Format (NDEF).
  </p>
</section> <!-- Introduction -->

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology and conventions</h2>
  <p>
    The Augmented Backus-Naur Form (ABNF) notation used is specified in
    [[RFC5234]].
  </p>
  <p>
    <b>NFC</b> stands for Near Field Communications, a short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See <a href="https://www.nfc-forum.org/specs/spec_list/">
    NFC Forum Technical Specifications</a> for a complete
    listing.
  </p>
  <p>
    An <dfn>NFC adapter</dfn> is the software entity in the underlying
    platform which provides access to NFC functionality implemented in a
    given hardware element (NFC chip). A device may have multiple NFC
    adapters, for instance a built-in one, and one or more attached via USB.
  </p>
  <div>
    An <dfn>NFC tag</dfn> is a passive NFC device that is not <a>blocklisted</a>.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. An <a>NFC tag</a> that supports <a>NDEF</a>
    contains a single <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. They may also expose an <a>NDEF</a> message.
    </p>
  </div>
  <div>
    An <dfn>NFC peer</dfn> is an active, powered device which can interact
    with other devices in order to exchange data using NFC.
    <p class="issue" data-number="529">
      As currently spec'ed, peer-to-peer is not supported.
    </p>
  </div>
  <p>
    An <dfn>NFC device</dfn> is either an <a>NFC peer</a>, or an <a>NFC tag</a>.
  </p>
  <p>
    <dfn>NDEF</dfn> is an abbreviation for NFC Forum Data Exchange Format, a
    lightweight binary message format that is standardized in [[!NFC-NDEF]].
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. NDEF messages can be stored on an <a>NFC tag</a> or
    exchanged between NFC-enabled devices.
  </p>
  <p>
    The term <dfn>NFC content</dfn> denotes all bytes sent to or received from
    an <a>NFC tag</a>. In the current API it is synonym to <a>NDEF message</a>.
  </p>
</section> <!-- Terminology -->


<section class="informative">
  <h2>The NFC Standard</h2>
  <p>
    NFC is standardized in the NFC Forum and described in [[NFC-STANDARDS]].
  </p>
  <section class="informative"> <h3>NDEF compatible tag types</h3>
    <p>
      The NFC Forum has mandated the support of five different tag types to be
      operable with NFC devices. The same is required on operating systems, such
      as Android.
    </p>
    <p>
      In addition to that, the <a>MIFARE Standard</a> specifies a way
      for NDEF to work on top of the older <a>MIFARE Standard</a>, which may
      be optionally supported by implementers.
    </p>
    <p>
      A note about the NDEF mapping can be found here:
      <a href="https://www.nxp.com/docs/en/application-note/AN1305.pdf">
      MIFARE Classic as NFC Type MIFARE Classic Tag</a>.
    </p>
    <div>
      <ol>
        <li>
          <dfn>NFC Forum Type 1</dfn>: This tag is based on the ISO/IEC 14443-3A
          (NFC-A). The tags are rewritable and can be
          configured to become read-only. Memory size can be between `96` bytes and
          `2` Kbytes. Communication speed is `106` kbit/s. In contrast to all other
          types, these tags have no anti-collision protection for dealing with multiple
          tags within the NFC field.
        </li>
        <li>
          <dfn>NFC Forum Type 2</dfn>: This tag is based on the
          ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
          to become read-only. Memory size can be between `48` bytes and `2` Kbytes.
          Communication speed is `106` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 3</dfn>: This tag is based on the Japanese Industrial
          Standard (JIS) X 6319-4 (ISO/IEC 18092), commonly known as FeliCa. The tags are
          preconfigured to be either rewritable or read-only. Memory is `2` kbytes.
          Communication speed is `212` kbit/s or `424` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 4</dfn>: This tag is based on the ISO/IEC 14443-4 A/B
          (NFC A, NFC B) and thus supports either NFC-A or NFC-B
          for communication. On top of that the tag may optionally support ISO-DEP
          (Data Exchange Protocol defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
          Part 4: Transmission protocol). The tags are preconfigured
          to be either rewritable or read-only. Variable memory, up to `32` kbytes.
          Supports three different communication speeds `106` or `212` or
          `424` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 5</dfn>: This tag is based on ISO/IEC 15693 (NFC-V) and
          allows reading and writing an NDEF message on an ISO/IEC 15693 RF tag
          that is accessible by long range RFID readers as well. The NFC communication
          is limited to short distance and may use the <i>Active Communication Mode</i> of
          ISO/IEC 18092 where the sending peer generates the field which balances
          power consumption and improves link stability. Variable memory, up to `64` kbytes.
          Communication speed is `26.48` kbit/s.
        </li>
        <li>
          <dfn>MIFARE Standard</dfn>: This tag, often sold under the brand names MIFARE
          Classic or MIFARE Mini, is based on the ISO/IEC 14443-3A (also known as NFC-A,
          as defined in ISO/IEC 14443-3:2011, Part 3: Initialization and anticollision).
          The tags are rewritable and can be configured to become read-only. Memory size
          can be between `320` and `4` kbytes. Communication speed is `106` kbit/s.
          <p class="note">
            <a>MIFARE Standard</a> is not an NFC Forum type and can only be read by devices
            using NXP hardware. Support for reading and writing to tags based on the
            <a>MIFARE Standard</a> is thus non-nominative, but the type is included
            due to the popularity and use in legacy systems.
          </p>
        </li>
      </ol>
    </div>
    <p>
      In addition to data types standardized for <a>NDEF record</a>s by the NFC
      Forum, many commercial products such as bus cards, door openers may be based
      on the <a>MIFARE Standard</a> which requires specific NFC chips (same vendor of
      card and reader) in order to function.
    </p>
  </section>

  <section>
  <h3>
    The NDEF record and fields
  </h3>
  <p>
    An <dfn>NDEF record</dfn> is a part of an <a>NDEF message</a>. Each record
    is a binary structure that contains a data payload, as well as associated
    type information. In addition to this, it includes information about how
    the data is structured, like payload size, whether the data is chunked over
    multiple records etc.
  </p>
  <div>
    A generic record looks like the following:
    <ndef-record class="ndef"
      header="*,*,*,*,*,*"
      content="*,PAYLOAD LENGTH - 1 (SR) to 4 bytes,ID LENGTH (optional),TYPE (optional),ID (optional),PAYLOAD (optional)">
    </ndef-record>
  </div>
  <p>
    Only the first three bytes (lines in figure) are mandatory. First the
    header byte, followed by the <a>TYPE LENGTH field</a> and <a>PAYLOAD
    LENGTH field</a>, both of which may be zero.
  </p>
  <div>
    The <dfn>TNF field</dfn> (bit `0-2`, type name format) indicates the format
    of the type name and is often exposed by native NFC software stacks. The
    field can take binary values denoting the following NDEF record payload types:
    <table class="simple">
      <tr>
        <th><strong>TNF value</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td><a>Empty record</a></td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum [=well-known type record=]</td>
      </tr>
      <tr>
        <td>2</td>
        <td><a>MIME type record</a></td>
      </tr>
      <tr>
        <td>3</td>
        <td><a>Absolute-URL record</a></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <a>external type record</a></td>
      </tr>
      <tr>
        <td>5</td>
        <td><a>Unknown record</a></td>
      </tr>
      <tr>
        <td>6</td>
        <td><a>Unchanged record</a></td>
      </tr>
      <tr>
        <td>7</td>
        <td>Reserved for future use</td>
      </tr>
    </table>
  </div>
  <p>
    The <dfn>IL field</dfn> (bit `3`, id length) indicates whether an
    <a>ID LENGTH field</a> is present. If the <a>IL field</a> is `0`, then the
    <a>ID field</a> is not present either.
  </p>
  <p>
    The <dfn>SR field</dfn> (bit `4`, short record) indicates a short record,
    one with a payload length <= `255` bytes. Normal records can have payload
    lengths exceeding `255` bytes up to a maximum of `4` GB. Short records only
    use one byte to indicate length, whether as normal records use `4` bytes
    (`2`<sup>`32`</sup>`-1` bytes).
  </p>
  <p>
    The <dfn>CF field</dfn> (bit `5`, chunk flag) indicates whether the payload
    is <a>chunked</a> across multiple records.
  </p>
  <p class="note">
    Web NFC turns all received chunked records into logical records and
    transparently chunks sent payload when that is needed.
  </p>
  <p>
    The <dfn>ME field</dfn> (bit `6`, message end) indicates whether this record
    is the last in the <a>NDEF message</a>.
  </p>
  <p>
    The <dfn>MB field</dfn> (bit `7`, message begin) indicates whether this
    record is the first of the <a>NDEF message</a>.
  </p>
  <p>
    The <dfn>TYPE LENGTH field</dfn> is an unsigned 8-bit integer that denotes
    the byte size of the <a>TYPE field</a>.
  </p>
  <p>
    The <dfn>TYPE field</dfn> is a globally unique and maintained identifier
    that describes the type of the <a>PAYLOAD field</a> in a structure,
    encoding and format dictated by value of the <a>TNF field</a>.
  </p>
  <p class="note">
    The [[[!NFC-RTD]]] requires that the <a>TYPE field</a> names MUST be
    compared in case-insensitive manner.
  </p>
  <p>
    The <dfn>ID LENGTH field</dfn> is an unsigned 8-bit integer that denotes
    the byte size of the <a>ID field</a>.
  </p>
  <p>
    The <dfn>ID field</dfn> is an identifier in the form of a URI reference
    ([[RFC3986]]) that is unique, and can be absolute of relative (in the
    latter case the application must provide a base URI). Middle and terminating
    chunk records MUST NOT have an <a>ID field</a>, other records MAY have it.
  </p>
  <p>
    The <dfn>PAYLOAD LENGTH field</dfn> denotes the byte size of the
    <a>PAYLOAD field</a>. If the <a>SR field</a> is `1`, its size is one byte,
    otherwise 4 bytes, representing an 8-bit or 32-bit unsigned integer,
    respectively.
  </p>
  <p>
    The <dfn>PAYLOAD field</dfn> carries the application bytes. Any internal
    structure of the data is opaque to NDEF. Note that in certain cases
    discussed later, this field MAY contain an <a>NDEF message</a> as data.
  </p>
  </section>

  <section>
  <h3>
    NDEF Record types
  </h3>
    <section> <h4>Empty NDEF record (TNF 0)</h4>
    <p>
      An <dfn>empty record</dfn>'s' <a>TYPE LENGTH field</a>,
      <a>ID LENGTH field</a> and <a>PAYLOAD LENGTH field</a> MUST be `0`, thus
      the <a>TYPE field</a>, <a>ID field</a> and <a>PAYLOAD field</a> MUST NOT
      be present.
    </p>
    <ndef-record
      header="1,1,0,1,0,0 (EMPTY)"
      content="0,0,_,_,_,_"
      short>
    </ndef-record>
    </section>

    <section>
    <h4>
      Well-known type records (TNF 1)
    </h4>
    <p>
      The NFC Forum has standardized a small set of useful sub record types in
      [[NFC-RTD]] (Resource Type Definition specifications) called
      <dfn>well-known type record</dfn>s, for instance text, URL, media and others.
      In addition, there are record types designed for more
      complex interactions, such as smart posters (containing optional embedded
      records for url, text, signature and actions), and handover records.
    </p>
    <p>
      The type information stored in the <a>TYPE field</a> of
      <a>well-known type records</a> can be of two kinds:
      <a href="#well-known-local-types">local types</a>
      and <a href="#well-known-global-types">global types</a>.
    </p>

    <section><h4>Well-known local types</h4>
      <p>
        NFC Forum <dfn>local type</dfn> that are defined by the NFC Forum or
        by an application, and always start with lowercase character or a
        number. Those are usually short strings that are unique only within
        the local context of the containing record. They are used when the
        meaning of the types doesn't matter outside of the local context of the
        containing record and when storage usage is a hard constraint. See
        <a>Smart poster</a> for an example on how local types are used.
      </p>
      <p class="note">
        A [=local type=] is thus defined in terms of a containing record type,
        and thus doesn't need any namespacing. For this reason the same local
        type name can be used within another record type with different meaning
        and different payload type.
      </p>
    </section>
    </section>  <!-- Well-known (TNF 1) types -->

    <section><h4>Well-known global types</h4>
      <p>
        NFC Forum <dfn>global type</dfn>s are defined and managed by the
        NFC Forum and usually start with an uppercase character.
        Examples: "`T`" for text, "`U`" for URL, "`Sp`" for smart poster,
        "`Sig`" for signature, "`Hc`" for handover carrier, "`Hr`" for
        handover request, "`Hs`" for handover select, etc.
      </p>

    <section> <h5>Text record</h5>
      <div>
        The <dfn>Text record</dfn> is a [=well-known type record=] that is defined
        in the [[NDEF-TEXT]] specification.
        The <a>TNF field</a> is `1` and the <a>TYPE field</a> is "`T`" (`0x54`).
        The first byte of the <a>PAYLOAD field</a> is a status byte, followed
        by the [=language tag=] in US-ASCII encoding.
        The rest of the payload is the actual text, encoded either in UTF-8 or
        UTF-16, as indicated by the status byte as follows:
        <ul>
          <li>Bits 0 to 5 define the length of the [=language tag=].</li>
          <li>Bit 6 is `0`.</li>
          <li>
            If bit 7 if set, means the payload is encoded in UTF-8, otherwise in
            UTF-16.
          </li>
        </ul>
      </div>
    </section>

    <section> <h5>URI record</h5>
      <p>
        <dfn>URI record</dfn> is defined in [[NDEF-URI]].
        The <a>TNF field</a> is `1` and the <a>TYPE field</a> is "`U`" (`0x55`).
        The first byte of the <a>PAYLOAD field</a> is a URI identifier code,
        in fact an index in an abbreviation table where the values are prepended
        to the rest of the URI. For instance the value `0` denotes no prepending,
        `1` denotes "`http://www.`", `0x04` denotes "`https://`"" and so on.
        The rest of the payload contains the rest of the URI as a UTF-8 string
        (and if the first byte is `0`, then it denotes the whole URI).
      </p>
      <p>
        The URI is defined in [[RFC3987]] and in fact is a UTF-8 encoded IRI
        that can be a URN or a URL.
      </p>
    </section>

    <section> <h5>Smart poster record</h5>
    <div>
      <dfn>Smart poster</dfn> is defined in [[NDEF-SMARTPOSTER]] to describe a
      given web content as an NDEF record that contains an <a>NDEF message</a>
      as payload, including the following records:
      <ul>
        <li>
          A single mandatory <a>URI record</a> that refers to the
          <a>smart poster</a> content.
          <p class="note">
            The [[NDEF-SMARTPOSTER]] states that applications SHALL use only the
            <a>smart poster</a> record if it is present in an <a>NDEF message</a>
            that also contains other <a>URI records</a>.
          </p>
        </li>
        <li>
          Zero or more <a>Text records</a> that act as a <dfn>title record</dfn>
          related to the content. When there are more than one title record
          present, they MUST be with different <a>language tags</a>.
          Applications SHOULD select one <a>title record</a> for presentation
          to the end user.
        </li>
        <li>
          Zero or more <a>MIME type records</a> that act as <dfn>icon record</dfn>
          related to the content. The <a>MIME type</a> is usually "`image/jpg`",
          "`image/png`", "`image/gif`", or even "`video/mpeg`".
          Applications SHOULD select one <a>icon record</a> for presentation
          to the end user.
        </li>
        <li>
          One optional <dfn>type record</dfn> that has a [=local type name=]
          "`t`" specific to <a>smart poster</a> and the <a>PAYLOAD field</a>
          contains a UTF-8 encoded MIME type for the content referred to by the
          <a>URI record</a>.
        </li>
        <li>
          One optional <dfn>size record</dfn> that has [=local type name=] "`s`"
          specific to <a>smart poster</a> and the <a>PAYLOAD field</a> contains
          a 4-byte 32 bit unsigned integer that denotes the size of the object
          referred to by the URL in the <a>URI record</a> of the
          <a>smart poster</a>.
        </li>
        <li>
          One optional <dfn>action record</dfn> that has a [=local type name=]
          "`act`" specific to <a>smart poster</a> and the <a>PAYLOAD field</a>
          contains a single byte, whose value has the following meaning:
          <table class="simple">
            <tr>
              <th><strong>Value</strong></th>
              <th><strong>Description</strong></th>
            </tr>
            <tr>
              <td>0</td>
              <td>Do the action</td>
            </tr>
            <tr>
              <td>1</td>
              <td>Save for later</td>
            </tr>
            <tr>
              <td>2</td>
              <td>Open for editing</td>
            </tr>
            <tr>
              <td>3..0xFF</td>
              <td>Reserved for future use</td>
            </tr>
          </table>
          There is no default action on the <a>smart poster</a> content if the
          <a>action record</a> is missing.
          <p class="note">
            At the time of NDEF standardization the value `0` ("do the action") was
            intended for use cases like send an SMS, make a call or launch browser.
            Similarly, the value `1`, ("save the content for later processing") was
            intended for use cases like store the SMS in inbox, save the URL in
            bookmarks, or save the phone number to contacts. Also, the value `2`
            ("open for editing") was meant to open the smart poster content with a
            default application for editing.
          </p>
          <p>
            Implementations don't need to implement any standardized behavior for the
            actions defined here. In this API it's up to the applications what actions
            they define (that may include the use cases above). However, Web NFC
            just provides the values.
          </p>
        </li>
        <li>
          A <a>smart poster</a> MAY also contain other records, which can be
          handled in an application specific manner.
        </li>
      </ul>
    </div>

    <div>
      The example below shows a smart poster record that embeds a text and a
      URL record.
      <ndef-record
        header="1,1,0,1,0,1 (WELL KNOWN)"
        content="*,*,_,'Sp' (0x53 0x70),_,*"
        short>
        <ndef-record slot="payload"
          header="1,0,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'T' (0x54),_,*"
          short noindices>
        </ndef-record>
        <ndef-record slot="payload"
          header="0,1,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'U' (0x55),_,*"
          short noindices>
        </ndef-record>
      </ndef-record>
    </div>
    </section>

    <section> <h5>Signature records</h5>
    <p>
      <dfn>NDEF Signature</dfn> is defined [[NDEF-SIGNATURE]].
      Its <a>TYPE field</a> contains "`Sig`" (`0x53`, `0x69`, `0x67`) and its
      <a>PAYLOAD field</a> contains version, signature and a certificate chain.
    </p>
    <p class="issue" data-number="363">
      As currently spec'ed, this is not supported.
    </p>
    </section>

    <section> <h5>Handover records</h5>
    <p>
      <dfn>NFC handover</dfn> is defined [[NFC-HANDOVER]] and the
      corresponding message structure that allows negotiation and activation of
      an alternative communication carrier, such as Bluetooth or WiFi.
      The negotiated communication carrier would then be used (separately) to
      perform certain activities between the two devices, such as sending photos
      to the other device, printing to a Bluetooth printer or streaming video to
      a television set.
    </p>
    <p class="issue" data-number="364">
      As currently spec'ed, this is not supported.
    </p>
    </section>
    </section> <!-- well-known global types -->

    <section>
    <h4>
      MIME type records (TNF 2)
    </h4>
    <div>
      The <dfn>MIME type record</dfn>s are records that store binary
      data with associated <a>MIME type</a>.
      <ndef-record
        header="*,*,*,*,*,2 (MIME)"
        content="*,*,*,SERIALIZED MIME TYPE,*,MIME TYPE PAYLOAD"
        short>
      </ndef-record>
    </div>
    </section>

    <section>
    <h4>
      Absolute-URL records (TNF 3)
    </h4>
    <p>
      In <dfn>absolute-URL record</dfn>s the <a>TYPE field</a> contains the
      <a>absolute-URL string</a>, and not the payload.
    </p>
    <p class=note>
      NOTE: Some platforms, like Windows Phone have stored additional data
      in the payload, but any payload data in these records are ignored by
      other platforms such as Android. On Android, reading such a record,
      will attempt to load the URL in Chrome and it is as such not intended
      for client applications.
    </p>
    <div>
      <ndef-record
        header="*,*,*,*,*,3 (ABSOLUTE URL)"
        content="*,*,*,ABSOLUTE URL STRING,*,PAYLOAD (optional/ignored)"
        short>
      </ndef-record>
    </div>
    </section>

    <section>
    <h4>
      External type records (TNF 4)
    </h4>
    <p>
      The NFC Forum <dfn data-no-export="">external type record</dfn>s are for
      application specified data types and are defined in [[[NFC-RTD]]].
    </p>
    <p>
      The <dfn>external type</dfn> is a URN with the prefix `"urn:nfc:ext:"` followed by
      the name of the owner [=domain=], adding a `U+003A` (`:`), then a non-zero
      type name, for instance `"urn:nfc:ext:w3.org:atype"`, stored as
      `"w3.org:atype"` in the <a>TYPE field</a>.
    </p>
    <div>
      <ndef-record
        header="*,*,*,*,*,4 (EXTERNAL)"
        content="*,*,*,EXTERNAL TYPE (eg. w3.org:member),*,*"
        short>
      </ndef-record>
    </div>
    </section>

    <section>
    <h4>
      Unknown type records (TNF 5)
    </h4>
    <p>
      The <dfn>unknown record</dfn>s are records that store
      opaque data without associated <a>MIME type</a>, meaning that the
      `application/octet-stream` default <a>MIME type</a> MAY be assumed.
      The [[NFC-NDEF]] specification recommends that <a>NDEF</a> parsers store
      or forward the payload without processing it.
    </p>
    <div>
      <ndef-record
        header="*,*,*,*,*,5 (UNKNOWN)"
        content="0,*,*,_,*,*"
        short>
      </ndef-record>
    </div>
  </section>
  <section>
    <h4>
      Unchanged type records (TNF 6)
    </h4>
    <div>
      The <dfn>unchanged record</dfn>s are record chunks of
      a chunked data set, and is used for any, but the first record.
      A <dfn>chunked</dfn> payload is spread across multiple <a>NDEF record</a>s
      that undergo the following rules:
      <ul>
        <li>
          The initial chunk record has the <a>CF field</a> set, its
          <a>TYPE field</a> set to the type of the whole chunked payload and
          its <a>ID field</a> MAY be set to an identifier used for the whole
          chunked payload. Its <a>PAYLOAD LENGTH field</a> denotes the size of
          the payload chunk in this record only.
        </li>
        <li>
          The middle chunk records have the <a>CF field</a> set, have the
          same <a>ID field</a> as the first chunk, their
          <a>TYPE LENGTH field</a> and <a>IL field</a> MUST be `0` and their
          <a>TNF field</a> MUST be `6` (unchanged).
        </li>
        <li>
          The terminating chunk record has this flag cleared, and in rest
          undergo the same rules as the middle chunk records.
        </li>
        <li>
          A chunked payload MUST be contained in a single <a>NDEF message</a>,
          therefore the initial and middle chunk records cannot have the
          <a>ME field</a> set.
        </li>
      </ul>
    </div>
    <div>
      First record:
      <ndef-record
        header="1,0,1,1,0,*"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Intermediate record:
      <ndef-record
        header="0,0,1,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Last record:
      <ndef-record
        header="0,1,0,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
    </div>
    <p>
      Any implementation of Web NFC MUST transparently expose chunked records
      as single logical records.
    </p>
    </section>
  </section>
</section>  <!-- NFC Standard -->

<section class="informative"> <h3>Use Cases</h3>
  <p>
    A few NFC user scenarios have been enumerated
    <a href="http://www.w3.org/2009/dap/wiki/Near_field_communications_%28NFC%29#Use_cases_submitted_to_DAP_mailing_list">
    here</a> and in the
    <a href="https://w3c.github.io/web-nfc/use-cases.html">Web NFC Use Cases</a>
    document. The rudimentary Web NFC interactions are the following.
  </p>

  <section> <h3>Reading an <a>NFC tag</a></h3>
    <p>
      Reading an <a>NFC tag</a> containing an <a>NDEF message</a>, while the
      {{Document}} of the <a>top-level browsing context</a> using Web NFC is
      <a>visible</a>. For instance, a web page instructs the user to tap an NFC
      tag, and then receives information from the tag.
    </p>
  </section>

  <section> <h3>Writing to an <a>NFC tag</a></h3>
    <div>
      The user opens a web page which can write to an <a>NFC tag</a>. The write
      operations may be one of the following:
      <ol>
        <li>
          Writing to a non-formatted <a>NFC tag</a>.
        </li>
        <li>
          Writing to an empty, but formatted <a>NFC tag</a>.
        </li>
        <li>
          Writing to an <a>NFC tag</a> which already contains an
          <a>NDEF message</a>.
        </li>
        <li>
          Writing to other, writable <a>NFC tag</a>s (i.e. overwriting a
          generic tag).
        </li>
      </ol>
    </div>
    <p class="note">
      Note that an NFC write operation to an <a>NFC tag</a> always involves
      also a read operation.
    </p>
  </section>

  <section> <h3>Support for multiple NFC adapters</h3>
    <p>
      Users may attach one or more external <a>NFC adapter</a>s to their
      devices, in addition to a built-in adapter. Users may use either
      <a>NFC adapter</a>.
    </p>
  </section>
</section> <!-- Use Cases -->

<section class="informative"> <h3>Features</h3>
  <div>
    High level features for the Web NFC specification include the following:
    <ol>
      <li>
        Support devices with single or multiple <a>NFC adapter</a>s.
        If there are multiple adapters present when invoking an NFC function
        then the UA operates all <a>NFC adapter</a>s in parallel.
      </li>
      <li>
        Support communication with passive (smart cards, tags, etc.) NFC devices.
      </li>
      <li>
        Allow users to act on (e.g. read, write or transceive) discovered
        passive NFC devices, as well as access the payload which were read in
        the process as <a>NDEF message</a>s.
      </li>
      <li>
        Allow users to write a payload via <a>NDEF record</a>s to compatible
        devices, such as writable tags, when they come in range, as
        <a>NDEF message</a>s.
      </li>
    </ol>
  </div>
</section> <!-- Features -->

<!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>

  <section><h3>Feature support</h3>
    <p>
      Detecting if Web NFC is supported can be done by checking NDEFReader
      and/or NDEFWriter objects. Note that this does not guarantee that NFC
      hardware is available.
    </p>
    <pre class="example">
      if ('NDEFReader' in window) { /* ... Scan NDEF Tags */ }
      if ('NDEFWriter' in window) { /* ... Write NDEF Tags */ }
    </pre>
  </section>

  <section><h3>General information about writing data</h3>
    <p>
      Writing data is generally straightforward, but there are a few
      gotcha's around how writing works with NFC.
    </p>
    <p>
      An NFC reader works by polling, so in order to be able to
      write to a tag, a tag first needs to be found and read, which
      means that polling needs to be initialized first.
    </p>
    <p>
      If polling is not initiated already by first calling `scan()`,
      then the `write()` method will initiate it temporarily until a
      tag was found and read, and writing to it was attempted.
    </p>
    <p>
      This means that the flow is that first a read it performed
      as the tag is first found, then followed by a write.
    </p>
    <p>
      This means that if `scan()` is running and you have an event
      listener for the `reading` event, it will be dispatched once
      during a `write()` operation, which might not be the intended
      behavior.
    </p>
    <p>
      In the following sections we will discuss how you can easily
      deal with this behavior, but first a few simple examples.
    </p>
  </section>

  <section><h3>Write a text string</h3>
    <p>
      Writing a text string to an NFC tag is straightforward.
    </p>
    <pre class="example">
      const writer = new NDEFWriter();
      writer.write(
        "Hello World"
      ).then(() => {
        console.log("Message written.");
      }).catch(error => {
        console.log(`Write failed :-( try again: ${error}.`);
      });
    </pre>
  </section>

  <section> <h3>Write a URL</h3>
    <p>
      In order to write an NDEF record of URL type, simply use NDEFMessage. Here
      we rely on async/await.
    </p>
    <pre class="example">
      const ndef = new NDEFReader();
      try {
        ndef.write({
          records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
        });
      } catch {
        console.log("Write failed :-( try again.");
      };
    </pre>
  </section>

  <section> <h3>Handling initial reads while writing</h3>
    <p>
      In order to write, a tag needs to be found and thus read. This gives
      you the ability to check whether it is actually a tag that you want to
      write to or not, by checking existing data or serial number.
    </p>
    <p>
      For this reason, it is recommended calling `write()` from a `reading`
      event.
    </p>
      The below example shows how to coordinate between a common `reading`
      handler and one used specifically for a single write.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      let ignoreRead = false;

      reader.onreading(event => {
        if (ignoreRead) {
          return; // write pending, ignore read.
        }

        console.log("We read a tag, but not during pending write!");
      }

      function write(data) {
        ignoreRead = true;
        return new Promise((resolve, reject) => {
          reader.addEventListener("reading", event => {
            // Check if we want to write to this tag, or reject.
            reader.write(data).then(resolve, reject).finally(() => ignoreRead = false);
          }, { once: true });
        });
      }

      await reader.scan();
      try {
        await write("Hello World");
        console.log("We wrote to a tag!")
      } catch(err) {
        console.error("Something went wrong", err);
      }
    </pre>
  </section>

  <section> <h3>Scheduling a write with a timeout</h3>
    <p>
      It can sometime be useful to set a time limit on a write operation.
      Like you ask the user to touch a tag, and if no tag is found within
      a certain amount of time, then you time out.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      reader.onreading(event => console.log("We read a tag!"));

      function write(data, { timeout } = {}) {
        return new Promise((resolve, reject) => {
          const ctlr = new AbortController();
          ctlr.signal.onabort = _ => reject("Time is up, bailing out!");
          if (typeof timeout == "number") {
            setTimeout(() => ctlr.abort(), timeout);
          }

          reader.addEventListener("reading", event => {
            reader.write(data, { signal: ctlr.signal }).then(resolve, reject);
          }, { once: true });
        });
      }

      await reader.scan();
      try {
        // Let's wait for 5 seconds only.
        write("Hello World", { timeout: 5_000 });}
      } catch(err) {
        console.error("Something went wrong", err);
      } finally {
        console.log("We wrote to a tag!");
      }
    </pre>
  </section>

  <section> <h3>Handle scanning errors</h3>
    <p>
      This example shows what happens when {{NDEFReader/scan}} promise rejects and
      {{NDEFReader/onerror}} is fired.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      reader.scan().then(() => {
        console.log("Scan started successfully.");
        reader.onerror = event => {
          console.log("Error! Cannot read data from the NFC tag. Try a different one?");
        };
        reader.onreading = event => {
          console.log("NDEF message read.");
        };
      }).catch(error => {
        console.log(`Error! Scan failed to start: ${error}.`);
      });
    </pre>
  </section>

  <section> <h3>Read a single tag, once</h3>
    <p>
      This example show you how to easily create a convenience function
      that just reads a single tag and then stops polling, saving
      battery life by cutting unneeded work.
    </p>
    <p>
      The example could easily be extended to time out after a given
      amount of milliseconds.
    </p>
    <pre class="example">
      const reader = new NDEFReader();

      function read() {
        return new Promise((resolve, reject) => {
          const ctlr = new AbortController();
          ctlr.signal.onabort = reject;
          reader.addEventListener("reading", event => {
            ctlr.abort();
            resolve(event);
          }, { once: true });
          reader.scan({ signal: ctlr.signal }).catch(err => reject(err));
        });
      }

      read().then(({ serialNumber }) => {
        console.log(serialNumber);
      })
    </pre>
  </section>

  <section> <h3>Read data from tag, and write to empty ones</h3>
    <p>
      This example shows reading various different kinds of data which can be
      stored on a tag. If the tag is unformatted or contains an empty record,
      a text message is written with the value "Hello World".
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan();
      reader.onreading = event => {
        const message = event.message;

        if (message.records.length == 0 ||     // unformatted tag
            message.records[0].recordType == 'empty' ) {  // empty record
          const writer = new NDEFWriter();
          writer.write({
            records: [{ recordType: "text", data: 'Hello World' }]
          });
          return;
        }

        const decoder = new TextDecoder();
        for (const record of message.records) {
          switch (record.recordType) {
            case "text":
              const textDecoder = new TextDecoder(record.encoding);
              console.log(`Text: ${textDecoder.decode(record.data)} (${record.lang})`);
              break;
            case "url":
              console.log(`URL: ${decoder.decode(record.data)}`);
              break;
            case "mime":
              if (record.mediaType === "application/json") {
                console.log(`JSON: ${JSON.parse(decoder.decode(record.data))}`);
              }
              else if (record.mediaType.startsWith('image/')) {
                const blob = new Blob([record.data], { type: record.mediaType });

                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                img.onload = () => window.URL.revokeObjectURL(this.src);

                document.body.appendChild(img);
              }
              else {
                console.log(`Media not handled`);
              }
              break;
            default:
              console.log(`Record not handled`);
          }
        }
      };
    </pre>
  </section>

  <section> <h3>Save and restore game progress with an NFC tag</h3>
    <p>
      Filtering of relevant data sources can be done by the use of
      the <a>NDEFScanOptions</a>. Below we use the custom record identifier
      "`my-game-progress`" as a relative URL so that when we read the data, we
      immediately update the game progress by issuing a write with a custom NDEF
      data layout.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({ id: "my-game-progress" });
      reader.onreading = async event => {
        console.log(`Game state: ${ JSON.stringify(event.message.records) }`);

        const encoder = new TextEncoder();
        const newMessage = {
          records: [{
            id: "my-game-progress",
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              level: 3,
              points: 4500,
              lives: 3
            }))
          }]
        };
        const writer = new NDEFWriter();
        await writer.write(newMessage);
        console.log("Message written");
      };
    </pre>
  </section>

  <section> <h3>Write and read JSON (serialized and deserialized)</h3>
    <p>
      Storing and receiving JSON data is easy with serialization and deserialization.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({
        mediaType: "application/*json"
      });
      reader.onreading = event => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          if (record.mediaType === 'application/json') {
            const json = JSON.parse(decoder.decode(record.data));
            const article =/^[aeio]/i.test(json.title) ? "an" : "a";
            console.log(`${json.name} is ${article} ${json.title}`);
          }
        }
      };

      const writer = new NDEFWriter();
      const encoder = new TextEncoder();
      writer.write({
        records: [
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Benny Jensen",
              title: "Banker"
            }))
          },
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Zoey Braun",
              title: "Engineer"
            }))
          }]
      });
    </pre>
  </section>

  <section> <h3>Write data and print out existing data</h3>
    <p>
      Writing data requires tapping an <a>NFC tag</a>.
    </p>
    <pre class="example">
      const ndef = new NDEFReader();

      ndef.onreading = async event => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          console.log("Record type:  " + record.recordType);
          console.log("MIME type:    " + record.mediaType);
          console.log("=== data ===\n" + decoder.decode(record.data));
        }

        try {
          await ndef.write("Overriding data is fun!");
        } catch(error) {
          console.log(`Write failed :-( try again: ${error}.`);
        }
      };

      ndef.scan();
    </pre>
  </section>

  <section> <h3>Stop listening to NDEF messages</h3>
    <p>
      Read NDEF messages for 3 seconds by using {{NDEFScanOptions/signal}}.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      const controller = new AbortController();

      await reader.scan({ signal: controller.signal });
      reader.onreading = event => {
        console.log("NDEF message read.");
      };

      controller.signal.onabort = event => {
        console.log("We're done waiting for NDEF messages.");
      };

      // Stop listening to NDEF messages after 3s.
      setTimeout(() => controller.abort(), 3_000);
    </pre>
  </section>

  <section> <h3>Write a smart poster message</h3>
    <pre class="example">
      const writer = new NDEFWriter();
      const encoder = new TextEncoder();
      writer.write({ records: [
        {
          recordType: "smart-poster",  // Sp
          data: { records: [
            {
              recordType: "url",  // URL record for the Sp content
              data: "https://my.org/content/19911"
            },
            {
              recordType: "text",  // title record for the Sp content
              data: "Funny dance"
            },
            {
              recordType: ":t",  // type record, a local type to Sp
              data: encoder.encode("image/gif") // MIME type of the Sp content
            },
            {
              recordType: ":s",  // size record, a local type to Sp
              data: new Uint32Array([4096]) // byte size of Sp content
            },
            {
              recordType: ":act",  // action record, a local type to Sp
              // do the action, in this case open in the browser
              data: new Uint8Array([0])
            },
            {
              recordType: "mime", // icon record, a MIME type record
              mediaType: "image/png",
              data: await (await fetch("icon1.png")).arrayBuffer()
            },
            {
              recordType: "mime", // another icon record
              mediaType: "image/jpg",
              data: await (await fetch("icon2.jpg")).arrayBuffer()
            }
          ]}
        }
      ]});
    </pre>
  </section>

  <section> <h3>Read an external record with an NDEF message as payload</h3>
    <p>
      External type records can be used to create application defined records.
      These records may contain an <a>NDEF message</a> as payload,
      with its own <a>NDEF records</a>, including <a>local types</a> that are
      used in the context of the application.
    </p>
    <p>
      Note that the <a>smart poster</a> record type also contains an
      <a>NDEF message</a> as payload.
    </p>
    <p>
      As NDEF gives no guarantee on the ordering of records, using
      an external type record with an <a>NDEF message</a> as payload,
      can be useful for encapsulating related data.
    </p>
    <p>
      This example shows how to read an external record for social posts,
      which contains an <a>NDEF message</a>, containing a text record and
      a record with the <a>local type</a> "act" (action), with definition
      borrowed from <a>smart poster</a>, but used in local application context.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({ recordType: "example.com:smart-poster" });
      reader.onreading = event => {
        const externalRecord = event.message.records.find(
          record => record.type == "example.com:smart-poster"
        );

        let action, text;

        for (const record of externalRecord.toRecords()) {
          if (record.recordType == "text") {
            const decoder = new TextDecoder(record.encoding);
            text = decoder.decode(record.data);
          } else if (record.recordType == ":act") {
            action = record.data.getUint8(0);
          }
        }

        switch (action) {
          case 0: // do the action
            console.log(`Post "${text}" to timeline`);
            break;
          case 1: // save for later
            console.log(`Save "${text}" as a draft`);
            break;
          case 2: // open for editing
            console.log(`Show editable post with "${text}"`);
            break;
        }
      };
    </pre>
  </section>

  <section> <h3>Write an external record with an NDEF message as payload</h3>
    <p>
      External type records can be used to create application defined records
      that may even contain an <a>NDEF message</a> as payload.
    </p>
    <pre class="example">
      const writer = new NDEFWriter();
      writer.write({ records: [
        {
          recordType: "example.game:a",
          data: {
            records: [
              {
                recordType: "url",
                data: "https://example.game/42"
              },
              {
                recordType: "text",
                data: "Game context given here"
              },
              {
                recordType: "mime",
                mediaType: "image/png",
                data: getImageBytes(fromURL)
              }
            ]
          }
        }
      ]});
    </pre>
  </section>

  <section> <h3>Write and read unknown records inside an external record</h3>
    <p>
      Unknown type records may be useful inside external type records as
      developers know what they represent and therefore can avoid specifying the
      mime type.
    </p>
    <pre class="example">
      const encoder = new TextEncoder();
      const writer = new NDEFWriter();
      writer.write({ records: [
        {
          recordType: "example.com:shoppingItem", // External record
          data: {
            records: [
              {
                recordType: "unknown", // Shopping item name
                data: encoder.encode("Food")
              },
              {
                recordType: "unknown", // Shopping item description
                data: encoder.encode("Provide nutritional support for an organism.")
              }
            ]
          }
        }
      ]});
    </pre>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({ recordType: "example.com:shoppingItem" });
      reader.onreading = event => {
        const shoppingItemRecord = event.message.records[0];
        if (!shoppingItemRecord) {
          return;
        }

        const [nameRecord, descriptionRecord] = shoppingItemRecord.toRecords();

        const decoder = new TextDecoder();
        console.log("Item name: " + decoder.decode(nameRecord.data));
        console.log("Item description: " + decoder.decode(descriptionRecord.data));
      };
    </pre>
  </section>
</section> <!-- Usage examples -->

<!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
<section> <h2>Data Representation</h2>
  <section> <h3>The <dfn>NDEFMessage</dfn> interface</h3>
    <p>
      The content of any <a>NDEF message</a> is exposed by the
      <a>NDEFMessage</a> interface:
    </p>
    <pre class="idl">
      [SecureContext, Exposed=Window]
      interface NDEFMessage {
        constructor(NDEFMessageInit messageInit);
        readonly attribute FrozenArray&lt;NDEFRecord&gt; records;
      };

      dictionary NDEFMessageInit {
        required sequence&lt;NDEFRecordInit&gt; records;
      };
    </pre>
    <p>
      The <dfn data-dfn-for="NDEFMessage">records</dfn>
      property represents a <a>list</a> of <a>NDEF record</a>s defining the
      <a>NDEF message</a>.
    </p>
    <p data-dfn-for="NDEFMessageInit">
      The <dfn>NDEFMessageInit</dfn> dictionary is used to initialize an
      <a>NDEF message</a>.
    </p>
  </section>

  <section data-dfn-for="NDEFRecord"> <h3>The <dfn>NDEFRecord</dfn> interface</h3>
    <p>
      The content of any <a>NDEF record</a> is exposed by the
      <a>NDEFRecord</a> interface:
    </p>
    <pre class="idl">
      typedef (DOMString or BufferSource or NDEFMessageInit) NDEFRecordDataSource;

      [SecureContext, Exposed=Window]
      interface NDEFRecord {
        constructor(NDEFRecordInit recordInit);

        readonly attribute USVString recordType;
        readonly attribute USVString? mediaType;
        readonly attribute USVString? id;
        readonly attribute DataView? data;

        readonly attribute USVString? encoding;
        readonly attribute USVString? lang;

        sequence&lt;NDEFRecord&gt;? toRecords();
      };

      dictionary NDEFRecordInit {
        required USVString recordType;
        USVString mediaType;
        USVString id;

        USVString encoding;
        USVString lang;

        NDEFRecordDataSource data;
      };
    </pre>
    <p>
      The <dfn>mediaType</dfn> property represents the <a>MIME type</a> of
      the <a>NDEF record</a> payload.
    </p>
    <p>
      The <dfn>recordType</dfn> property represents the <a>NDEF record</a> types.
    </p>
    <div>
      The <dfn>id</dfn> property represents the <dfn>record identifier</dfn>,
      which is an absolute or relative URL. The required uniqueness of the
      identifier is guaranteed only by the generator, not by this specification.
      <p class=note>
        The NFC NDEF specifications uses the terms "message identifier" and "payload identifier"
        instead of <a>record identifier</a>, but the identifier is tied to each record and not
        the message (collection of records), and it may be present when no payload is.
      </p>
    </div>
    <p>
      The <dfn>encoding</dfn> attribute represents the
      [=encoding/name|encoding name=] used for encoding the payload in the
      case it is textual data.
    </p>
    <p>
      The <dfn>lang</dfn> attribute represents the [=language tag=]
      of the payload in the case that was encoded.
    </p>
    <p>
      A <dfn>language tag</dfn> is a <a>string</a> that matches the
      production of a <code>Language-Tag</code> defined in the [[BCP47]]
      specifications (see the <a href=
      "https://www.iana.org/assignments/language-subtag-registry">IANA
      Language Subtag Registry</a> for an authoritative list of possible
      values). That is, a language range is composed of one or more
      <dfn>subtags</dfn> that are delimited by a U+002D HYPHEN-MINUS ("-").
      For example, the '<code>en-AU</code>' language range represents
      English as spoken in Australia, and '<code>fr-CA</code>' represents
      French as spoken in Canada. Language tags that meet the validity
      criteria of [[RFC5646]] section 2.2.9 that can be verified without
      reference to the IANA Language Subtag Registry are considered
      structurally valid.
    </p>
    <p>
      The <dfn>data</dfn> property represents the <a>PAYLOAD field</a> data.
    </p>
    <p>
      The <dfn>toRecords()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.data bytes</a> with the <a>NDEF Record</a>.
    </p>
    <p data-dfn-for="NDEFRecordInit">
      The <dfn>NDEFRecordInit</dfn> dictionary is used to initialize an
      <a>NDEF record</a> with its <a>record type</a> <dfn>recordType</dfn>, and
      optional <a>record identifier</a> <dfn>id</dfn> and payload data
      <dfn>data</dfn>.
    </p>
    <div data-dfn-for="NDEFRecordInit">
      Additionally, there are additional optional fields that are only applicable
      for certain <a>record types</a>:
      <ul>
        <li data-dfn-for="NDEFRecordInit">
          "<a>mime</a>": Optional <a>MIME type</a> <dfn>mediaType</dfn>.
        </li>
        <li data-dfn-for="NDEFRecordInit">
          "<a>text</a>": Optional [=encoding/label|encoding label=]
          <dfn>encoding</dfn> and [=language tag=] <dfn>lang</dfn>.
        </li>
      </ul>
    </div>
    <p>
      The mapping from data types of an
      <a>NDEFRecordInit</a> to <a>NDEF record</a> types is presented
      in the algorithmic steps which handle the data and described in the
      [[[#steps-receiving]]] and [[[#writing-content]]] sections.
    </p>
    <p>
      To <dfn>convert NDEFRecord.data bytes</dfn>
      given a |record:NDEFRecord|, run these steps:
    </p>
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Let |bytes:byte sequence| be the value of record's <a>data</a> attribute.
      </li>
      <li>
        Let |recordType:record type| be the value of |record|'s
        <a>recordType</a> attribute.
      </li>
      <li>
        If the |recordType| value is "`smart-poster`", then return the result of
        running <a>parse records from bytes</a> given |bytes| and
        `"smart-poster"`.
      </li>
      <li>
        If running <a>validate external type</a> on |recordType| returns `true`,
        then return the result of running <a>parse records from bytes</a> given
        |bytes| and `"external"`.
      </li>
      <li>
        Otherwise, [= exception/throw =] a
        {{"NotSupportedError"}} {{DOMException}} and abort these steps.
      </li>
    </ol>
  </section> <!-- NDEFRecord dictionary -->

  <section>
    <h2>The <dfn>record type</dfn> string</h2>
      <p>
        This string defines the allowed record types for an <a>NDEFRecord</a>. The
        [[[#data-mapping]]] section describes how it is mapped to
        <a>NDEF record</a> types.
      </p>
      <p>
        A standardized <dfn>well known type name</dfn> can be one of the
        following:
      </p>
      <dl>
        <dt>The "<dfn>empty</dfn>" string</dt>
        <dd>
          The value representing an <a href="#empty-ndef-record-tnf-0">empty</a>
          <a>NDEFRecord</a>.
        </dd>
        <dt>The "<dfn>text</dfn>" string</dt>
        <dd>
          The value representing a <a>Text record</a>.
        </dd>
        <dt>The "<dfn>url</dfn>" string</dt>
        <dd>
          The value representing a <a>URI record</a>.
        </dd>
        <dt>The "<dfn>smart-poster</dfn>" string</dt>
        <dd>
          The value representing a <a>Smart poster</a> record.
        </dd>
        <dt>The "<dfn>absolute-url</dfn>" string</dt>
        <dd>
          The value representing an <a>absolute-URL record</a>.
        </dd>
        <dt>The "<dfn>mime</dfn>" string</dt>
        <dd>
          The value representing a <a>MIME type record</a>.
        </dd>
        <dt>The "<dfn>unknown</dfn>" string</dt>
        <dd>
          The value representing an <a>unknown record</a>.
        </dd>
      </dl>
      <p>
        In addition to [=well known type names=] it is also possible for
        organizations to create a custom <dfn>external type name</dfn>,
        which is a string consisting of a [=domain=] name and a custom type name,
        separated by a colon `U+003A` (`:`).
      </p>
      <p>
        Applications MAY also use a <dfn>local type name</dfn>, which is a
        string that MUST start with lowercase character or a number,
        representing a type for an NFC Forum [=local type=]. It is
        typically used in a record of an <a>NDEFMessage</a> that is the payload
        of a parent <a>NDEFRecord</a>, for instance in a <a>smart poster</a>.
        The context of the <a>local type</a> is the parent record whose payload
        is the <a>NDEFMessage</a> to which this record belongs and the
        <a>local type name</a> SHOULD NOT conflict with any other type names
        used in that context.
      </p>
      <p>
        Any implementation of Web NFC MUST transparently expose chunked records
        as single logical records, therefore <a>unchanged record</a>s are not
        explicitly represented.
      </p>
      <p>
        Two <a>well-known type records</a> (including any NFC Forum
        <a>local type</a> and any NFC Forum <a>global type</a>) MUST be compared
        character by character in case-sensitive manner.
      </p>
      <p>
        Two external types MUST be compared character by character, in
        case-insensitive manner.
      </p>
      <p>
        The binary representation of any <a>well-known type record</a> and
        <a>external type</a> MUST be written as a relative URI (RFC 3986),
        omitting the namespace identifier (NID) "`nfc`" and namespace specific
        string (NSS) "`wkt`" and "`ext`", respectively, i.e. omitting the
        "`urn:nfc:wkt:`" and "`urn:nfc:ext:`" prefixes.
        For instance, "`urn:nfc:ext:company.com:a" is stored as "`company.com:a`"
        and the <a>well-known type records</a> of a <a>Text record</a> is
        "`urn:nfc:wkt:T`", but it is stored as "`T`".
      </p>

  </section>

  <section id="data-mapping"><h3>Data mapping</h3>
  <p>
    The mapping from data types of an <a>NDEFRecordInit</a> to
    <a>NDEF record</a> types, as used in the [[[#writing-content]]]
    section is as follows:
  </p>
  <table class="simple" data-link-for="NDEFRecordInit">
    <tr>
      <th>{{recordType}}</th>
      <th>{{mediaType}}</th>
      <th>{{data}}</th>
      <th nowrap><a href="#ndef-record-types">record type</a></th>
      <th nowrap>[=TNF field=]</th>
      <th nowrap>[=TYPE field=]</th>
    </tr>
    <tr>
      <td><dfn>"`empty`"</dfn></td>
      <td><i>unused</i></td>
      <td><i>unused</i></td>
      <td><a>Empty record</a></td>
      <td>0</td>
      <td><i>unused</i></td>
    </tr>
    <tr>
      <td><dfn>"`text`"</dfn></td>
      <td><i>unused</i></td>
      <td>
        {{BufferSource}} or<br>
        {{DOMString}}
      </td>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`T`"</td>
    </tr>
    <tr>
      <td><dfn>"`url`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}}</td>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`U`"</td>
    </tr>
    <tr>
      <td nowrap><dfn>"`smart-poster`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{NDEFMessageInit}}</td>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`Sp`"</td>
    </tr>
    <tr>
      <td>[=local type name=] prefixed by a colon `U+003A` (`:`), e.g., "`:act`", "`:s`", and "`:t`"</td>
      <td><i>unused</i></td>
      <td>
        {{BufferSource}} or {{NDEFMessageInit}}
      </td>
      <td>[=Local type=] record*</td>
      <td>1</td>
      <td>[=local type name=], e.g., "`act`", "`s`", and "`t`"</td>
    </tr>
    <tr>
      <td><dfn>"`mime`"</dfn></td>
      <td>[= MIME type =]</a></td>
      <td>{{BufferSource}}</td>
      <td><a>MIME type record</a></td>
      <td>2</td>
      <td>[= MIME type =]</td>
    </tr>
    <tr>
      <td nowrap><dfn>"`absolute-url`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}} <i>url</i></td>
      <td><a>Absolute-URL record</a></td>
      <td>3</td>
      <td>[=Absolute-URL=]</td>
    </tr>
    <tr>
      <td><i>[=external type name=]</i></td>
      <td><i>unused</i></td>
      <td>
        {{BufferSource}} or<br>
        {{NDEFMessageInit}}
      </td>
      <td><a>External type record</a></td>
      <td>4</td>
      <td>[=external type name=]</td>
    </tr>
    <tr>
      <td><dfn>"`unknown`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{BufferSource}}</td>
      <td>[=Unknown record=]</td>
      <td>5</td>
      <td><i>unused</i></td>
    </tr>
  </table>
  <p>
    * A [=local type=] record has to be embedded with the <a>NDEFMessage</a>
    payload of another record.
  </p>
  <p>
    The mapping from <a>NDEF record</a> types to <a>NDEFRecord</a>,
    as used for incoming <a>NDEF message</a>s described in the
    [[[#steps-receiving]]] section, is as follows.
  </p>
  <table class="simple" data-link-for="NDEFRecord">
    <tr>
      <th><a href="#ndef-record-types">record type</a></th>
      <th nowrap>[=TNF field=]<br></th>
      <th nowrap>[=TYPE field=]</th>
      <th>{{recordType}}</th>
      <th>{{mediaType}}</th>
    </tr>
    <tr>
      <td>[=Empty record=]</td>
      <td>0</td>
      <td><i>unused</i></td>
      <td>"`empty`"</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`T`"</td>
      <td>"`text`"</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`U`"</td>
      <td>"`url`"</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`Sp`"</td>
      <td nowrap>"`smart-poster`"</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td>[=Local type=] record*</td>
      <td>1</td>
      <td>[=local type name=], e.g., "`act`", "`s`", and "`t`"</td>
      <td>[=local type name=] prefixed by a colon `U+003A` (`:`), e.g., "`:act`", "`:s`", and "`:t`"</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td>[=MIME type record=]</td>
      <td>2</td>
      <td>[=MIME type=]</td>
      <td>"`mime`"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
    </tr>
    <tr>
      <td>[=Absolute-URL record=]</td>
      <td>3</td>
      <td>URL</td>
      <td>"`absolute-url`"</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td>[=External type record=]</a></td>
      <td>4</td>
      <td>[=external type name=]</td>
      <td>[=external type name=]</td>
      <td>`null`</td>
    </tr>
    <tr>
      <td><a>Unknown record</a></td>
      <td>5</td>
      <td><i>unused</i></td>
      <td>"`unknown`"</td>
      <td>`null`</td>
    </tr>
  </table>
  </section>
</section> <!-- Data types and content -->


<section> <h2>The NDEFReader and NDEFWriter objects</h2>
  The objects provide a way for the <a>browsing context</a> to
  use NFC functionality.
  They allow for writing <a>NDEF message</a>s to <a>NFC tag</a>s within range,
  and to act on incoming <a>NDEF message</a>s from <a>NFC tag</a>s.
  <pre class="idl">
    typedef (DOMString or BufferSource or NDEFMessageInit) NDEFMessageSource;

    [SecureContext, Exposed=Window]
    interface NDEFWriter {
      constructor();

      Promise&lt;undefined&gt; write(NDEFMessageSource message, optional NDEFWriteOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NDEFReader : EventTarget {
      constructor();

      attribute EventHandler onerror;
      attribute EventHandler onreading;

      Promise&lt;undefined&gt; scan(optional NDEFScanOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NDEFReadingEvent : Event {
      constructor(DOMString type, NDEFReadingEventInit readingEventInitDict);

      readonly attribute DOMString serialNumber;
      [SameObject] readonly attribute NDEFMessage message;
    };

    dictionary NDEFReadingEventInit : EventInit {
      DOMString? serialNumber = "";
      required NDEFMessageInit message;
    };
  </pre>
  <p>
    The <dfn>NDEFMessageSource</dfn> is a union type representing argument types
    accepted by the {{NDEFWriter/write()}} method.
  </p>
  <p data-dfn-for="NDEFReadingEvent">
    The <dfn>NDEFReadingEvent</dfn> is the event being dispatched on new NFC readings.
    The <dfn>serialNumber</dfn> property represents the serial number of
    the device used for anti-collision and identification, or empty string in case none
    is available. The <dfn>message</dfn> is an <a>NDEFMessage</a> object.
  </p>
  <p data-dfn-for="NDEFReadingEventInit">
    <dfn>NDEFReadingEventInit</dfn> is used to initialize a new event with a serial number
    and the <a>NDEFMessageInit</a> data via the <dfn>message</dfn> member.
    If <dfn>serialNumber</dfn> is not present or is `null`,
    empty string will be used to init the event.
  </p>
  <p class="note">
    Though most tags will have a stable unique identifier (UID), not all
    have one and some tags even create a random number on each read.
    The serial number usually consists of 4 or 7 numbers, separated by `:`.
  </p>
  <p>
    The <dfn>NDEFWriter</dfn> is an object used for writing data to an <a>NFC tag</a>.
  </p>
  <p>
    An {{NDEFWriter}} object has the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
    internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody data-link-for="NDEFWriter">
     <tr>
      <td><dfn>[[\WriteOptions]]</dfn></td>
      <td>`null`</td>
      <td>
        The {{NDEFWriteOptions}} value for writer.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\WriteMessage]]</dfn></td>
      <td>`null`</td>
      <td>
        The {{NDEFMessage}} to be written.
        It is initially unset.
      </td>
     </tr>
    </tbody>
  </table>

  <p>
    The <dfn>NDEFReader</dfn> is an object used for reading data when a device,
    such as a tag, is within the magnetic induction field.
  </p>
  <p>
    An {{NDEFReader}} object has the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
    internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody data-link-for="NDEFScanOptions">
     <tr>
      <td><dfn>[[\Id]]</dfn></td>
      <td>`undefined`</td>
      <td>
        The {{NDEFScanOptions}}.<a>id</a> value.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\RecordType]]</dfn></td>
      <td>`undefined`</td>
      <td>
        The {{NDEFScanOptions}}.<a>recordType</a> value.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\MediaType]]</dfn></td>
      <td>`undefined`</td>
      <td>
        The {{NDEFScanOptions}}.<a>mediaType</a> value.
      </td>
      </tr>
      <tr>
        <td><dfn>[[\Signal]]</dfn></td>
        <td>`undefined`</td>
        <td>
          The {{NDEFScanOptions}}.<a>signal</a> to abort the operation.
        </td>
      </tr>
    </tbody>
  </table>

  <p class="note">
    Note that the internal slots of {{NDEFReader}} come from the
    |options:NDEFScanOptions| passed to <a>NDEFReader.scan()</a>.
    Therefore there is maximum one filter associated with any given
    {{NDEFReader}} object and successive invocations of <a>NDEFReader.scan()</a>
    with new |options:NDEFScanOptions| will replace existing filters.
  </p>
  <p>
    The <dfn data-dfn-for="NDEFReader">onreading</dfn> is an {{EventHandler}}
    which is called to notify that new reading is available.
  </p>
  <p>
    The <dfn data-dfn-for="NDEFReader">onerror</dfn> is an {{EventHandler}}
    which is called to notify that an error happened during reading.
  </p>
  <section><h3>NFC state associated with the settings object</h3>
  <p>
    The <a>relevant settings object</a> of the <a>active document</a> of a
    <a>browsing context</a> which supports NFC has an associated
    <dfn>NFC state</dfn> record with the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal
    slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><dfn>[[\Suspended]]</dfn></td>
      <td>`false`</td>
      <td>
        A boolean flag indicating whether NFC functionality is
        <a href="#nfc-suspended">suspended</a> or not, initially
        `false`.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\ActivatedReaderList]]</dfn></td>
      <td>empty <a>set</a></td>
      <td>
        A <a>set</a> of {{NDEFReader}} instances.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\PendingWrite]]</dfn></td>
      <td>empty</td>
      <td>
        A &lt;|promise:Promise|, |writer:NDEFWriter|&gt; tuple where |promise|
        holds a pending {{Promise}} and |writer| holds an {{NDEFWriter}}.
      </td>
      </tr>
    </tbody>
  </table>
  <p>
    The <dfn>activated reader objects</dfn> is the value of the
    <a>[[\ActivatedReaderList]]</a> internal slot.
  </p>
  <p>
    The <dfn>pending write tuple</dfn> is the value of the
    <a>[[\PendingWrite]]</a> internal slot.
  </p>
  <p>
    <dfn id="nfc-is-suspended">NFC is suspended</dfn> if the
    <a>[[\Suspended]]</a> internal slot is `true`.
  </p>
  <p>
    To <dfn id="suspend-nfc">suspend NFC</dfn>, set the <a>[[\Suspended]]</a>
    internal slot to `true`.
  </p>
  <p>
    To <dfn id="resume-nfc">resume NFC</dfn>, set the <a>[[\Suspended]]</a>
    internal slot to `false`.
  </p>
  <p class="note">
    Internal slots are used only as a notation in this specification, and
    implementations do not necessarily have to map them to explicit internal
    properties.
  </p>
  </section>

  <section> <h3>Handling NFC adapters</h3>
    Implementations MAY use multiple <a>NFC adapter</a>s
    according to the algorithmic steps described in this specification.
  </section>

  <section><h3>Obtaining permission</h3>
    <p>
      The
      <a href="https://www.w3.org/TR/permissions/#dictdef-permissiondescriptor">
      <dfn>Web NFC permission name</dfn></a> is
      <a href="https://github.com/w3c/permissions/issues/47">defined</a> as
      "`nfc`".
    </p>
    <div>
      To <dfn>obtain permission</dfn>, run these steps:
      <ol class=algorithm>
        <li>
          Run the
          <a>query a permission</a> steps for the
          <a>Web NFC permission name</a> until completion.
          <ol>
            <li>
              If it resolved with {{PermissionState["granted"]}}
              (i.e. permission has been granted to the <a>origin</a> and
              <a>global object</a> using the [[[PERMISSIONS]]] API),
              return `true`.
            </li>
            <li>
              Otherwise, if it resolved with {{PermissionState["prompt"]}},
              then optionally
              <a data-lt="request permission to use">request permission</a>
              from the user for the <a>Web NFC permission name</a>.
              If that is granted, return `true`.
              <p class="issue" data-number="482">
                The <a data-lt="request permission to use">request permission</a>
                steps are not yet clearly defined.
                At this point the UA asks the user about the policy to be used
                with the <a>Web NFC permission name</a> for the given
                <a>origin</a> and <a>global object</a>, if the user grants
                permission, return `true`.
              </p>
            </li>
          </ol>
        </li>
        <li>
          Return `false`.
        </li>
      </ol>
    </div>
  </section>

  <section><h3>Handling visibility change</h3>
    <p>
      When the user agent determines that the
      <dfn data-cite="PAGE-VISIBILITY#dfn-visibility-states">visibility
      state</dfn> of the [=environment settings object / responsible document=]
      of the <a>current settings object</a> changes, it must run these steps:
    </p>
    <ol class="algorithm">
      <li>Let |document:Document| be the [=environment settings object /
      responsible document=] of the <a>current settings object</a>.
      </li>
      <li>
        If |document|'s <a>visibility state</a> is `"visible"`,
        <a>resume NFC</a> and abort these steps.
      </li>
      <li>
        Otherwise, <a>suspend NFC</a> and attempt to <a>abort a pending
        write operation</a>.
      </li>
    </ol>
    <p>
      The term <dfn id="nfc-suspended">suspended</dfn> refers to NFC
      operations being suspended, which means that no <a>NFC content</a> is
      written by <a>NDEFWriter</a>s, and no received <a>NFC content</a> is
      presented to any {{NDEFReader}} while being suspended.
    </p>
  </section>

  <section><h3>Aborting pending write operation</h3>
  <div>
    To attempt to <dfn>abort a pending write operation</dfn> on an
    <a>environment settings object</a>, perform the following steps:
    <ol class=algorithm>
      <li>
        If there is no <a>pending write tuple</a> |tuple|, abort these steps.
      </li>
      <li>
        If |tuple|'s writer has already initiated an ongoing NFC data transfer,
        abort these steps.
      </li>
      <li>
        Reject |tuple|'s promise with an {{"AbortError"}} {{DOMException}}
        and abort these steps.
        <p class=note>
          Rejecting the promise will clear the <a>pending write tuple</a>.
        </p>
      </li>
    </ol>
  </div>
  </section>

  <section><h3>Releasing NFC</h3>
  <p>
    To <dfn>release NFC</dfn> on an <a>environment settings object</a>,
    perform the following steps:
  </p>
  <ol id="steps-nfc-release">
    <li>
      <a>Suspend NFC</a>.
    </li>
    <li>
      Attempt to <a>abort a pending write operation</a>.
    </li>
    <li>
      Stop the <a>dispatch NFC content</a> steps.
    </li>
    <li>
      Clear the <a>activated reader objects</a>.
    </li>
    <li>
      Release the NFC resources associated with |nfc| on the
      underlying platform.
    </li>
  </ol>
  <p>
    The UA must <a>release NFC</a> given the document's
    <a>relevant settings object</a> as additional
    <a>unloading document cleanup steps</a>.
  </p>
  </section> <!-- release NFC -->

  <section data-dfn-for="NDEFWriteOptions">
    <h3>The <dfn>NDEFWriteOptions</dfn> dictionary</h3>
    <pre class="idl">
      dictionary NDEFWriteOptions {
        boolean overwrite = true;
        AbortSignal? signal;
      };
    </pre>
    <p>
      When the value of the <dfn>overwrite</dfn> property is
      `false`, the <a href="#steps-write">write algorithm</a>
      will read the <a>NFC tag</a> to determine if it has
      <a>NDEF</a> records on it, and if yes, it will not
      execute any pending write.
    </p>
    <p>
      The <dfn>signal</dfn> property allows to abort
      the {{NDEFWriter/write()}} operation.
    </p>
  </section>

  <section data-dfn-for="NDEFScanOptions">
    <h3>The <dfn>NDEFScanOptions</dfn> dictionary</h3>
      <p>
        To describe which messages an application is interested in, the
        <a>NDEFScanOptions</a> dictionary is used:
      </p>
      <pre class="idl">
        dictionary NDEFScanOptions {
          USVString id;
          USVString recordType;
          USVString mediaType;
          AbortSignal? signal;
        };
      </pre>
      <p>
        The <dfn>signal</dfn> property allows to abort the
      {{NDEFReader/scan()}} operation.
      </p>
      <p>
        The <dfn>id</dfn> property
        denotes the string value which is used for matching the
        <a>record identifier</a> of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        If the dictionary member is not present,
        then it will be ignored by the
        <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>recordType</dfn> property
        denotes the string value which is used for matching the
        <a>record type</a> of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        If the dictionary member is not present,
        then it will be ignored by the
        <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>mediaType</dfn> property
        denotes the <a>match pattern</a> which is used for matching the
        {{NDEFRecord/mediaType}} property of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
      </p>
      <pre
        title="Filter accepting only JSON content"
        class="example highlight">
        const options = {
          mediaType: "application/*json"  // any JSON-based MIME type
        }
      </pre>
      <pre
        title="Filter which only accepts binary content for a custom record identifier"
        class="example highlight">
        const options = {
          id: "my-restaurant-daily-menu",
          mediaType: "application/octet-stream"
        }
      </pre>
  </section> <!-- NDEFScanOptions -->

  <section id="writing-content">
    <h3><dfn>Writing content</dfn></h3>
    <p>
      This section describes how to write an <a>NDEF message</a>
      to an <a>NFC tag</a> when it is next time in proximity range before a
      timer expires. At any time there is a maximum of one
      <a>NDEF message</a> that can be set for writing for an <a>origin</a> until
      the current message is sent or the write is aborted.
    </p>
    <section><h3>The <strong>write()</strong> method</h3>
      <div id="steps-write">
        The
        <dfn>NDEFWriter.write</dfn> method, when invoked, MUST run the
        <dfn>write a message</dfn> algorithm:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be a new {{Promise}} object.
          </li>
          <li>
            Let |message:NDEFMessageSource| be the first argument.
          </li>
          <li>
            Let |options:NDEFWriteOptions| be the second argument.
          </li>
          <li>
            Let |signal:AbortSignal| be the |options|‚Äô dictionary member
            of the same name if present, or `null` otherwise.
          </li>
          <li>
            If |signal|‚Äôs [= AbortSignal/aborted flag =] is set, then reject |p|
            with an {{"AbortError"}} {{DOMException}} and return |p|.
          </li>
          <li>
            If |signal| is not `null`, then
            <a data-cite="dom#abortsignal-abort-algorithms">
            add the following abort steps</a> to |signal|:
              <ol>
                <li>
                  Run the <a>abort a pending write operation</a> on the
                  <a>environment settings object</a>.
                </li>
              </ol>
          </li>
          <li>
            [=promise/React=] to |p|:
            <ol>
              <li>
                If |p| was settled (fulfilled or rejected), then clear the
                <a>pending write tuple</a> if it exists.
              </li>
            </ol>
          </li>
          <li>
            Return |p| and run the following steps <a>in parallel</a>:
            <ol>
              <li>
                If the <a>obtain permission</a> steps return `false`, then
                reject |p| with a {{"NotAllowedError"}} {{DOMException}} and
                abort these steps.
              </li>
              <li>
                If there is no underlying <a>NFC Adapter</a>, or if a connection
                cannot be established, then reject |p| with a
                {{"NotSupportedError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                If the UA is not allowed to access the underlying <a>NFC Adapter</a>
                (e.g. a user preference), then reject |p| with a
                {{"NotReadableError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                If pushing data is not supported by the underlying
                <a>NFC Adapter</a>, then reject |p| with a {{"NotSupportedError"}}
                {{DOMException}} and abort these steps.
              </li>
              <li>
                An implementation MAY reject |p| with
                a {{"NotSupportedError"}} {{DOMException}}
                and abort these steps.
                <p class="note">
                  The UA might abort message write at this point. The reasons
                  for termination are implementation details. For example, the
                  implementation might be unable to support the requested
                  operation.
                </p>
              </li>
              <li>
                Let |output| be the notation for the <a>NDEF message</a>
                to be created by UA, as the result of invoking
                <a>create NDEF message</a> with |message| and `""`.
                If this throws an exception, reject |p| with that
                exception and abort these steps.
              </li>
              <li>
                Attempt to <a>abort a pending write operation</a>.
                <p class="note">
                  A write replaces all previously configured write operations.
                </p>
              </li>
              <li>
                Set `this`.[[\WriteOptions]] to |options|.
              </li>
              <li>
                Set `this`.[[\WriteMessage]] to |output|.
              </li>
              <li>
                Set <a>pending write tuple</a> to (`this`, |p|).
              </li>
              <li>
                Run the <a>start the NFC write</a> steps whenever an
                <a>NFC tag</a> |device| comes within communication range.
                <p class="note">
                  If <a>NFC is suspended</a>, continue waiting until promise is
                  aborted by the user or an <a>NFC tag</a> comes within
                  communication range.
                </p>
              </li>
            </ol>
            </li>
          </li>
        </ol>
      </div>

      <div id="steps-start-nfc-write">
        To <dfn>start the NFC write</dfn>, run these steps:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be the <a>pending write tuple</a>'s promise.
          </li>
          <li>
            Let |writer| be the <a>pending write tuple</a>'s writer.
          </li>
          <li>
            Let |options:NDEFWriteOptions| be |writer|.[[\WriteOptions]].
          </li>
          <li>
            If the <a>NFC tag</a> in proximity range does not expose
            <a>NDEF</a> technology for formatting or writing, then
            reject |p| with a {{"NotSupportedError"}} {{DOMException}} and
            return |p|.
          </li>
          <li>
            Verify that <a href="#nfc-is-suspended">NFC is not suspended</a>.
          </li>
          <li>
            In case of success, run the following steps:
            <ol>
              <li>
                If |device| is an <a>NFC tag</a> and if |options|'s overwrite is
                `false`, read the tag to check whether there are <a>NDEF</a>
                records on the tag. If yes, then reject |p| with a
                {{"NotAllowedError"}} {{DOMException}} and return |p|.
              </li>
              <li>
                Let |output:NDEFMessage| be |writer|.[[\WriteMessage]].
              </li>
              <li>
                Initiate data transfer to |device| using
                |output| as buffer, using the <a>NFC adapter</a>
                in communication range with |device|.
                <p class="note">
                  If the <a>NFC tag</a> in proximity range is unformatted and
                  <a>NDEF</a>-formatable, format it and write |output| as
                  buffer.
                </p>
                <p class="note">
                  Multiple adapters should be used sequentially by users.
                  There is very little likelihood that a simultaneous tap
                  will happen on two or multiple different and connected
                  <a>NFC adapter</a>s.
                  If it happens, the user will likely need to repeat the
                  taps until success, preferably one device at a time.
                  The error here gives an indication that the operation
                  needs to be repeated. Otherwise the user may think the
                  operation succeeded on all connected <a>NFC adapter</a>s.
                </p>
              </li>
              <li>
                If the transfer fails, reject |p| with
                {{"NetworkError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                When the transfer has completed, resolve |p|.
              </li>
            </ol>
          </li>
        </ol>
      </div>
    </section>
  </section> <!-- Writing content -->

  <section><h3>Creating NDEF message</h3>
    <div>
      To <dfn>create NDEF message</dfn> given a
      |source:NDEFMessageSource| and |context:string|, run these steps:
      <ol class=algorithm id="create-web-nfc-message">
        <li>Switch on |source:NDEFMessageSource|'s type:
          <dl>
            <dt>{{DOMString}}</dt>
            <ul>
              <li>
                Let |textRecord| be an <a>NDEFrecord</a> initialized with its
                |recordType| set to "`text`" and |data| set to |source|.
              </li>
              <li>
                Let |records| be the list ¬´ |textRecord| ¬ª.
              </li>
              <li>
                Set |source|'s records to |records|.
              </li>
            </ul>
            <dt>{{BufferSource}}</dt>
            <ul>
                <li>
                  Let |mimeRecord| be an <a>NDEFRecord</a> initialized with its
                  |recordType| set to "`mime`", |data| set to |source|, and
                  |mediaType| set to "`application/octet-stream`".
                </li>
                <li>
                  Let |records| be the list ¬´ |mimeRecord| ¬ª.
                </li>
                <li>
                  Set |source|'s records to |records|.
                </li>
            </ul>
            <dt>{{NDEFMessageInit}}</dt>
            <ul>
              <li>
                If |source|'s records [= list/is empty =], [= exception/throw =]
                a {{TypeError}} and abort these steps.
              </li>
            </ul>
            <dt>unmatched type</dt>
            <ul>
              <li>
                [= exception/throw =] a {{TypeError}} and abort these steps.
              </li>
            </ul>
          </dl>
        </li>
        <li>
          Let |output| be the notation for the <a>NDEF message</a>
          to be created by the UA as a result of these steps.
        </li>
        <li>
          [= list/For each =] |record:NDEFRecordInit| in the <a>list</a>
          |source|'s records, run the following steps:
          <ol>
            <li>
              Let |ndef| be the result of running <a>create NDEF record</a>
              given |record:NDEFRecordInit| and |context|, or make sure the
              underlying platform provides equivalent values to |ndef|.
              If the algorithm throws an exception |e|, reject |promise| with
              |e| and abort these steps.
            </li>
            <li>
              Add |ndef| to |output|.
            </li>
          </ol>
        </li>
        <li>
          If running <a>check created records</a> given |output| and |context|
          throw an |error: Error|, reject |promise| with |error| and abort these
          steps.
        </li>
        <li>
          Return |output|.
        </li>
      </ol>
    </div>

    <section><h3>Check created records</h3>
      <div>
        To <dfn>check created records</dfn> given |records: NDEFRecord sequence|
        and |context: string|, run these steps:
        <ol class=algorithm>
          <li>
            If |context| is `"smart-poster"` and |records| does not contain
            exactly one <a>URI record</a>, or if it contains more than one
            <a>type record</a>, <a>size record</a> or <a>action record</a>,
            throw {{TypeError}} and abort these steps.
          </li>
          <li>
            If |context| is `"smart-poster"`, move the <a>URI record</a> to
            the beginning of |records|.
          </li>
        </ol>
        <p class="note">
          Web NFC currently allows writing <a>external type</a> and
          <a>local type</a> records in <a>smart poster</a>.
          Also, <a>empty records</a> are allowed.
          Applications MAY ignore any extra records inside
          the <a>smart poster</a>.
        </p>
        <p class="note">
          Icon record media types could be limited to `"image/"` or `"video/"`,
          but the [[NDEF-SMARTPOSTER]] specification does actually allow other
          media type records in a <a>smart poster</a>, which can be treated in
          an application-specific manner, for instance a vCard contact card
          using one of its associated
          <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">
          MIME types</a>.
        </p>
      </div>
    </section>

    <section><h3>Creating NDEF record</h3>
      <div>
        To <dfn>create NDEF record</dfn> given |record:NDEFRecordInit|
        and |context:string|, run these steps:
        <ol data-link-for="NDEFRecordInit">
          <li>
            Let |ndef| be the representation of an <a>NDEF record</a> to be
            created by the UA.
          </li>
          <li>
            If |record|'s <a>id</a> is not `undefined`:
            <ul>
              <li>
                Let |identifier| be |record|'s <a>id</a>.
              </li>
              <li>
                Set |ndef|'s <a>IL field</a> to `1`.
              </li>
              <li>
                Set |ndef|'s <a>ID LENGTH field</a> to the length of
                |identifier|.
              </li>
              <li>
                Set |ndef|'s <a>ID field</a> to |identifier|.
              </li>
            </ul>
          </li>
          <li>
            Switching on |record|'s <a>recordType</a>, invoke the algorithm
            specified below with |record|, |ndef| and |context| and return the
            result. If an exception |e| is thrown, reject |promise| with |e|
            and abort these steps.
            <dl>
              <dt>"`empty`"</dt>
              <ul>
                <li>
                  <a>map empty record to NDEF</a>.
                </li>
              </ul>
              <dt>"`text`"</dt>
              <ul>
                <li>
                  <a>map text to NDEF</a>.
                </li>
              </ul>
              <dt>"`url`"</dt>
              <ul>
                <li>
                  <a>map a URL to NDEF</a>.
                </li>
              </ul>
              <dt>"`mime`"</dt>
              <ul>
                <li>
                  <a>map binary data to NDEF</a>.
                </li>
              </ul>
              <dt>"`smart-poster`"</dt>
              <ul>
                <li>
                  <a>map smart poster to NDEF</a>.
                </li>
              </ul>
              <dt>"`absolute-url`"</dt>
              <ul>
                <li>
                  <a>map absolute-URL to NDEF</a>.
                </li>
              </ul>
            </dl>
          </li>
          <li>
            If |record|'s <a>recordType</a> starts with a colon `U+003A` (`:`):
            <ul>
              <li>
                If |context| is `""` (i.e. |record| is not a payload to another
                <a>NDEF record</a>), reject |promise| with a {{TypeError}} and
                abort these steps.
              </li>
              <li>
                If running the <a>validate local type</a> steps on |record|'s
                <a>recordType</a> returns `false`, reject |promise| with a
                {{TypeError}} and abort these steps.
              </li>
              <li>
                Return the result of running
                <a>map local type to NDEF</a> given |record|, |ndef| and
                |context|. If that throws an exception |e|, reject |promise|
                with |e| and abort these steps.
              </li>
            </ul>
          </li>
          <li>
            If running <a>validate external type</a> on |record|'s
            <a>recordType</a> returns `true`,
            return <a>map external data to NDEF</a> given |record|, |ndef| and
            |context|. If that throws an exception |e|, reject |promise|
            with |e| and abort these steps.
          </li>
          <li>
            Otherwise, [= exception/throw =] a {{TypeError}} and abort
            these steps.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Validating external type</h3>
      <div>
        The [[NFC-RTD]] specifies that external types MUST contain
        the [=domain=] name of the issuing organization, a colon `U+003A` (`:`)
        and a type name that is at least one character long, for instance
        "`w3.org:member`".
      </div>
      <p>
        The [[NFC-RTD]] specifies the URN prefix ‚Äú`urn:nfc:ext:`‚Äù as well, but
        it is not stored in the <a>NDEF record</a>, therefore Web NFC
        applications SHOULD NOT specify the URN prefix when creating
        <a>external type records</a>.
      </p>
      <p class="note">
        The [[NFC-RTD]] requires that external type names are represented
        with the URN prefix ‚Äú`urn:nfc:ext:`‚Äù, e.g. when reading
        <a>NDEF messages</a>. However, since <a>external type records</a> are
        distinguished by having the <a>TNF FIELD</a> set to `0x04`, there is
        no risk seen for type name clashing. Also, there are
        <a href="https://www.w3.org/2001/tag/doc/URNsAndRegistries-50.html">
        W3C TAG recommendations</a> to avoid using URNs in the Web.
        Therefore, Web NFC does not use the URN prefix neither when reading
        or writing <a>NDEF messages</a>.
      </p>
      <p>
        To <dfn>validate external type</dfn> given |input:USVString|, run
        these steps:
      </p>
      <ol class=algorithm id="validate-external-type">
        <li>
          If |input:string| is not an [=ASCII string=], is empty, or its
          length exceeds 255 bytes, return `false`.
        </li>
        <li>
           Let |domain| be the |input| from the start of |input| up to
           but excluding the first occurrence of `U+003A` (`:`), or `null`
           if that is not found.
        </li>
        <li>
          Let |type| be the |input| after the first occurrence, if any, of
          `U+003A` (`:`) up to the end of |input|, or `null` if that is
          not found.
        </li>
        <li>
          If |domain| or |type| is `null`, return `false`.
        </li>
        <li>
          Let |asciiDomain| be the result of running
          <a href="https://url.spec.whatwg.org/#concept-domain-to-ascii">
          domain to ASCII</a> given |domain| and `true` (as |beStrict|).
        </li>
        <li>
          If |asciiDomain| is failure, return `false`.
        </li>
        <li>
          If |asciiDomain| contains a [=forbidden host code point=] or
          `U+005F` `LOW LINE` (`_`), return `false`.
        </li>
        <li>
          If |type| contains [=code points=] that are not
          [=ASCII alphanumeric=], or `U+0024` (`$`), `U+0027` (`'`),
          `U+0028` `LEFT PARENTHESIS` (`(`), `U+0029` `RIGHT PARENTHESIS` (`)`),
          `U+002A` (`*`), `U+002B` (`+`), `U+002C` (`,`), `U+002D` (`-`),
          `U+002E` (`.`), `U+003B` (`;`), `U+003D` (`=`), `U+0040` (`@`),
          `U+005F` (`_`), return `false`.
        </li>
        <li>
          Return `true`.
        </li>
      </ol>
    </section>

    <section><h3>Validating local type</h3>
      <p>
        To <dfn>validate local type</dfn> given an |input:USVString| run
        these steps:
      </p>
      <ol class=algorithm id="validate-local-type">
        <li>
          Let |localTypeName| be the |input| after the first occurrence of
          `U+003A` (`:`) up to the end of |input|.
        </li>
        <li>
          If |localTypeName| is not a {{USVString}} or its length exceeds 255
          bytes, return `false` and abort these steps.
        </li>
        <li>
          If |localTypeName| does not start with a lowercase character or a
          number, return `false`.
        </li>
        <li>
          If |input| is equal to the <a>record type</a> of any <a>NDEF record</a>
          defined in its containing <a>NDEF message</a>, return `false`.
        </li>
        <li>
          Return `true`.
        </li>
      </ol>
    </section>

    <section><h3>Mapping empty record to NDEF</h3>
      <div>
        To <dfn>map empty record to NDEF</dfn> given a |record:NDEFRecordInit|
        |ndef| and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <!--
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          -->
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If |record|'s <a>id</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>Set the
            |ndef|'s <a>TNF field</a> to `0` (<a>empty record</a>).
          </li>
          <li>Set the
            |ndef|'s <a>IL field</a> to `0`.
          </li>
          <li>Set
            |ndef|'s <a>TYPE LENGTH field</a>,
            and <a>PAYLOAD LENGTH field</a> to `0`,
            and omit <a>TYPE field</a> and <a>PAYLOAD field</a>.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping string to NDEF</h3>
      <div>
        To <dfn>map text to NDEF</dfn> given a |record:NDEFRecordInit|, |ndef|
        and |context:string|, run these steps:
        <p class="note">
          This is useful when clients specifically want to write text in a
          [=well-known type record=].
          Other options would be to use the value "`mime`"
          with an explicit <a>MIME type</a> text type, which allows for
          better differentiation, e.g. when using "`text/xml`", or
          "`text/vcard`".
        </p>
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of |record|'s <a>data</a> is not {{DOMString}} or
            {{BufferSource}}, [= exception/throw =] a {{TypeError}} and abort
            these steps.
          </li>
          <li>
            Let |documentLanguage:string| be the [=document element=]'s
            <a>lang</a> attribute.
          </li>
          <li>
            If |documentLanguage| is the empty string, set it to "`en`".
          </li>
          <li>
            Let |language:string| be |record|'s <a>lang</a> if it [= map/exists =],
            or else to |documentLanguage|.
          </li>
          <li>Switch on the type of |record|'s <a>data</a>:
            <dl>
              <dt>{{DOMString}}</dt>
              <ol>
                <li>
                  If |record|'s <a>encoding</a> is neither `undefined` nor
                  "`utf-8`", [= exception/throw =] a {{TypeError}} and abort
                  these steps.
                </li>
                <li>
                  Let |encoding label:string| be "`utf-8`".
                </li>
              </ol>
              <dt>{{BufferSource}}</dt>
              <ol>
                <li>
                  Let |encoding label:string| be |record|'s <a>encoding</a> if
                  it [= map/exists =], or else "`utf-8`".
                </li>
                <li>
                  If |encoding label| is not equal to "`utf-8`", "`utf-16`",
                  "`utf-16le`" or "`utf-16be`" [= exception/throw =] a
                  {{TypeError}} and abort these steps.
                </li>
              </ol>
            </dl>
          </li>
          <li>
            Let |encoding name| be the [=encoding/name|name=]
            <a data-cite="encoding#concept-encoding-get">obtained</a>
            from |encoding label|.
          </li>
          <li>
            Let |header:byte| be a <a>byte</a> constructed the following way:
            <ol>
              <li>
                If |encoding name| is equal to UTF-8, set bit `7` to the value
                `0`, or else set the value to `1`.
              </li>
              <li>
                Set bit `6` to the value `0` (reserved).
              </li>
              <li>
                Let |languageLength:octet| be the length of the
                |language| <a>string</a>.
              </li>
              <li>
                If |languageLength| cannot be stored in 6 bit
                (|languageLength| > 63), [= exception/throw =] a {{SyntaxError}}.
              </li>
              <li>
                Set bit `5` to bit `0` to |languageLength|.
              </li>
            </ol>
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> (position 0) of |data| to |header|.
              </li>
              <li>
                Set position 1 (second <a>byte</a>) to position |languageLength|
                of |data| to |language|.
              </li>
              <li>Switch on the type of |record|'s <a>data</a>:
                <dl>
                  <dt>{{DOMString}}</dt>
                  <ol>
                    <li>
                      Let |stream:byte stream| be the resulting
                      <a data-cite="encoding#concept-stream">byte stream</a> of
                      running <a>UTF-8 encode</a> on |record|'s <a>data</a>.
                    </li>
                    <li>
                      <a data-cite="encoding#concept-stream-read">Read</a> bytes
                      from |stream| into |data| (from position |languageLength| + 1)
                      until <a data-cite="encoding#concept-stream-read">read</a>
                      returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
                    </li>
                  </ol>
                  <dt>{{BufferSource}}</dt>
                  <ol>
                    <li>
                      Set bytes from |record|'s <a>data</a> into |data|
                      (from position |languageLength| + 1) .
                    </li>
                    </ol>
                </dl>
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            <ol>
              <li>
                Set the |ndef|'s <a>TNF field</a> to `1` (
                [=well-known type record=]).
              </li>
              <li>
                Set the |ndef|'s <a>TYPE field</a> to "`T`" (`0x54`).
              </li>
              <li>
                Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
                to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping URL to NDEF</h3>
      <div>
        To <dfn>map a URL to NDEF</dfn> given a |record:NDEFRecordInit|, |ndef|
        and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If |record|'s <a>data</a> is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |url:URL| be the result of
            <a data-lt="url parser">parsing</a> |record|'s <a>data</a>.
          </li>
          <li>
            If |url| is failure, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |serializedURL:string| be
            <a data-cite="url#concept-url-serializer">serialization</a> of |url|.
          </li>
          <li>
            Match the URI prefixes as defined in [[[NFC-STANDARDS]]],
            URI Record Type Definition specification, Section 3.2.2, against
            the |serializedURL|.
          </li>
          <li>
            Let |prefixString:string| be the matched prefix or else the
            <a href="#dfn-empty">empty</a> <a>string</a>.
          </li>
          <li>
            Let |prefixByte:byte| be the corresponding prefix number,
            or else `0`.
          </li>
          <li>
            Let |shortenedURL:string| be |serializedURL| with
            |prefixString| removed from the start of the <a>string</a>.
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> of |data| to |prefixByte|.
              </li>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of
                running <a>UTF-8 encode</a> on |shortenedURL|.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from
                |stream| into |data| (from position 1) until
                <a data-cite="encoding#concept-stream-read">read</a>
                returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Set the |ndef|'s <a>TNF field</a> to `1`
            ([=well-known type record=]).
          </li>
          <li>
            Set the |ndef|'s <a>TYPE field</a> to "`U`" (`0x55`).
          </li>
          <li>
            Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
          </li>
          <li>
            If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
            to |data|.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping binary data to NDEF</h3>
      <div>
        To <dfn>map binary data to NDEF</dfn> given a |record:NDEFRecordInit|,
        |ndef| and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecord">
          <li>
            If the type of a |record|'s <a>data</a> is not
            {{BufferSource}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Let |mimeType| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on
            |record|'s <a>mediaType</a>.
          </li>
          <li>
            If |mimeType| is failure, let |mimeTypeRecord| be a new
            <a>MIME type record</a> whose type is "`application`", and
            subtype is "`octet-stream`".
          </li>
          <!--
          <li>
            If |context| is `"smart-poster"` and |mimeType| does not
            start with `"image/"` or `"video/"`, throw <a>TypeError</a>
            and abort these steps.
          </li>
          -->
          <li>
            Set |arrayBuffer| to |record|'s <a>data</a>.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Set the |ndef|'s <a>TNF field</a> to `2` (<a>MIME type</a>).
          </li>
          <li>
            Set the |ndef|'s <a>TYPE field</a> to the result of
            <a>serialize a MIME type</a> with |mimeType| as
            the input.
          </li>
          <li>
            Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
          </li>
          <li>
            If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
            to |data|.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping external data to NDEF</h3>
      <div>
        To <dfn>map external data to NDEF</dfn> given a |record:NDEFRecordInit|,
        |ndef| and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <!--
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          -->
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is not
            {{BufferSource}} or {{NDEFMessageInit}}, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `4`
            (<a>external type record</a>).
          </li>
          <li>
            Set the |ndef|'s <a>TYPE field</a> to |record|'s
            <a>recordType</a>.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is {{BufferSource}},
            <ol>
              <li>
                Set |arrayBuffer| to |record|'s <a>data</a>.
              </li>
              <li>
                Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
              </li>
              <li>
                Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
              </li>
              <li>
                Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
                to |data|.
              </li>
            </ol>
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is {{NDEFMessageInit}},
            <ol>
              <li>
                Set the |ndef|'s <a>PAYLOAD field</a> to the result of running
                the <a>create NDEF message</a> given |record|'s <a>data</a>
                and `"external"`.
              </li>
              <li>
                Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to the length of
                |ndef|'s <a>PAYLOAD field</a>.
              </li>
            </ol>
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping local type to NDEF</h3>
      <div>
        To <dfn>map local type to NDEF</dfn> given a |record:NDEFRecordInit|,
        |ndef| and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is not
            {{BufferSource}} or {{NDEFMessageInit}}, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `1`
            ([=well-known type record=]).
          </li>
          <li>
            Let |localTypeName| be the |record|'s <a>recordType</a> after the
            first occurrence of `U+003A` (`:`) up to the end of |record|'s
            <a>recordType</a>.
          </li>
          <li>
            Set |ndef|'s <a>TYPE field</a> to |localTypeName|, representing the
            <a>local type name</a>.
          </li>
          <li>
            If |context| is `"smart-poster"`, |localTypeName| is
            <strong>"`s`" (`0x73`)</strong> and if the type of
            |record|'s <a>data</a> is not {{BufferSource}} or its byte length
            is bigger than 4, [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If |context| is `"smart-poster"`, |localTypeName| is
            <strong>"`act`" (`0x61` `0x63` `0x74`) </strong> and if the type of
            |record|'s <a>data</a> is not {{BufferSource}} or its byte length
            is not exactly one, [= exception/throw =] a {{TypeError}} and abort
            these steps.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is {{BufferSource}},
            <ol>
              <li>
                Set |arrayBuffer| to |record|'s <a>data</a>.
              </li>
              <li>
                Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
              </li>
              <li>
                Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
              </li>
              <li>
                Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
                to |data|.
              </li>
            </ol>
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is {{NDEFMessageInit}},
            <ol>
              <li>
                Set the |ndef|'s <a>PAYLOAD field</a> to the result of running
                the <a>create NDEF message</a> given |record|'s <a>data</a>
                and `"local"`.
              </li>
              <li>
                Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to the length of
                |ndef|'s <a>PAYLOAD field</a>.
              </li>
            </ol>
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping smart poster to NDEF</h3>
      <div>
        To <dfn>map smart poster to NDEF</dfn>, given a |record:NDEFRecordInit|
        |ndef| and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is not
            {{NDEFMessageInit}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `1`
            ([=well-known type record=]).
          </li>
          <li>
            Set |ndef|'s <a>TYPE field</a> to "`Sp`" (`0x53` `0x70`).
          </li>
          <li>
            Set |ndef|'s <a>PAYLOAD field</a> to the result of running the
            <a>create NDEF message</a> given |record|'s <a>data</a> and
            `"smart-poster"`.
          </li>
          <li>
            Set |ndef|'s <a>PAYLOAD LENGTH field</a> to the length of
            |ndef|'s <a>PAYLOAD field</a>.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping absolute-URL to NDEF</h3>
      <div>
        To <dfn>map absolute-URL to NDEF</dfn> given a |record:NDEFRecordInit|
        |ndef| and |context:string|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecord">
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
            <p class="note">
              The [[NDEF-SMARTPOSTER]] specification allows only one URL in
              a <a>smart poster</a> and that MUST be a single <a>URI record</a>.
            </p>
          </li>
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If |record|'s <a>data</a> is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the result of <a data-lt="url parser">parsing</a> |record|'s
            <a>data</a> is failure, [= exception/throw =] a
            {{SyntaxError}} and abort these steps.
          </li>
          <li>
            Set |arrayBuffer| to |record|'s <a>data</a>.
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `3` ([=absolute-URL record=]).
          </li>
          <li>
            Set |ndef|'s <a>TYPE field</a> to |data|.
          </li>
          <li>
            Set |ndef|'s <a>PAYLOAD LENGTH field</a> to `0` and omit <a>PAYLOAD
            field</a>.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>
  </section>

  <section> <h3>Listening for content</h3>
    <p>
      To listen for <a>NFC content</a>, the client MUST activate an
      {{NDEFReader}} instance by calling <a>NDEFReader.scan()</a>. When attaching
      an event listener for the "`reading`" event on it, <a>NFC content</a> is
      accessible to the client.
    </p>
    <p>
      If there are any {{NDEFReader}} instances in <a>activated reader objects</a>
      then the <a>UA</a> MUST listen to <a>NDEF message</a>s on all connected
      NFC adapters.
    </p>
    <p>
      Each {{NDEFReader}} can accept <a>NDEF message</a>s based on
      data type, and record identifier filters.
    </p>

    <section> <h3>Match patterns</h3>
      <div>
        A <dfn>match pattern</dfn> is defined by the following ABNF:
        <pre class="abnf">
          match-pattern  = top-level-type "/" [ tree "." ] subtype [ "+" suffix ] [ ";" parameters ]
          top-level-type = "*" / &lt; VCHAR except "/" and "*" &gt;
          subtype        = "*" / &lt; VCHAR except "+" &gt;
        </pre>
        A <a>match pattern</a> is a
        <a href="http://pubs.opengroup.org/onlinepubs/007904875/utilities/xcu_chap02.html#tag_02_13_03">
        glob</a> used for matching <a>MIME type</a>s,
        for instance the pattern "`application/*+json`" matches
        "`application/calendar+json`", but does not match
        "`application/json`". The pattern
        "`*/*json`", on the other hand, matches both.
      </div>
    </section>

    <section> <h3>The <strong>scan()</strong> method</h3>
      <p>
        Incoming <a>NFC content</a> is matched using {{NDEFReader}} instances.
      </p>
      <div>
        When the <dfn>NDEFReader.scan</dfn> method is invoked, the UA
        MUST run the following
        <dfn id="steps-listen">NFC listen algorithm</dfn>:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be a new {{Promise}} object.
          </li>
          <li>
            Let |reader:NDEFReader| be the {{NDEFReader}} instance.
          </li>
          <li>
            Let |options| be first argument.
          </li>
          <li>
            [= list/For each =] |key| ‚Üí |value| of |options|:
            <ol>
              <li>
                If |key| equals "`signal`" and |value| is not `undefined`, set
                |reader|.<a>[[\Signal]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`id`", set
                |reader|.<a>[[\Id]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`recordType`", set
                |reader|.<a>[[\RecordType]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`mediaType`", set
                |reader|.<a>[[\MediaType]]</a> to |value|.
              </li>
            </ol>
          </li>
          <li>
            If |reader|.<a>[[\Signal]]</a>'s [= AbortSignal/aborted flag =] is
            set, then reject |p| with a {{"AbortError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If |reader|.<a>[[\Signal]]</a> is not `null`, then
            <a data-cite="dom#abortsignal-abort-algorithms">add the following
            abort steps</a> to |reader|.<a>[[\Signal]]</a>:
            <ol>
              <li>
                Remove the {{NDEFReader}} instance from the
                <a>activated reader objects</a>.
              </li>
              <li>
                If the <a>activated reader objects</a> [= list/is empty =],
                then make a request to stop listening to <a>NDEF message</a>s
                on all <a>NFC adapter</a>s.
              </li>
            </ol>
          </li>
          <li>
            Return |p| and run the following steps <a>in parallel</a>:
            <ol>
              <li>
                If the <a>obtain permission</a> steps return `false`, then
                reject |p| with a {{"NotAllowedError"}} {{DOMException}} and
                abort these steps.
              </li>
              <li>
                If there is no underlying <a>NFC Adapter</a>, or if a connection
                cannot be established, then reject |p| with a
                {{"NotSupportedError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                If the UA is not allowed to access the underlying <a>NFC Adapter</a>
                (e.g. a user preference), then reject |p| with a
                {{"NotReadableError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                Add |reader| to the <a>activated reader objects</a>.
              </li>
              <li>
                Resolve |p|.
              </li>
              <li>
                Whenever the <a>UA</a> detects NFC technology, run the
                <a>NFC reading algorithm</a>.
              </li>
            </ol>
          </li>
        </ol>
      </div>
    </section>

    <section><h3>The NFC reading algorithm</h3>
    To receive <a>NDEF</a> content, run the <dfn>NFC reading algorithm</dfn>:
    <ol class=algorithm id="parse-ndef">
      <li>
        If <a>NFC is suspended</a>, abort these steps.
      </li>
      <li>
        If the <a>NFC tag</a> in proximity range does not expose <a>NDEF</a>
        technology for reading or formatting, run the following sub-steps:
        <ol>
          <li>[= list/For each =]
            {{NDEFReader}} instance |reader:NDEFReader| in the
            <a>activated reader objects</a>, run the following sub-steps:
            <ol>
              <li>
                <a>Fire an event</a> named "`error`" at |reader|.
              </li>
            </ol>
          </li>
          <li>
            Abort these steps.
          </li>
        </ol>
      </li>
      <li>
        Let |serialNumber:serialNumber| be the device identifier as a series of
        numbers, or `null` if unavailable.
      </li>
      <li>
        If |serialNumber| is not `null`, set it to the
        <a>string</a> of U+003A (`:`) concatenating each number represented as
        <a>ASCII hex digit</a>, in the same order.
      </li>
      <li>
        Let |message:NDEFMessage| be a new <a>NDEFMessage</a> object, with
        |message|'s records set to the empty <a>list</a>.
      </li>
      <li>
        If the <a>NFC tag</a> in proximity range is unformatted and is
        NDEF-formattable, let |input| be `null`.
        Otherwise, let |input| be the notation for the <a>NDEF message</a>
        which has been received.
        <p class="note">
           The UA SHOULD represent an unformatted <a>NFC tag</a> as an
           <a>NDEF message</a> containing no <a>NDEF record</a>s, i.e. an empty
           array for its {{NDEFMessage/records}} property.
        </p>
      </li>
      <li>
        [= list/For each =] <a>NDEF record</a> which is part of |input|, run the
        following sub-steps:
        <ol>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a> with
            |typeNameField:number| corresponding to the <a>TNF field</a> and
            |payload:byte sequence| corresponding to the <a>PAYLOAD field</a>
            data.
          </li>
          <li>
            Let |record:NDEFRecord| be the result of <a>parse an NDEF record</a>
            given |ndef| and `""`.
          </li>
          <li>
             If |record| is not `null`, <a>append</a> |record| to |message|'s
             records.
          </li>
        </ol>
      </li>
      <li>
        If <a href="#nfc-is-suspended">NFC is not suspended</a>, run the
        <a>dispatch NFC content</a> steps with given |serialNumber|
        and |message|.
      </li>
    </ol>
    </section>

    <section data-link-for="NDEFReadingEvent"><h3>Dispatching NFC content</h3>
    <p>
      To <dfn>dispatch NFC content</dfn> given a |serialNumber:serialNumber|
      of type <a>serialNumber</a> and a |message:NDEFMessage|
      of type <a>NDEFMessage</a>, run these steps:
    </p>
    <ol class=algorithm>
      <li>
        [= list/For each =] {{NDEFReader}} instance |reader:NDEFReader| in
        the <a>activated reader objects</a>, run the following sub-steps:
        <ol>
          <li>
            [= list/For each =] |record:NDEFRecord| in |message:NDEFMessage|,
            <ol>
              <li>
                Let |matched:boolean| be `false`.
              </li>
              <li>
                If |reader|.<a>[[\Id]]</a> is not `undefined` and is not equal
                to |record|'s <a href="#dom-ndefrecord-id">id</a>,
                [= iteration/continue =].
                If it is equal, set |matched| to `true`.
              </li>
              <li>
                If |reader|.<a>[[\RecordType]]</a> is not `undefined` and is
                not equal to |record|'s
                <a href="#dom-ndefrecord-recordtype">recordType</a>,
                [= iteration/continue =].
                If it is equal, set |matched| to `true`.
              </li>
              <li>
                If |reader|.<a>[[\MediaType]]</a> is not `undefined` and is not
                equal to
                |record|'s <a href="#dom-ndefrecord-mediatype">mediaType</a>,
                [= iteration/continue =].
                If it is equal, set |matched| to `true`.
              </li>
              <li>
                If |matched| is `true`,
                <ol>
                  <li>
                    <a>fire an event</a> named "`reading`"
                    at |reader| using <a>NDEFReadingEvent</a> with its
                    <a>serialNumber</a> attribute initialized to |serialNumber|
                    and <a>message</a> attribute initialized to |message|.
                  </li>
                  <li>
                    [= iteration/Break =].
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    </section>
  </section>

  <section id="steps-receiving">
  <h3>Parsing content</h3>

  <section><h3>Parsing records from bytes</h3>
    To <dfn>parse records from bytes</dfn> given |bytes:byte sequence| and
    |context: string|, run these steps:
    <ol class=algorithm>
      <li>
        If the length of |bytes| is `0`, return `null` and abort these steps.
      </li>
      <li>
        Let |records| be the empty list.
      </li>
      <li>
        As long as there are unread bytes of |bytes|, run the following
        sub-steps:
        <ol>
          <li>
            If the remaining length of |bytes| is less than `3`, return `null`
            and abort these sub-steps.
          </li>
          <li>
            If any of the following steps requires reading bytes beyond the
            remaining length of |bytes|, return `null` and abort these
            sub-steps.
          </li>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a>.
          </li>
          <li>
            Let |header:byte| be the next byte of |bytes|.
            <ol>
              <li>
                Let |messageBegin:boolean| (<a>MB field</a>) be the left most
                bit (bit 7) of |header|.
              </li>
              <li>
                If this is the first iteration of these sub-steps and
                |messageBegin| is `false`, return `null` and abort these
                sub-steps.
              </li>
              <li>
                Let |messageEnd:boolean| (<a>ME field</a>) be bit 6 of |header|.
              </li>
              <p class=note>
                As chunked records are not allowed as sub records, ignore bit 5
                (<a>CF field</a>) is ignored.
              </p>
              <li>
                Let |shortRecord:boolean| (<a>SR field</a>) be bit 4 of |header|.
              </li>
              <li>
                Let |hasIdLength:boolean| (<a>IL field</a>) be bit 3 of |header|.
              </li>
              <li>
                Let |ndef|'s |typeNameField:number| (<a>TNF field</a>) be the
                integer value of bit 2-0 of |header|.
              </li>
            </ol>
          </li>
          <li>
            Let |typeLength:number| be the integer value of next byte
            (<a>TYPE LENGTH field</a>) of |bytes|.
          </li>
          <li>
            If |shortRecord| is `true`, let |payloadLength:number|
            be the integer value of next byte (<a>PAYLOAD LENGTH field</a>) of
            |bytes|.
          </li>
          <li>
            Otherwise, let |payloadLength| be the integer value of the next 4
            bytes of |bytes|.
          </li>
          <li>
            If |hasIdLength| is `true`, let |idLength:number| be
            the integer value of next byte (<a>ID LENGTH field</a>) of |bytes|,
            otherwise let it be `0`.
          </li>
          <li>
            If |typeLength| > 0, let |ndef|'s |type:string| be result of
            running <a>UTF-8 decode</a> on the next |typeLength|
            (<a>TYPE field</a>) bytes, or else let |type| be the empty string.
          </li>
          <li>
            If |idLength| > 0, let |ndef|'s |id:string| be result of
            running <a>UTF-8 decode</a> on the next |idLength| (<a>ID field</a>)
            bytes, or else let |ndef|'s |id| be the empty string.
          </li>
          <li>
            Let |ndef|'s |payload| be the <a>byte sequence</a> of the last
            |payloadLength| (<a>PAYLOAD field</a>) bytes, which may be `0` bytes.
          </li>
          <li>
            Let |record:NDEFRecord| be the result of <a>parse an NDEF record</a>
            given |ndef| and |context|.
          </li>
          <li>
            If |record| is not `null`, <a>append</a> |record| to |records|.
          </li>
          <li>
            If |messageEnd| is `true`,
            <ol>
              <li>
                If <a>check parsed records</a> given |records| and |context|
                throws an |error|, reject |promise| with |error| and abort these
                steps.
              </li>
              <li>
                Otherwise abort these sub-steps (terminate the loop).
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        Return |records|.
      </li>
    </ol>
  </section>

  <section><h3>Check parsed records</h3>
    To <dfn>check parsed records</dfn> given |records: NDEFRecord sequence|
    and |context: string|, run these steps:
    <ol class=algorithm>
      <li>
        If |context| is `"smart-poster"` and |records| does not contain
        exactly one <a>URI record</a>, or if it contains more than one
        <a>type record</a>, <a>size record</a> or <a>action record</a>,
        throw {{TypeError}} and abort these steps.
      </li>
      <!--
      <li>
        If |context| is `"smart-poster"` and |records| contain
        [=absolute-URL records=], remove them from |records|.
        <p class="note">
          In other words, remove [=absolute-URL records=] from <a>smart poster</a>,
          as required by the [[NDEF-SMARTPOSTER]] specification.
        </p>
      </li>
      <li>
        If any record in |records| is a <a>smart poster</a>, then remove
        all <a>URI records</a> and [=absolute-URL records=] from |records|.
        <p class="note">
          In other words, remove [=absolute-URL records=] and <a>URI records</a>
          from <a>NDEF messages</a> that contain a <a>smart poster</a> record,
          as required by the [[NDEF-SMARTPOSTER]] specification.
        </p>
      </li>
      -->
      <li>
        Otherwise return `true`.
      </li>
    </ol>
  </section>

  <section><h3>Parsing NDEF records</h3>
  <div>
    To <dfn>parse an NDEF record</dfn> given |ndef| and |context:string| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>id</a> to |ndef|'s |id:string|.
      </li>
      <li>
        Set |record|'s <a>lang</a> to `null`.
      </li>
      <li>
        Set |record|'s <a>encoding</a> to `null`.
      </li>
      <li>
        If |ndef|'s |typeNameField:number| (<a>TNF field</a>) is `0`
        (<a>empty record</a>):
        <ol>
          <li>
            Set |record|'s <a>id</a> to `null`.
          </li>
          <li>
            Set |record|'s <a>recordType</a> to "`empty`".
          </li>
          <li>
            Set |record|'s <a>mediaType</a> to `null`.
          </li>
          <li>
            Set |record|'s <a>data</a> to `null`.
          </li>
        </ol>
      </li>
      <li>
        If |ndef|'s |typeNameField| is `1` ([=well-known type record=]), then
        <ol>
          <li>
            If |ndef|'s |type:string| is <strong>"`T`" (`0x54`)</strong>,
            set |record| to the result of running
            <a>parse an NDEF text record</a> on |ndef|.
          </li>
          <li>
            If |ndef|'s |type:string| is <strong>"`U`" (`0x55`)</strong>,
            set |record| to the result of running
            <a>parse an NDEF URL record</a> on |ndef|.
          </li>
          <li>
            If |ndef|'s |type:string| is <strong>"`Sp`" (`0x53` `0x70`)</strong>,
            set |record| to the result of running
            <a>parse an NDEF smart-poster record</a> on |ndef|.
          </li>
          <li>
            If |ndef|'s |type:string| is <strong>"`s`" (`0x73`)</strong>
            and if |context| is equal to `"smart-poster"`,
            set |record| to the result of running
            <a>parse a smart-poster size record</a> on |ndef|.
          </li>
          <li>
            If |ndef|'s |type:string| is <strong>"`t`" (`0x74`)</strong>
            and if |context| is equal to `"smart-poster"`,
            set |record| to the result of running
            <a>parse a smart-poster type record</a> on |ndef|.
          </li>
          <li>
            If |ndef|'s |type:string| is <strong>"`act`" (`0x61` `0x63` `0x74`)
            </strong> and if |context| is equal to `"smart-poster"`,
            set |record| to the result of running
            <a>parse a smart-poster action record</a> on |ndef|.
          </li>
          <li>
            If running the <a>validate local type</a> steps on
            |ndef|'s |type:string| returns `true`,
            <ol>
              <li>
                If |context| is not `"external"` or `"smart-poster"`,
                [= exception/throw =] a {{TypeError}} and abort these steps.
              </li>
              <li>
                Set |record| to the result of running
                <a>parse a local type record</a> on |ndef|.
              </li>
            </ol>
          </li>
          <li>
            Otherwise [= exception/throw =] a {{TypeError}} and abort these
            steps.
          </li>
        </ol>
      </li>
      <li>
        If |ndef|'s |typeNameField| is `2` (<a>MIME type record</a>), then
        set |record| to the result of running
        <a>parse an NDEF MIME type record</a> on |ndef|, or make sure that
        the underlying platform provides equivalent values to the |record|
        object's properties.
      </li>
      <li>
        If |ndef|'s |typeNameField| is `3` (<a>absolute-URL record</a>),
        then set |record| to the result of running
        <a>parse an NDEF absolute-URL record</a> on |ndef|.
      </li>
      <li>
        If |ndef|'s |typeNameField| is `4` (<a>external type record</a>),
        then set |record| to the result of running
        <a>parse an NDEF external type record</a> on |ndef|, or make sure that
        the underlying platform provides equivalent values to the |record|
        object's properties.
      </li>
      <li>
        If |ndef|'s |typeNameField| is `5` (<a>unknown record</a>)
        then set |record| to the result of running
        <a>parse an NDEF unknown record</a> on |ndef|, or make sure that the
        underlying platform provides equivalent values to the |record| object's
        properties.
      </li>
      <li>
        Otherwise [= exception/throw =] a {{TypeError}} and abort these steps.
      </li>
    </ol>
  </div>
  </section>

  <section><h3>Parsing NDEF well-known `T` records</h3>
  <div>
    To <dfn>parse an NDEF text record</dfn> given an |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`text`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present, set
        |record|'s <a>data</a> to `null` and return |record|.
      </li>
      <li>
        Let |header:byte| be the first <a>byte</a> of |ndefRecord|'s
        <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |languageLength:octet| be the value given by bit `5`
        to bit `0` of the |header|.
      </li>
      <li>
        Let |language:string| be the result of running <a>ASCII decode</a>
        on second <a>byte</a> to the |languageLength| + `1` byte, inclusive.
      </li>
      <li>
        Set |record|'s <a>lang</a> to |language|.
      </li>
      <li>
        Set |record|'s <a>encoding</a> be "`utf-8`" if bit `7` ([=MB field=]) of
        |header| is equal to the value `0`, or else "`utf-16be`".
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        Return |record|.
      </li>
    </ol> <!-- parsing NDEF text record -->
  </div>
  <aside class="note" data-link-for="NDEFRecord">
    <p>
      The Unicode standard defines multiple encodings like UTF-8, UTF-16 and UTF-32.
      UTF-8 is the preferred encoding on the web, and it has the advantage
      that it is endianness agnostic, as [=code points=] are represented in single bytes.
    </p>
    <p>
      The NDEF text records allow the text to be encoded as either UTF-8 or UTF-16.
      Generally, it is preferred to use UTF-8 encoding on the web, but integration
      with existing systems may require UTF-16.
    </p>
    <p>
      The data transmission order and thus the byte order of NDEF is
      defined as big endian (BE) in [[[NFC-NDEF]]], which means that everything is read back with big endian byte ordering.
    </p>
    <p>
      For UTF-16, byte order matters as it might differ between reading and writing
      due to each [=code point=] spanning two bytes. For this reason UTF-16 encoded text
      usually contains a byte order mark (also known as BOM), which is written as
      `0xFEFF`. This means that if the byte order differs between host machine and
      NDEF, then the value will be read back as `0xFFFE`, indicating that the byte
      order should be swapped. The [[[ENCODING]]] differentiates UTF-16 as UTF-16BE
      (big endian) and UTF-16LE (little endian) depending on the byte order.
    </p>
    <p>
      In the case that no byte order mark is present, UTF-16BE encoding should be assumed.
    </p>
    <p>
      Using the <a data-cite="encoding#decoder">decoder</a> with `encoding` set to
      `utf-16`, it will automatically detect whether bytes should be swapped in
      case the byte order mark is present. `utf-16be` can be used to read as big
      endian in case there is no byte order mark.
    </p>
    <p>
      Using the <a data-cite="encoding#encoder">encoder</a>, it is only possible
      to encode as UTF-8, so if UTF-16 is needed, it will have to be encoded
      manually or by using a library.
    </p>
  </aside>
  </section>

  <section><h3>Parsing NDEF well-known `U` records</h3>
  <div>
    To <dfn>parse an NDEF URL record</dfn> given an |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`url`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present,
        set |record|'s <a>data</a> to `null` and return |record|.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |prefixByte:byte| be the value of the first <a>byte</a> of
        |buffer|.
      </li>
      <li>
        If the value of |prefixByte| matches the URL expansion codes in the
        [[[NFC-STANDARDS]]] URI Record Type Definition specification,
        Section 3.2.2, Table 3, then
        <ol>
          <li>
            Let |prefixString:string| be the <a>byte sequence</a> value
            corresponding to the value of |prefixByte|.
          </li>
          <li>
            Set |record|'s <a>data</a> to |prefixString| appended to |buffer|.
          </li>
        </ol>
      </li>
      <li>
        Otherwise, if there is no match for |prefixByte|, set
        |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        Return |record|.
      </li>
    </ol> <!-- parsing NDEF URL record -->
  </div>
  </section>

  <section><h3>Parsing NDEF well-known `Sp` records</h3>
  <div>
    To <dfn>parse an NDEF smart-poster record</dfn> given an |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`smart-poster`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present, set
        |record|'s <a>data</a> to `null` and return |record|.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        Return |record|.
        <p class="note">
          Applications may call <code>toRecords()</code> on <a>data</a> to
          parse it to <a>NDEF records</a>, or may parse it themselves.
        </p>
      </li>
    </ol>  <!-- parsing NDEF smart-poster record -->
  </div>
  <div>
    To <dfn>parse a smart-poster size record</dfn> given an |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`:s`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> has not exactly 4 bytes,
        [= exception/throw =] a {{TypeError}} and abort these steps.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
        <p class="note">
          Applications can parse this value as a 32 bit unsigned integer that
          denotes the size of the object the URI record in the <a>smart-poster</a>
          refers to.
        </p>
      </li>
      <li>
        Return |record|.
      </li>
    </ol>
  </div>
  <div>
    To <dfn>parse a smart-poster type record</dfn> given an |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`:t`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
        <p class="note">
          Applications can parse this value as a string that contains an
          [[RFC2048]] media type that denotes the media type of the object the
          URI record in the <a>smart-poster</a> refers to.
        </p>
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        Return |record|.
      </li>
    </ol>
  </div>
  <div>
    To <dfn>parse a smart-poster action record</dfn> given an |ndefRecord| into
    a |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`:act`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> has not exactly 1 byte,
        [= exception/throw =] a {{TypeError}} and abort these steps.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
        <p class="note">
          Applications can parse this value as an 8 bit unsigned integer for
          which the values are defined <a href="#dfn-action-record">here</a>.
        </p>
      </li>
      <li>
        Return |record|.
      </li>
    </ol>
  </div>
  </section>

  <section><h3>Parsing local type records</h3>
  <div>
    To <dfn>parse a local type record</dfn> given |ndef| into
    a |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`:`" (`U+003A`) concatenated with
        |ndef|'s |type:string|.
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        Return |record|.
      </li>
    </ol>
  </div>
  </section>

  <section><h3>Parsing NDEF MIME type records</h3>
    <div>
      To <dfn>parse an NDEF MIME type record</dfn> given an |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to "`mime`".
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to the
          result of <a>serialize a MIME type</a> with |mimeType| as
          the input.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise
          `null`.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          Return |record|.
        </li>
      </ol> <!-- parsing NDEF MIME type record -->
    </div>
  </section>

  <section><h3>Parsing NDEF absolute-URL records</h3>
    <div>
      To <dfn>parse an NDEF absolute-URL record</dfn> given an |ndefRecord| into
      a |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to "`absolute-url`".
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to `null`.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>TYPE field</a>.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          Return |record|.
        </li>
      </ol>  <!-- parsing NDEF absolute URI record -->
    </div>
  </section>

  <section><h3>Parsing NDEF external type records</h3>
    <div>
      To <dfn>parse an NDEF external type record</dfn> given an |ndefRecord| into
      a |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to the
          value of |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to `null`.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise
          `null`.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          Return |record|.
        </li>
      </ol>  <!-- parsing NDEF external type record -->
    </div>
  </section>

  <section><h3>Parsing NDEF unknown type records</h3>
    <div>
      To <dfn>parse an NDEF unknown record</dfn> given an |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to "`unknown`".
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to `null`.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise
          `null`.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          Return |record|.
        </li>
      </ol>  <!-- parsing NDEF unknown record -->
    </div>
  </section>
</section>
</section>

<!-- - - - - - - - - - - - - - - The Blocklist - - - - - - - - - - - - - - - -->
<section> <h2 id="blocklist">The Blocklist</h2>
  <p>
    This specification relies on a blocklist file to restrict the set of NFC
    devices a website can access.
  </p>
  <p>
    The result of <dfn>parsing the blocklist</dfn> at a |url:URL| is a list of
    historical bytes hexadecimal values, produced by the following algorithm:
    <ol class=algorithm>
      <li>
        Fetch |url:URL|, and let |contents:string| be its body, decoded as UTF-8.
      </li>
      <li>
        Let |lines:array| be |contents| split on `"\n"`.
      </li>
      <li>
        Let |result:list| be an empty <a>list</a>.
      </li>
      <li>
        [= list/For each =] |line:string| in |lines|, run the following sub-steps:
        <ol>
          <li>
            If |line| is empty, continue to the next line.
          </li>
          <li>
            If |line| starts with `"#"`, continue to the next line.
          </li>
          <li>
            If |line| contains invalid hexadecimal values, continue to the next line.
          </li>
          <li>
            <a>Append</a> |line| to |result|.
          </li>
          </li>
        </ol>
      </li>
      <li>
        Return |result|.
      </li>
    </ol>  <!-- parsing the blocklist -->
  </p>
  <p>
    The <dfn>blocklist</dfn> is the result of <a>parsing the blocklist</a> at
    <a
    href="https://github.com/w3c/web-nfc/blob/gh-pages/blocklist.txt">https://github.com/w3c/web-nfc/blob/gh-pages/blocklist.txt</a>.
    The UA should re-fetch the blocklist periodically, but it‚Äôs unspecified how
    often.
  </p>
  <p>
    An <a>NFC device</a> is <dfn>blocklisted</dfn> if the <a>blocklist</a>‚Äôs
    value contains the device's <a>historical bytes</a> hexadecimal values. In
    ISO 14443-4 terminology, the <dfn>historical bytes</dfn> are a subset of the
    RATS (Request for Answer To Select) response.
  </p>
</section>

<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2 id="security">Security and Privacy</h2>
  <section> <h3>Chain of trust</h3>
    <p>
      Implementations need to make sure that when the user authorizes a method which is part of the Web NFC API, only that action is run, without side effects.
    </p>
    <p>
      By default, NDEF doesn't provide any way to make the content trusted
      beyond allowing tags to be made permanently read-only after writing
      data to them. This can even be done from a factory setting.
    </p>
    <p>
      Data written by the use of this API is not signed or encrypted automatically,
      which follows existing native NFC APIs. In order to protect the
      integrity and authenticity of NDEF messages, the NFC Forum introduced
      [[NDEF-SIGNATURE]]. Using <a>NDEF signature</a> and
      key management is the responsibility of the application.
    </p>
    <p>
      For trusting the <strong>confidentiality</strong> of the data exchanged
      via NFC, applications may use encrypted <a>NFC content</a>.
    </p>
    <p>
      For trusting the <strong>integrity</strong> of the data exchanged via NFC,
      applications may use an <a>NDEF signature</a>, with key management based
      on Public Key Infrastructure (PKI).
    </p>
    <p>
      Security considerations for MIME types in general are discussed in
      [[RFC2048]] and [[RFC2046]].
    </p>
  </section>
  <section> <h3>Privacy implications and implementation considerations</h3>
    <p>
      The comparison to barcodes or QR codes is appropriate because NFC tags
      are another non-human-readable method of exchanging data and sharing
      them can have unforeseen privacy and security implications. For a web
      site to read a QR code, a piece of interruptive UI must be used (the
      camera) which captures an image and makes it apparent that the contents
      of this image (including the QR code) will be available to the web page,
      making it clear to the user that scanning is being performed.
    </p>
    <p>
      Scanning a tag with NFC requires the user to place the scanning device
      (e.g. phone) in close proximity to the NFC tag - usually 5-10 cm, 2-4
      inches.
    </p>
    <p>
      Scanning a tag when a Web NFC scan is not active, triggers the host OS
      handling. Thus launching URLs and apps from scanning a NFC tag is not
      handled and supported by Web NFC itself.
    </p>
    <p>
      Furthermore, Web NFC scanning needs to be activated from a user interaction,
      and scanning is paused when the web site is not in focus or the device
      screen turns off (i.e. is not unlocked). This is put in place so that
      accidental scans are not likely to happen.
    </p>
    <p>
      Web NFC further recommends that the implementation makes it very clear
      UX-wise to the user that data will be scanned when placing the scanning
      device in close proximity to a NFC tag - basically mimicking the UX flow
      of scanning a QR code.
    </p>
    <p>
      There are many options for doing so, like playing back a sound or showing
      some persistent UI while the scanning can happen, for instance a modal
      dialog with the ability to cancel at any point.
    </p>
    <img class="illustration" src="images/scan.jpg">
    <p>
      An implementation could also show the data that is about to be uploaded,
      postpone sharing the read data until the user OK'd it and even show some
      UI allowing the user to select which records to share.
    </p>
    <img class="illustration" src="images/approve.jpg">
    <section> <h4>Reading and writing during a scan</h4>
      <p>
       When the user scans a tag, at that point the web application has access
       to read the data on the tag, and in case it is not read-only, also to
       write data to the tag. Consumer stickers for private usage (e.g. in the
       maker community) are often unlocked (read + write), whereas commercial
       deployment of NFC are read-only.
      </p>
      <p class="note">
        An older protocol SNEP (Simple NDEF Exchange Protocol) allowed active
        devices (e.g. a phone) to receive NDEF data from another active device,
        but it is unsupported by Web NFC and it is currently being deprecated
        on supported native platforms.
      </p>
      <p class="note">
        A newer protocol TNEP (Tag NDEF Exchange Protocol) allows bidirectional
        communication between a scanner device (e.g. phone) and actively powered
        device like an IOT device. It is currently unsupported by Web NFC, and
        furthermore it has restrictions on what input to accept and the IOT device
        must ensure that the accepted records are valid.
      </p>
      <p>
        If the tag contains privacy sensitive data, such data will be shared with
        the site. Potentially, not immediately if the UX requires the user to
        confirm the data exchange before doing so.
      </p>
      <p>
        In some cases it might be obvious that the tag/device contains privacy
        sensitive data, say in case of NFC equipped conference badgets and business
        cards. This would also be the case with an NFC equipped glucose meter,
        which can indicate that you, or someone in the close family, are a diabetes
        patient.
      </p>
      <p>
        In other cases it might be less obvious that that can happen, but a user
        might have used an app or website to write data to a tag that unknowingly
        to the user encoded a user id or the like, which can later be read back
        by any other site.
      </p>
      <p>
        Private and unexpected data can also be stored in files (e.g. word
        pressing documents, PDFs or camera images) which are uploaded using
        the file upload API. The mitigations associated with the Web NFC API
        are stronger than those associated with file upload and the data less
        likely to be personally identifiable.
      </p>
    </section>
    <section> <h4>Reading and writing during a scan</h4>
      <p>
        A scan of a tag might also reveal user location if the website knows
        how to identify the tag and know the tags location in the real world,
        like if it is mounted inside a museum. It might also be able to deduct
        it somewhat as for instance FeliCa NFC tags are mostly used in Japan,
        but Web NFC doesn‚Äôt reveal what tag technology is used.
      </p>
      <p>
        This does not bring the web advertising and tracking model into the
        real world, because it requires an action by the user and it cannot
        be triggered in the background; and with proper UX it should be clear
        that scanning is active.
      </p>
    </section>
    <section> <h4>Overwriting existing data</h4>
      <p>
        There is also the fear that writing to a NFC tag can ruin it or
        ‚Äúbrick it‚Äù. As NFC tags were designed to be read by multiple user
        applications, NDEF tags have been designed with an easy way to make
        devices permanently read-only and can even be configured that way
        from a factory.
      </p>
      <p>
        NDEF is a simple exchange format for reading and writing data and
        not for bi-directional communication. NFC supports multiple
        communications formats based on lower tech (thus not locked as
        read-only as NDEF) and none of these are supported by Web NFC.
      </p>
    </section>
  </section>

  <section> <h3>Things that users should be made aware of when using NFC</h3>
    <p>
      This section details some of the things that users ought to be aware
      of when using NFC. It is recommendated that implementations help educate
      the users of given facts before or when related NFC actions are performed.
    </p>
    <h4>Data that is read is shared with site</h4>
    <p>
      When a site has access to read NFC content, then the data of the scanned
      tags is shared with the site, in a similar way to uploading files and images.
      As with any site, it is up to the user whether to trust that the site handles this data properly and in the
      intended manner.
    </p>
    <h4>A site may modify and overwrite data of tags that are not made read-only</h4>
    <p>
      Deployed NFC solutions, like tags in stores etc, should always be made
      read-only in order to ensure they are not modified by mistake or as part
      of a malicious act.
    </p>
    <p>
      Private tags and stickers are often unlocked (writable) from the factory
      and the user should be aware that such tags might be overwritten/modified
      by scanning them.
    </p>
    <h4>Reading a fixed (e.g. mounted) tag may expose reading location</h4>
    <p>
      A fixed tag may encode its ID or location in the data, meaning that reading
      it exposes that information to the site that knows the physical location of the tag, which then can deduct the location
      the read took place. That combined with being logged into a service, can
      share your location data with the site.
    </p>
    <p>
      Data written is readable by other apps and sites with granted read access
      Any NDEF data on a tag can be read by any app or web site with the proper
      access, so if that is not intended then the data should be encrypted in a
      secure manner that only who is supposed to read it can.
    </p>
    <h4>Multiple tags may be within the reading field at the same time</h4>
    <p>
      NFC can only read one tag at the time, but multiple tags can be detected
      and one of the tags can be selected as the tag to communicate with.
    </p>
    <p>
      Use cases for this could be having multiple smart cards (NFC based) in
      your wallet and not wanting to take the card out.
    </p>
    <p>
      This is mostly useful for payment cards and travel cards that are read
      by external hardware and thus not a use-case for Web NFC. For Web NFC,
      we do not allow reading when there are multiple tags available, preventing the following attack vector.
    </p>
    <p>
      There is an attack vector, where someone places another malicious NFC
      tag/sticker on top of a legitimate tag, in order to load the wrong
      app/site, or inject wrong data into the right app/site. They can
      do so by cloning the data of the original tag and modifying it -
      either by changing the URL to load a malicious app/site, or by
      changing the data to inject malicious data in the right app/site.
      Example: the tag is supposed to take you to <a href="https://example.com">https://example.com</a> but is modified
      to take you to <a href="https://ex–∞mple.com">https://ex–∞mple.com</a> (that is with a Cyrillic –∞) - it looks legitimate
      and you might now to giving sensitive data to a malicious site.
    </p>
    <p>
      Loading web sites from a tag is outside the scope of Web NFC, but it
      is recommended for user agents to not auto load URLs when multiple
      tags are available due to the above attack vector.
    </p>
    <p>
      By disallowing reading when there are multiple tags available, Web
      NFC protects well against injecting wrong/malicious data into a site
      as shielding the existing NFC tag is quite difficult as it requires
      ferrite shielding which is quite visible. Metal interferes with the
      magnetic field and makes tags not readable.
    </p>
  </section>

  <section class="informative"> <h2>Assets</h2>
    <div>
      Assets to be protected include the following:
      <ul>
        <li>
          <strong>NDEF message</strong> as a whole,
          <strong>NDEF records</strong> (including payload and header) in
          particular, either in-transfer or in-storage state,
          when they are being overwritten by a Web NFC triggered operation,
          against data disclosure and data modification.
          This also includes Denial of Service attacks against a solution
          deployed with NFC tags (e.g. a malicious actor destroying tags linked
          to a solution).
        </li>
        <li>
          <strong>User identity or other privacy sensitive attributes</strong>
          that can be directly or indirectly determined by using Web NFC, by the
          <a>NFC content</a> creator, or by a web site using Web NFC.
          This data could be used directly or leaked forward to third parties.
          Examples are user location, device identifiers and user identifiers.
        </li>
        <li>
          <strong>User data</strong> exposed to a web page using Web NFC.
          While a web page might collect user data using other means than
          Web NFC, it might embed this data into NDEF records and share via
          Web NFC.
        </li>
        <li>
          <strong>Integrity of user device</strong>.
          A read of an NFC tag might result in a user device compromise
          that can further lead to loss of other web NFC or platform assets.
        </li>
      </ul>
    </div>
  </section>

  <section class="informative"> <h2>Attacker model</h2>
    <p>
      The following attacker patterns have been considered:
      <ul>
        <li>
          <strong>Malicious web page creator</strong>: phishing user data,
          identity or other privacy sensitive attributes, destroying or
          modifying NFC tags to cause further damage through fake identities
          and attack vectors.
        </li>
        <li>
          <strong>Malicious NFC tag creator</strong>: same as above, but with the
          additional possibility to create, delete or modify the NFC
          tags locally.
          As a result can compromise integrity of user device, cause data
          injection, redirect to malicious web page, phishing user location,
          causing side actions such as installing applications, trigger
          automated dispatching or other actions.
        </li>
        <li>
          <strong>Compromised device or user agent: man-in-the-middle (MITM) attack</strong>:
          any MITM style attack between Web NFC implementation and an <a>NFC adapter</a>
          in a user device, including attempts to interact with a web site using
          Web NFC by presenting modified or replayed NDEF records.
        </li>
      </ul>
    </p>
  </section>

  <section class="informative"> <h3>Threats</h3>
    <p>
      An introduction to NFC security is found <a href="https://resources.infosecinstitute.com/near-field-communication-nfc-technology-vulnerabilities-and-principal-attack-schema/">here</a>.
      Potential threats for Web NFC are given below.
    </p>

    <section> <h4>Fingerprinting and data collection</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          Malicious web page collects user data, identity or other privacy
          sensitive attributes (such as location) without user consent and
          exposes it to third parties (writing it to NFC tags).
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          User data, user identity or other privacy sensitive attributes
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious web page owner using Web NFC, malicious tag owner.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          The user SHOULD be able to be aware of what data can be shared using
          NFC from the given web page.
          Use permissions and user prompts for accessing personal data,
          minimize user data exposed to NFC.
          An NFC tag SHOULD NOT ever trigger a user‚Äôs device to navigate
          to a web site without asking permission, unless the site has been in
          the foreground or has been brought to the foreground and has been
          granted permission. User agents SHOULD take into account the
          security and privacy measures listed in the
          <a href="http://dev.w3.org/geo/api/spec-source.html#security">
          Geolocation API</a>.
        </dd>
      </dl>
    </section>

    <section> <h4>NFC tag modification</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          An NFC tag is being modified without user consent.
          This might enable further attacks using a malicious tag
          or can be a Denial of Service attack to make one or more tags
          unusable.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          NDEF message records, including payload and header in-storage.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious web page creator, malicious user.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          Require permission and user prompt needed for writing tags.
          Or, control what tags can be written by a given web page, for instance
          a web page can write only a tag that can be connected to its
          <a>origin</a>.
          Or, allow overwriting since tags not meant to be written can be
          protected by making them read only.
          Use <a>NDEF signature</a> to detect a modification of NFC tags.
        </dd>
      </dl>
    </section>

    <section> <h4>NDEF record modification in-transit</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          <a>NDEF record</a>s transferred between Web NFC and the
          <a>NFC adapter</a> and user device are modified to cause various
          man-in-the-middle attacks or denial-of-service (DoS) attacks.
          Also, <a>NDEF signature</a> records can be removed or
          replaced along with changed content.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          <a>NDEF record</a>s in-transfer.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious man-in-the-middle user.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          This threat is out of scope for Web NFC implementations.
          Applications can use <a>NDEF signature</a>s and appropriate tools
          (signature algorithm, certificates, security policies) to protect the
          <a>NFC content</a>. Additionally, harden the platform stack.
        </dd>
      </dl>
    </section>

    <section> <h4>NDEF record payload disclosure</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          Confidential payload of <a>NDEF record</a> in-storage (stored
          on an NFC tag) or in-transfer between Web NFC and the
          <a>NFC adapter</a> are read by unauthorized parties.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          Confidential NDEF message payload in-transfer and in-storage.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious man-in-the-middle user, malicious web page creator.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          To ensure confidentiality, use payload encryption and secure
          communication for data exchange, authentication and authorization
          between Web NFC and <a>NFC adapter</a>s.
        </dd>
      </dl>
    </section>

    <section> <h4>Active attack via malicious NFC tag</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          Malicious tag may be involuntarily or voluntarily read by devices
          and the data read may constitute an attack vector on the user agent.
          For example it can attempt to trigger an action on
          the device, which may be a threat, for instance launching a malicious
          web site, or opening an image prepared for attacking the device.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          Integrity of user device, all other Web NFC assets.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious tag creator.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          This is a generic problem with all existing NFC tags.
          The data is considered application specific.
          Implementations need security hardening.
          Involuntary touch is low probability due to short range and critical
          angle for reading, and due to the focus requirements.
          Automatic actions for smart posters and other tags should not be
          allowed. The user must be made aware and given the ability to control
          what is happening during the NFC communication. For instance, opening
          content from <a>smart poster</a>, automatic connection to (possibly
          malicious) WiFi via <a>NFC handover</a>, etc.
          Do no allow actions from untrusted NFC tags, trust can be established
          via the <a>NDEF signature</a> check.
        </dd>
      </dl>
    </section>
  </section>

  <section class="informative"> <h2>Security mechanisms for implementations</h2>
    <section> <h3><dfn>Obtaining permission</dfn></h3>
      <p>
        Implementations SHOULD use a mechanism to <a>obtain permission</a>,
        for instance an explicit permission given by the user.
        The [[[PERMISSIONS]]] API is suggested to be used by UAs
        for implementing NFC related permissions.
      </p>
      <p>
        Implementations MAY use per-session/ephemeral permissions.
      </p>
    </section>
    <section> <h3><dfn>Warning user during NFC operations</dfn></h3>
      <p>
        Implementations MAY show an overlay dialog whenever the NFC adapter is
        being accessed by the web page (e.g. there is an ongoing scan) in order
        to warn user.
      </p>
    </section>
  </section>
  <section class="informative"> <h2>Security mechanisms for applications</h2>
    <section> <h3>Encrypting <a>NFC content</a></h3>
      <p>
        For trusting the confidentiality of the data exchanged via NFC,
        applications may use encrypted <a>NFC content</a> with key management
        based on Public Key Infrastructure (PKI).
        Key management is out of the scope of Web NFC.
      </p>
    </section>

    <section> <h3>Signing NDEF records</h3>
      <p>
        For trusting the integrity of the data exchanged via NFC, user agents
        MAY use an <a>NDEF signature</a> with a Public Key Infrastructure
        for key management.
      </p>
      <p>
        For tags signed with <a>NDEF signature</a> version 1.0 ([[NFC-SECURITY]]),
        the signature is applied only to the <a>TYPE field</a>, <a>ID field</a>
        and <a>PAYLOAD field</a>, leaving out the first byte of the NDEF header,
        allowing surface to attacks. Version 2.0 of [[NFC-SECURITY]] included
        tag hardware attributes in the signature and allowed for shorter
        certificates.
      </p>
      <p>
        An <a>NDEF signature</a> covers the preceding records until another
        <a>NDEF signature</a> or the beginning of the <a>NDEF message</a> is
        reached.
      </p>
      <p>
        In order to mitigate <a href="https://www.researchgate.net/publication/224227216_Security_Vulnerabilities_of_the_NDEF_Signature_Record_Type">
        known vulnerabilities</a> of <a>NDEF signature</a>, it is recommended
        that applications always sign a full <a>NDEF message</a> with a single
        <a>NDEF signature</a>, and use the right tool chain and security
        policies for creating and verifying signatures.
      </p>
    </section>

  </section>

  <section> <h3>Security policies</h3>
    <p>
      This section lists the normative security policies for implementations.
    </p>

    <section> <h4>Secure Context</h4>
      <p>
        Only <a>secure contexts</a> are allowed to access <a>NFC content</a>.
        Browsers MAY ignore this rule for development purposes only.
      </p>
    </section>

    <section> <h4>Visible document</h4>
      <p>
        Web NFC functionality is allowed only for the {{Document}} of the
        <a>top-level browsing context</a>, which must be
        <dfn data-cite="PAGE-VISIBILITY#dom-visibilitystate-visible">visible</dfn>.
      </p>
      <p>
        This also means that UAs should block access to the NFC radio if
        the display is off or the device is locked.
        For backgrounded web pages, receiving and writing <a>NFC content</a>
        must be <a id="#nfc-suspended">suspended</a>.
      </p>
    </section>

    <section> <h4>Permissions controls</h4>
      <p>
        Making an <a>NFC tag</a> read-only MUST <a>obtain permission</a>, or
        otherwise fail.
      </p>
      <p>
        Setting up listeners for reading <a>NFC content</a> SHOULD
        <a>obtain permission</a>.
      </p>
      <p>
        Writing <a>NFC content</a> to an <a>NFC tag</a> MUST
        <a>obtain permission</a>.
        See the [[[#writing-content]]] section.
      </p>
      <p>
        All permission that are preserved beyond the current
        browsing session MUST be revocable.
      </p>
    </section>

    <section> <h4>Blocklist</h4>
      <p>
        Web NFC includes a <a>blocklist</a> of vulnerable NFC devices to prevent
        websites from taking advantage of them.
      </p>
    </section>

    <section> <h4>Warn about risk of physical location leak</h4>
      <p>
        When listening for and writing <a>NFC content</a>,
        the UA MAY warn the user that the given <a>origin</a> may be able to
        infer physical location.
      </p>
    </section>

    <section> <h4>Restrict automatic handling</h4>
      <p>
        When the payload data on <a>NFC content</a> is untrusted, it MUST NOT
        be used by the UA to do automatic handling of the content, such as
        opening a web page with a URL found in an <a>NFC tag</a>, or installing
        an application, or other actions, unless the user approves that.
      </p>
    </section>

    <section> <h4>Signing <a>NFC content</a></h4>
      <div>
        The following policies are recommended to be implemented by applications.
        <ul>
          <li>
            A <a>smart poster</a> MAY be trusted only if signed by using
            a single <a>NDEF signature</a> record by the same issuer and
            it is either the first record in a message, or it is preceded by
            another <a>NDEF signature</a>.
          </li>
          <li>
            An <a>NDEF message</a> MAY be trusted only if signed by
            a single <a>NDEF signature</a> record by the same issuer.
          </li>
          <li>
            User agents expose <a>NDEF signature</a> records without verifying
            them. It is applications' responsibility to verify signatures and
            to sign <a>NFC content</a>.
          </li>
          <li>
            Applications SHOULD use appropriate signature algorithms,
            certificates and security policies for <a>NDEF signature</a>
            creation and verification. Also, take into account the known
            attacks agains <a>NDEF signature</a>s, for instance removing
            <a>NDEF signature</a>, replacing <a>NDEF signature</a> along with
             modifying the <a>NFC content</a>, reordering records by changing
             the record <a>PAYLOAD LENGTH field</a>, etc.
          </li>
        </ul>
      </div>
    </section>
    <!-- TODO: add later
    <p class="note">
      For Bluetooth and WiFi handover (supported in later versions),
      the user should have to grant access to the secondary API and must be
      able to properly understand what they are granting.
    </p>
    -->
  </section> <!-- Policies -->
</section> <!-- Security and Privacy  -->

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>

<!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
<section> <h2>Acknowledgments</h2>
  <p>
    The editors would like to thank Jeffrey Yasskin, Anne van Kesteren,
    Anssi Kostiainen, Domenic Denicola, Daniel Ehrenberg, Jonas Sicking,
    Don Coleman, Salvatore Iovene, Rijubrata Bhaumik, Wanming Lin, Han Leon,
    Ryan Sleevi, Bal√°zs Engedy, Theodore Olsauskas-Warren, Reilly Grant,
    Diego Gonz√°lez and Daniel Appelquist for their contributions to this document.
  </p>
  <p>
    Special thanks to Luc Yriarte and Samuel Ortiz for their initial
    <a href="https://github.com/w3c/nfc">work</a>
    on exposing NFC to the web platform, and for their support for the current
    approach. Also, special thanks to Elena Reshetova for the contributions to
    the Security and Privacy section.
  </p>
</section>

</body>
</html>
