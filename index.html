<!DOCTYPE html>
<html>
<head>
  <title>Web NFC API</title>
  <meta charset="UTF-8">
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
          class='remove'>
  </script>
  <script class="remove">
    var respecConfig = {
          specStatus:           "CG-DRAFT",
          shortName:            "web-nfc",
          noLegacyStyle:        true,
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
          edDraftURI:           "https://w3c.github.io/web-nfc/",
          crEnd:                "",
          editors: [
            { name: "Kenneth Rohde Christiansen", company: "Intel",
                    companyURL: "https://intel.com/" },
            { name: "Zoltan Kis", company: "Intel",
                    companyURL: "https://intel.com/" }
          ],
          formerEditors: [
            { name: "Alexander Shalamov", company: "Intel",
                    companyURL: "https://intel.com/" }
          ],
          inlineCSS:    true,
          noIDLIn:      true,
          // extraCSS:     ["../ReSpec.js/css/respec.css"],
          wg:           "Web NFC Community Group",
          wgURI:        "https://www.w3.org/community/web-nfc/",
          wgPublicList: "public-web-nfc",
          issueBase: "https://www.github.com/w3c/web-nfc/issues/",
          githubAPI: "https://api.github.com/repos/w3c/web-nfc",
          otherLinks: [
            {
              key: "Repository",
              data: [{
                    value: "We are on Github.",
                    href: "https://github.com/w3c/web-nfc"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/w3c/web-nfc/issues"
                }, {
                    value: "Commit history.",
                    href: "https://github.com/w3c/web-nfc/commits/gh-pages"
                }, {
                    value: "Usage scenarios",
                    href: "https://w3c.github.io/web-nfc/use-cases.html"
                }
              ]
            },
            {
              key: "Contributors",
              data: [{
                    value: "In the github repository",
                    href: "https://github.com/w3c/web-nfc/graphs/contributors"
                  }
              ]
            },
          ],
          localBiblio: {
            "NFC-SECURITY": {
              href: "https://github.com/w3c/web-nfc/security-privacy.html",
              title: "Web NFC Security and Privacy",
              publisher: "W3C",
              date: "25 April 2015",
            },
            "NFC-USECASES": {
              href: "https://github.com/w3c/web-nfc/use-cases.html",
              title: "Web NFC Use Cases",
              publisher: "W3C",
              date: "25 April 2015",
            },
            "NFC-STANDARDS": {
              href: "http://members.nfc-forum.org/specs/spec_list/",
              title: "NFC Forum Technical Specifications",
              publisher: "NFC Forum",
              date: "24 July 2006"
            },
            "NFC-RTD": {
              href: "http://members.nfc-forum.org/specs/spec_list/",
              title: "NFC Record Type Definition (RTD) Technical Specification",
              publisher: "NFC Forum",
              date: "24 July 2006"
            },
            "ISO-639.2": {
              href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
              title: "Codes for the Representation of Names of Languages",
              publisher: "ISO",
              date: "18 March 2014"
            },
            "WEBAPPSEC": {
              href:"https://w3c.github.io/webappsec/specs/powerfulfeatures",
              title: "Secure Contexts",
              publisher: "W3C",
              date: "17 July 2015"
            },
          },
    };
  </script>
  <style>
    table.simple { border: 1px solid #000; }
    table.simple td { border-right: 1px solid #000; }
  </style>
</head>

<body>

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz.

    The hardware standard is deined in [[NFC-STANDARDS]].
  </p>
  <p>
    This document defines an API to enable selected use-cases based on
    NFC technology.
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered
    unstable.
    Implementers who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This document defines conformance criteria that apply to a single
    product: the <dfn>UA</dfn> (user agent) that implements the interfaces it
    contains.
  </p>
  <p>
    Implementations that use [[!ECMAScript]] to implement the APIs defined in
    this document MUST implement them in a manner consistent with the
    [[!ECMAScript]] Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this document uses that specification and terminology.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology and conventions</h2>
  <p>
    The terms <dfn data-cite="!URL#concept-url">URL</dfn>,
    <dfn data-cite="!URL#concept-url-scheme">URL scheme</dfn>,
    <dfn data-cite="!URL#concept-url-host">URL host</dfn>,
    <dfn data-cite="!URL#concept-url-path">URL path</dfn>,
    <dfn data-cite="!URL#concept-url">URL record</dfn>,
    <dfn data-cite="!URL#parse-a-url">parse a URL</dfn>,
    <dfn data-cite="!URL#absolute-url-string">absolute-URL string</dfn>,
    <dfn data-cite="!URL#path-absolute-url-string">path-absolute-URL string</dfn> and
    <dfn data-cite="!URL#concept-basic-url-parser">basic URL parser</dfn> are defined in [[!URL]].
  </p>
  <p>
    The following terms are defined in [[!HTML]]:
    <dfn data-cite="!HTML#browsing-context">browsing context</dfn>,
    <dfn data-cite="!HTML#top-level-browsing-context">top-level browsing context</dfn>,
    <dfn data-cite="!HTML#global-object">global object</dfn>,
    <dfn data-cite="!HTML#current-settings-object">current settings object</dfn>,
    <dfn data-cite="!HTML#document">Document</dfn>,
    <dfn data-cite="!HTML#document-base-url">document base URL</dfn>,
    <dfn data-cite="!HTML#window"><code>Window</code></dfn>,
    <dfn data-cite="!HTML#windowproxy"><code>WindowProxy</code></dfn>,
    <dfn data-cite="!HTML#origin">origin</dfn>,
    <dfn data-cite="!HTML#ascii-serialisation-of-an-origin">serialized origin</dfn>,
    executing algorithms <dfn data-cite="!HTML#in-parallel">in parallel</dfn>,
    <dfn data-cite="!HTML#queue-a-task">queue a task</dfn>,
    <dfn data-cite="!HTML#task-source">task source</dfn>,
    <dfn data-cite="!HTML#the-iframe-element">iframe</dfn>,
    <dfn data-cite="!HTML#relevant-settings-object">relevant settings object</dfn>,
    <dfn data-cite="!HTML#active-document">active document</dfn>,
    <dfn data-cite="!HTML#environment-settings-object">environment settings object</dfn>,
    <dfn data-cite="!HTML#eventhandler">EventHandler</dfn>,
    <dfn data-cite="!HTML#focus">focus</dfn>,
    <dfn data-cite="!HTML#handler-onblur">lose focus</dfn>,
    <dfn data-cite="!HTML#unloading-document-cleanup-steps">unloading document cleanup steps</dfn>.
  </p>
  <p>
    A <a>browsing context</a> refers to the environment in which
    <a>Document</a> objects are presented to the user. A given
    <a>browsing context</a> has a single <code><a>WindowProxy</a></code> object,
    but it can have many <code>Document</code> objects, with their associated
    <code><a>Window</a></code> objects.
  </p>
  <p>
    The term
    <dfn data-cite="!MIMESNIFF#mime-type">MIME type</dfn>,
    <dfn data-cite="!MIMESNIFF#parsing-a-mime-type">Parsing a MIME type</dfn>,
    <dfn data-cite="!MIMESNIFF#serializing-a-mime-type">Serializing a MIME type</dfn>,
    <dfn data-cite="!MIMESNIFF#valid-mime-type">valid MIME type string</dfn> and
    <dfn data-cite="!MIMESNIFF#json-mime-type">JSON MIME type</dfn>
    are defined in [[!MIMESNIFF]].
  <p>
    The term <dfn data-cite="!WEBAPPSEC#secure-context">secure context</dfn>
    is defined in [[!WEBAPPSEC]].
  </p>
  <p>
    The terms <dfn data-cite="!PAGE-VISIBILITY#dom-visibilitystate-visible">visible</dfn>
    and <dfn data-cite="!PAGE-VISIBILITY#dfn-visibility-states">visibility</dfn>
    are defined in [[!PAGE-VISIBILITY]].
  </p>
  <p>
    The terms <dfn data-cite="!PERMISSIONS#query-a-permission">query a permission</dfn>,
    <dfn data-cite="!PERMISSIONS##request-permission-to-use">request permission</dfn>,
    <dfn data-cite="!PERMISSIONS#dom-permissionstate-granted"><code>"granted"</code></dfn> and
    <dfn data-cite="!PERMISSIONS##dom-permissionstate-prompt"><code>"prompt"</code></dfn>
    are defined in [[!PERMISSIONS]].
  </p>
  <p>
    The Augmented Backus-Naur Form (ABNF) notation used is specified in
    [[!RFC5234]].
  </p>
  <p>
    <dfn data-cite="!WEBIDL#dfn-throw"><code>throw</code></dfn>,
    <dfn data-cite="!WEBIDL#dfn-create-exception"><code>creating</code></dfn>,
    <dfn data-cite="!WEBIDL#idl-DOMString"><code>DOMString</code></dfn>,
    <dfn data-cite="!WEBIDL#idl-dictionary"><code>Dictionary</code></dfn>,
    <dfn data-cite="!WEBIDL#idl-ArrayBuffer"><code>ArrayBuffer</code></dfn>,
    <dfn data-cite="!WEBIDL#common-BufferSource"><code>BufferSource</code></dfn>,
    <dfn data-cite="!WEBIDL#idl-any"><code>any</code></dfn>,
    <dfn data-cite="!WEBIDL#dfn-present">not present</dfn>,
    <dfn data-cite="!WEBIDL#exceptiondef-typeerror"><code>TypeError</code></dfn>,
    <dfn data-cite="!WEBIDL#idl-DOMException"><code>DOMException</code></dfn>,
    <dfn data-cite="!WEBIDL#aborterror"><code>AbortError</code></dfn>,
    <dfn data-cite="!WEBIDL#syntaxerror"><code>SyntaxError</code></dfn>,
    <dfn data-cite="!WEBIDL#notsupportederror"><code>NotSupportedError</code></dfn>,
    <dfn data-cite="!WEBIDL#networkerror"><code>NetworkError</code></dfn>,
    <dfn data-cite="!WEBIDL#notreadableerror"><code>NotReadableError</code></dfn>,
    <dfn data-cite="!WEBIDL#timeouterror"><code>TimeoutError</code></dfn>,
    <dfn data-cite="!WEBIDL#nomodificationallowederror"><code>NoModificationAllowedError</code></dfn>, and
    <dfn data-cite="!WEBIDL#securityerror"><code>SecurityError</code></dfn>,
    are defined in [[!WEBIDL]].
  </p>
  <p>
    <dfn data-cite="!ECMASCRIPT#sec-promise-objects"><code>Promise</code></dfn>,
    <dfn data-cite="!ECMASCRIPT#sec-json-object">JSON</dfn>,
    <dfn data-cite="!ECMASCRIPT#sec-json.stringify">JSON.stringify</dfn>,
    <dfn data-cite="!ECMASCRIPT#sec-json.parse">JSON.parse</dfn> and
    <dfn data-cite="!ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal slots</dfn>
    are defined in [[!ECMASCRIPT]].
  </p>
  <p>
    <dfn data-cite="!INFRA#ascii-decode">ASCII decode</dfn>,
    <dfn data-cite="!INFRA#ascii-encode">ASCII encode</dfn>,
    <dfn data-cite="!INFRA#ascii-lowercase">ASCII lowercase</dfn>,
    <dfn data-cite="!INFRA#ascii-hex-digit">ASCII hex digit</dfn>,
    <dfn data-cite="!INFRA#string">string</dfn>,
    <dfn data-cite="!INFRA#byte">byte</dfn>,
    <dfn data-cite="!INFRA#byte-sequence">byte sequence</dfn>,
    <dfn data-cite="!INFRA#ordered-set">set</dfn>,
    <dfn data-cite="!INFRA#map-exists">exists</dfn>,
    <dfn data-cite="!INFRA#list">list</dfn>,
    <dfn data-cite="!INFRA#list-iterate">for each</dfn>,
    <dfn data-cite="!INFRA#iteration-continue">continue</dfn>,
    <dfn data-cite="!INFRA#list-is-empty">is empty</dfn>,
    <dfn data-cite="!INFRA#list-is-not-empty">is not empty</dfn>,
    <dfn data-cite="!INFRA#list-append" data-lt="list-append">append</dfn>,
    <dfn data-cite="!INFRA#list-contain" data-lt="list-contain">contains</dfn>,
    <dfn data-cite="!INFRA#parse-json-from-bytes">parse JSON from bytes</dfn> and
    <dfn data-cite="!INFRA#serialize-json-to-bytes">serialize JSON to bytes</dfn>,
    are defined in [[!INFRA]].
  </p>
  <p>
    <dfn data-cite="!DOM#concept-event-fire">fire an event</dfn>,
    <dfn data-cite="!DOM#abortsignal">AbortSignal</dfn>,
    <dfn data-cite="!DOM#abortsignal-aborted-flag">aborted flag</dfn>, and
    <dfn data-cite="!DOM#abortsignal-add">add the following abort steps</dfn>
    are defined in [[!DOM]].
  </p>
  <p>
    <dfn data-cite="!ENCODING#utf-8">UTF-8 encoding</dfn>,
    <dfn data-cite="!ENCODING#utf-8-decode">UTF-8 decode</dfn>,
    <dfn data-cite="!ENCODING#utf-8-encode">UTF-8 encode</dfn>,
    <dfn data-cite="!ENCODING#encode">encode</dfn>, and
    <dfn data-cite="!ENCODING#decode">decode</dfn> are defined in [[!ENCODING]].
  </p>

  <section> <h3>Security related terms</h3>
  <p>
    The term <dfn>expressed permission</dfn> refers to an act by the user, e.g.
    via user interface or setting or host device platform features, using which
    the user approves the permission of a <a>browsing context</a> to access the
    given functionality.
  </p>
  <p>
    The term <dfn id="askforgiveness">ask for forgiveness</dfn> refers to some
    form of unobtrusive notification that informs the user of an operation
    while it is running.
    UAs SHOULD provide the user with means to ignore similar future
    operations from the same <a>origin</a> and advertise this to the user.
  </p>
  <p>
    The term <dfn>prearranged trust relationship</dfn> means that the
    UA has already established a trust relationship for a
    certain operation using a platform specific mechanism, so that an
    <a>expressed permission</a> from the user is not any more needed.
    See also this
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#prearranged-trust-relationship">
    section</a> in the Security and Privacy document.
  </p>
  <p>
    The term <dfn>obtain permission</dfn> for a certain operation indicates
    that the UA has either obtained <a>expressed permission</a>, or
    <a href="#askforgiveness">asked for forgiveness</a>, or ensured a
    <a>prearranged trust relationship</a> exists.
  </p>
  <p>
    The
    <a href="https://www.w3.org/TR/permissions/#dictdef-permissiondescriptor">
    <dfn>Web NFC permission name</dfn></a> is
    <a href="https://github.com/w3c/permissions/issues/47">defined</a> as
    <code>"nfc"</code>.
  </p>
  </section>
  <section> <h3>NFC specific terms</h3>
  <p>
    <b>NFC</b> stands for Near Field Communications, short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See <a href="https://www.nfc-forum.org/specs/spec_list/">
    https://www.nfc-forum.org/specs/spec_list/</a> for a complete
    listing.
  </p>
  <p>
    An <dfn>NFC adapter</dfn> is the software entity in the underlying
    platform which provides access to NFC functionality implemented in a
    given hardware element (NFC chip). A device may have multiple NFC
    adapters, for instance a built-in one, and one or more attached via USB.
  </p>
  <p>
    An <dfn>NFC tag</dfn> is a passive NFC device.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. An <a>NFC tag</a> contains a single
    <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. Implementations are expected to encapsulate this.
    </p>
  </p>
  <p>
    An <dfn>NFC peer</dfn> is an active, powered device, which can interact
    with other devices in order to exchange data using NFC.
  </p>
  <p>
    An <dfn>NFC device</dfn> is either an <a>NFC peer</a>, or an <a>NFC tag</a>.
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. <dfn>NDEF</dfn> is an abbreviation for NFC Forum
    Data Exchange Format, a lightweight binary message format. NDEF messages
    can be stored on an <a>NFC tag</a> or exchanged between NFC-enabled devices.
  </p>
  <p>
    The term <dfn>NFC content</dfn> is a synonym for <a>NDEF message</a>,
    which can originate either from an <a>NFC tag</a> or an <a>NFC peer</a>.
  </p>
  <p>
    An <dfn>NDEF record</dfn> is a part of an <a>NDEF message</a> that has a
    single associated type information to its payload. It contains a
    Type Name Format (TNF) field, the payload size, the payload type, an
    optional identifier which is a URL, and a payload of maximum size of
    2^32-1 bytes.
    The NFC Forum has standardized a small set of useful data types for
    use in <a>NDEF record</a>s, for instance text, URL, and binary data such as
    media. In addition, there are record types designed for more complex
    interactions, such as Smart Poster, and handover records.
  </p>
  <p>
    The <dfn>TNF</dfn> (Type Name Format) field of the <a>NDEF record</a> can
    take binary values denoting the following <a>NDEF record</a> payload
    types:
    <table class="simple">
      <tr>
        <th><strong>Value</strong></th>
        <th><strong>Type Name Format</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td>Empty</td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum <dfn>well-known type</dfn> as defined in [[!NFC-RTD]]
        </td>
      </tr>
      <tr>
        <td>2</td>
        <td><a>MIME type</a></td>
      </tr>
      <tr>
        <td>3</td>
        <td><a>Absolute-URL string</a></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <dfn>external type</dfn> as defined in [[!NFC-RTD]]</td>
      </tr>
      <tr>
        <td>5</td>
        <td>Unknown</td>
      </tr>
      <tr>
        <td>6</td>
        <td>Unchanged</td>
      </tr>
      <tr>
        <td>7</td>
        <td>Reserved</td>
      </tr>
    </table>
    <br>
    NFC Forum <a>well-known type</a> includes record types <i>text</i>,
    <i>URI</i>, <i>Smart Poster</i> (containing a URL or other
    data, and possible actions).
  </p>
  <p>
    A <dfn>Web NFC message</dfn> consists of a sequence of <a>NDEF record</a>s,
    one of which is a <a>Web NFC record</a>.
  </p>
  <p>
    The <dfn>Web NFC message origin</dfn> is a <a>serialized origin</a>
    with <code>"https"</code> scheme, stored in the <a>Web NFC record</a>.
    For <a>NFC content</a> that is not a <a>Web NFC message</a>, it is
    <code>null</code>.
  </p>
  <p>
    The <dfn id="web-nfc-id">Web NFC Id</dfn> is an <a>absolute-URL string</a>,
    specifically the <a>Web NFC message origin</a> optionally
    followed by a <a>path-absolute-URL string</a>, stored in the <a>Web NFC Record</a>.
    This enables matching <a>Web NFC content</a> with <a>URL pattern</a>s
    specified by <a>NFCReader</a>s.
  </p>
  <p>
    A <dfn>Web NFC record</dfn> is an <a>NDEF record</a> of <a>external type</a> type,
    specific to Web NFC. It indicates that the containing <a>NDEF message</a>
    is targeted for <a>browsing context</a>s using this API
    and contains information useful for handling the <a>NDEF message</a> with
    the algorithms defined in this specification.
    The format of a <a>Web NFC record</a> is as follows:
    <ul>
      <li>
        Uses NFC Forum <a>external type</a> record (<a>TNF</a>=4) with the
        TYPE field set to <code>urn:nfc:ext:w3.org:webnfc</code>.
      </li>
      <li>
        The payload contains the <a>Web NFC Id</a> of the
        <a>Web NFC message</a>.
      </li>
    </ul>
  </p>
  <p>
    The term <dfn>Web NFC content</dfn> denotes all <a>Web NFC message</a>s
    contained within an <a>NDEF message</a>, identified by the <a>Web NFC Id</a>
    within the <a>NDEF message</a>. This version of the specification
    supports one <a>Web NFC message</a> per <a>NDEF message</a>.
  </p>
  <p class="note">
    As part of the <a>NDEF record</a>, an <dfn>NDEF Id</dfn> field may be
    present for application specific usages. According to the
    [[NFC-STANDARDS]] it contains a URL with the maximum length of 256 bytes.
    This URL is used for identifying the <a>NDEF record</a> payload in an
    application specific way.
    This version of the specification does not use <a>NDEF Id</a> for
    <a>NDEF record</a> level payload identification, since <a>NDEF message</a>
    level identification is used.
  </p>
  <p>
    An <dfn>NFC handover</dfn> defines NFC Forum
    <a href="#dfn-well-known-type">Well Known Types</a> and the
    corresponding message structure that allows negotiation and activation of
    an alternative communication carrier, such as Bluetooth or WiFi.
    The negotiated communication carrier would then be used (separately) to
    perform certain activities between the two devices, such as sending photos
    to the other device, printing to a Bluetooth printer or streaming video to
    a television set.
  </p>
  </section>
</section> <!-- Terminology -->

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <p>
    In general, there are following groups of user scenarios for NFC:
    <ul>
      <li>
        Hold a device in close proximity to a passively powered tag, such as
        a plastic card or sticker, in order to read and/or write data.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to push a <a>Web NFC message</a> from one device to the other.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to initiate a connection using another wireless carrier such
        as Bluetooth or WiFi.
      </li>
      <li>Card emulation
       <ol>
        <li>
          With a secure element: for payments by holding your phone close to a
          point-of-sales terminal, instead of swiping a payment card.
        </li>
        <li>With host card emulation: for allowing use-cases like using a phone
          acting as a hotel room keycard.
        </li>
       </ol>
      </li>
    </ul>
  </p>
  <p>
    NFC works using magnetic induction, meaning that the reader will emit a
    small electric charge which then creates a magnetic field. This field powers
    the passive device which turns it into electrical impulses to communicate
    data. Thus, when the devices are within range, a read is always performed
    (see NFC Analog Specification and NFC Digital Protocol, NFC Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, then later to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As NFC is based on existing RFID standards, many NFC chipsets support
    reading RFID tags, but many of these are only supported by single
    vendors and not part of the NFC standards. Though certain devices support
    reading and writing to these, it is not a goal of this document to
    support proprietary tags or support interoperability with legacy systems.
  </p>
  <p>
    The NFC Forum has mandated the support of five different tag types to be
    operable with NFC devices. The same is required on operating systems such as
    Android.
    <ol>
      <li>
        <b>NFC Forum Type 1</b>: This tag is based on the ISO/IEC 14443-3A
        (also known as NFC-A, as defined in ISO/IEC 14443-3:2011, Part 3:
        Initialization and anticollision). The tags are rewritable and can be
        configured to become read-only. Memory size can be between 96 bytes and
        2 Kbytes. Communication speed is 106 kbit/sec.
      </li>
      <li><b>NFC Forum Type 2</b>: This tag is also based on the
        ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
        to become read-only. Memory size can be between 48 bytes and 2 Kbytes.
        Communication speed is 106 kbit/sec. In contrast to Type 1, Type 2 has
        anti-collision protection for dealing with multiple tags within the NFC
        field.
      </li>
      <li><b>NFC Forum Type 3</b>: This tag is based on the Japanese Industrial
        Standard (JIS) X 6319-4, commonly known as FeliCa. The tags are
        preconfigured to be either rewritable or read-only. Memory availability
        is variable, theoretical memory limit is 1MByte per service.
        Communication speed is 106 kbit/sec. Like Type 2, it supports
        anti-collision protection.
      </li>
      <li><b>NFC Forum Type 4</b> (November 2010): This tag is based on the
        ISO/IEC 14443 like Type 1 and 2, but it supports either NFC-A or NFC-B
        for communication. On top of that the tag may support the Data Exchange
        Protocol (aka ISO-DEP) defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
        Part 4: Transmission protocol). Like Type 3, the tags are preconfigured
        to be either rewritable or read-only. Variable memory, up to 32 KB per
        service. Supports three different communication speeds 106 or 212 or
        424 Kbits/s.
      </li>
      <li>
        <b>NFC Forum Type 5</b>: This tag is based on the NFC-V RF
        technology which is based on ISO/IEC 15693 and allows reading and
        writing an NDEF message on a ISO/IEC 15693 RF tag that is accessible by
        long range RFID readers as well. The NFC communication is limited to
        short distance and may use the Active Communication Mode of
        ISO/IEC 18092 where the sending peer generates the field which balances
        power consumption and improves link stability.
      </li>
    </ol>
  </p>
  <p>
    In addition to data types standardized for <a>NDEF record</a>s by the NFC
    Forum, many commercial products such as bus cards, door openers etc use
    different card specific data and protocol extensions which require specific
    NFC chips (same vendor of card and reader) in order to function.
  </p>
  <p>
    Card emulation mode capabilities also depend on the NFC chip in the device.
    For payments, a Secure Element is often needed.
  </p>
  <p class="note">
    This document does not aim supporting all possible use cases of NFC
    technology, but only a few use cases which are considered relevant to be
    used by web pages in browsers, using the browser security model.
  </p>
  </section> <!-- Introduction -->

  <!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
  <section class="informative"> <h2>Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>

  <aside title="Push a text string to either a tag or peer"
       class="example">
    <p>
      Pushing a text string (like the serialized JSON below)
      to any kind of device is straight forward. Options can
      be left out, as they default to pushing to both tags and
      peers.
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
writer.push(
  '{ "prop1": "value1", "prop2": "value2" }'
).then(() => {
  console.log("Message pushed.");
}).catch((error) => {
  console.log("Push failed :-( try again.");
});
    </pre>
  </aside>

  <aside title="Push a text string to a peer device" class="example">
    <p>
      It is possible to restrict to which devices (tags or peers) data
      should be pushed. Below we specify to only push to peers,
      and thus, no data is pushed when the user taps a tag.
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
writer.push(
  "Text meant for peers only", { target: "peer" }
).then(() => {
  console.log("Message pushed.");
}).catch((error) => {
  console.log("Push failed :-( try again.");
});
    </pre>
  </aside>

  <aside title="Push a URL to either a tag or peer" class="example">
    <p>
      In order to push an NDEF record of URL type, simply use NDEFMessage.
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
writer.push({
  records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
}).then(() => {
  console.log("Message pushed.");
}).catch((error) => {
  console.log("Push failed :-( try again.");
});
    </pre>
  </aside>

  <aside title="Read data from tag, and write to empty ones" class="example">
    <p>
      Below we read various different kinds of data which can be stored on a tag.
      In the case the tag is empty, we write a text message with the value
      "Hello World".
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
const reader = new NFCReader();

reader.onreading = event => {
  const message = event.message;
  if (message.records[0].recordType == 'empty') {
    writer.push({
      url: "/custom/path",
      records: [{ recordType: "text", data: 'Hello World' }]
    });
    return;
  }

  console.log(`Read message written by ${message.url}`);

  for (let record of message.records) {
    switch (record.recordType) {
      case "text":
        console.log(`Text: ${record.data}`);
        break;
      case "url":
        console.log(`URL: ${record.data}`);
        break;
      case "json":
        console.log(`JSON: ${record.data.myProperty.toString()}`);
        break;
      case "opaque":
        if (record.mediaType.startsWith('image/') {
          const blob = new Blob([record.data], {type: record.mediaType});

          const img = document.createElement("img");
          img.src = URL.createObjectURL(blob);
          img.onload = () => window.URL.revokeObjectURL(this.src);

          document.body.appendChild(img);
        }
        break;
    }
  }
};

reader.start();
    </pre>
  </aside>

  <aside title="Save and restore game progress with another device"
       class="example">
    <p>
      Filtering of relevant data sources can be done by the use of
      the <a>NFCReaderOptions</a>. Below we accept URL with <code>
      "/mypath/mygame/"</code> in its path from <code>"mygame.com"</code>
      domain and its subdomains. When we read the data, we immediately update
      the game progress by issueing a push with a custom NDEF data layout.
    </p>
    <p>
      The example allows reading and pushing to both peers and tags,
      whichever one is tapped first.
    </p>
    <pre class="highlight">
const reader = new NFCReader({url: "https://mygame.com/mypath/mygame"});
reader.start();
reader.onreading = async event => {
  console.log(`Source:     ${ event.message.url }`);
  console.log(`Game state: ${ JSON.stringify(event.message.records) }`);

  const newMessage = {
    url: "/mypath/mygame/update",
    records: [{
      recordType: "json",
      mediaType: "application/json",
      data: { level: 3, points: 4500, lives: 3 }
    }]
  };
  const writer = new NFCWriter();
  await writer.push(newMessage);
  console.log("Pushed message");
};
    </pre>
  </aside>

  <aside title="Push and read JSON (serialized and deserialized)"
       class="example">
    <p>
      Storing and receiving JSON data is easy with serialization and deserialization.
    </p>
    <pre class="highlight">
const reader = new NFCReader({url: document.baseURI, recordType: "json"});

reader.addEventListener("reading", event => {
  for (let record of event.message.records) {
    let article =/[aeio]/.test(record.data.title) ? "an" : "a";
    console.log(`${record.data.name} is ${article} ${record.data.title}`);
  }
});

reader.start();

const writer = new NFCWriter();
writer.push({
  records: [
    {
      recordType: "json",
      mediaType: "application/json",
      data: {
        name: "Benny Jensen",
        title: "Banker"
      }
    },
    {
      recordType: "json",
      mediaType: "application/json",
      data: {
        name: "Zoey Braun",
        title: "Engineer"
      }
    }]
});
    </pre>
  </aside>

  <aside title="Write data to tag and print out existing data" class="example">
    <p>
      Pushing data to a tag requires tapping it. If existing data should be
      read during the same tap, we need to set the <code>ignoreRead</code>
      property to <code>false</code> for the <a>NFCWriter</a>.
    </p>
    <pre class="highlight">
const reader = new NFCReader();
reader.onreading = event => {
  for (let record of event.message.records) {
    console.log("Record type:  " + record.recordType);
    console.log("MIME type:    " + record.mediaType);
    console.log("=== data ===\n" + record.data);
  }
};
reader.start();

const writer = new NFCWriter();
writer.push("Pushing data is fun!", {target: "tag", ignoreRead: false});
    </pre>
  </aside>
  </section> <!-- Usage examples -->

  <section class="informative"> <h3>Use Cases</h3>
    <p>
      A few Web NFC user scenarios are described in the
      <a href="https://w3c.github.io/web-nfc/use-cases.html">Use Cases</a>
      document. These user scenarios can be grouped by criteria based on
      security, privacy and feature categories, resulting in generic flows as
      follows.
    </p>
    <section> <h3>Reading an <a>NFC tag</a></h3>
      <ol>
        <li>
          Reading an <a>NFC tag</a> containing a <a>Web NFC message</a>, when a
          web page using the Web NFC API is open and in <a>focus</a>.
          For instance, a web page instructs the user to tap an NFC tag, and
          then receives information from the tag.
        </li>
        <li>
          Reading an <a>NFC tag</a> containing other than <a>Web NFC message</a>,
          when a web page using the Web NFC API is open and in <a>focus</a>.
        </li>
        <li>
          Reading an <a>NFC tag</a> when no web site using the Web NFC API is
          open or in <a>focus</a>.
          <p class="note">
            This use case is not supported in this version of the specification,
            and it has low priority for future versions as well.
          </p>
        </li>
      </ol>
    </section>
    <section> <h3>Writing to an <a>NFC tag</a></h3>
      <p>
        The user opens a web page which can write an <a>NFC tag</a>. The write
        operations may be one of the following:
        <ol>
          <li>
            Writing to an empty <a>NFC tag</a>.
          </li>
          <li>
            Writing to an <a>NFC tag</a> which already contains a
            <a>Web NFC message</a> with a different <a>Web NFC message origin</a>
            (i.e. overwriting a web-specific tag).
          </li>
          <li>
            Writing to an <a>NFC tag</a> which already contains a
            <a>Web NFC message</a> with the same <a>Web NFC message origin</a>
            (i.e. updating own tag).
          </li>
          <li>
            Writing to other, writable <a>NFC tag</a>s (i.e. overwriting a
            generic tag).
          </li>
        </ol>
      </p>
      <p class="note">
        Note that an NFC write operation to an <a>NFC tag</a> always involves
        also a read operation.
      </p>
    </section>
    <section> <h3>Pushing data to an <a>NFC peer</a> device</h3>
      <p>
        In general, pushing data to another Web NFC capable device requires that
        on the initiating device the user would first have to navigate to a web
        site. The user would then touch the device against another Web NFC
        equipped device, and data transfer would occur.
      </p>
      <p>
        On the receiving device the UA will dispatch the content to an application
        registered and eligible to handle the content, and if that application is
        a browser which has a web page open and in <a>focus</a> with active <a>NFCReader</a>,
        then the content is delivered to the page through the <a>NFCReadingEvent</a>.
      </p>
    </section>
    <section> <h3>Handover to another wireless connection type</h3>
      <p>
        NFC supports handover protocols to Bluetooth or WiFi connectivity for
        the purpose of larger volume data transfer. The user touches another
        NFC capable device, and as a result configuration data is sent for a
        new Bluetooth or WiFi connection, which is then established between the
        devices.
      </p>
      <p class="note">
        This use case is not supported in this version of the specification.
      </p>
    </section>
    <section> <h3>Payment scenarios</h3>
      <p>
        Payment scenarios with Web NFC generally do not refer to supporting
        the payment process itself, but associating the payment status with
        a web page in order to have secondary actions. For instance,
        the user buys goods in a store, and payments options include contactless
        payment using NFC technology.
        In general, touching the device to the point of sales terminal receiver
        area will result in a transaction between the secure element from the
        device and the point of sales terminal. With the Web NFC API, if the
        user navigates to a web site before paying, there may be interaction
        with that site regarding the payment, e.g. the user could get points and
        discounts, or get delivered application or service specific data (e.g.
        tickets, keys, etc) to the device.
      </p>
      <p class="note">
        This use case is not supported in this version of the specification.
      </p>
    </section>
    <section> <h3>Support for multiple NFC adapters</h3>
      <p>
        Users may attach one or more external <a>NFC adapter</a>s to their
        devices, in addition to a built-in adapter. Users may use either
        <a>NFC adapter</a>.
      </p>
    </section>
  </section> <!-- Use Cases -->

  <section class="informative"> <h3>Features</h3>
    <p>High level features for the Web NFC specification include the following:
      <ol>
        <li>
          Support devices with single or multiple <a>NFC adapter</a>s.
          If there are multiple adapters present when invoking an NFC function
          then the UA operates all <a>NFC adapter</a>s in parallel.
        </li>
        <li>
          Support communication with active (powered devices such as readers,
          phones) and passive (smart cards, tags, etc) devices.
        </li>
        <li>
          Allow users to act on (e.g. read, write or transceive) discovered
          NFC devices (passive and active), as well as access the payload
          which were read in the process as <a>Web NFC message</a>s.
        </li>
        <li>
          Allow users to write a payload via <a>NDEF record</a>s to compatible
          devices, such as writeable tags, when they come in range, as
          <a>Web NFC message</a>s.
        </li>
        <li>
          [future] Allow manual connection for various technologies such as
          NFC-A and NFC-F depending on the secondary device.
        </li>
        <li>
          [future] Allow <a>NFC handover</a> to Bluetooth or WiFi.
        </li>
        <li>
          [future] Allow card emulation with secure element or host card
          emulation.
        </li>
      </ol>
    </p>
    <p>
      This specification makes a few simplifications in what use cases
      and data types the Web NFC API can handle:
      <ul>
        <li>
          Expose data types already known to web browsers as
          <a>MIME type</a>s.
        </li>
        <li>Use the web security model.</li>
        <li>
          Implementations encapsulate <a>NDEF record</a> handling and the API
          exposes only data and control events.
        </li>
      </ul>
    </p>
  </section> <!-- Features -->
</section> <!-- Introduction -->

<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2 id="security">Security and Privacy</h2>
  <p>
    The trust model, attacker model, threat model and possible mitigation
    proposals for the Web NFC API are presented in the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html">
    Security and Privacy</a> document. This section presents the chosen
    security and privacy model through normative requirements to
    implementations.
  </p>

  <section> <h3>Chain of trust</h3>
  <p>
    Web pages using the Web NFC API are not trusted.
    This means that the user needs to be aware of exactly what a web page is
    intending to do with NFC at any given moment. Implementations need to
    make sure that when the user authorizes a method of this API, then only that
    action is run, without side effects, and exactly in the context and the
    number of times the user allows the execution of NFC related operations,
    according to the algorithmic steps detailed in this specification.
  </p>
  <p>
    The integrity of <a>NFC content</a> SHOULD NOT be trusted when
    used for implementing security policies, for instance the authenticity of
    <a>origin</a>s saved in the <a>Web NFC Id</a>, unless a
    <a>prearranged trust relationship</a> exists.
  </p>
  </section>

  <section> <h3>Threats</h3>
  <p>
    The main threats are summarized in the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#threats-and-possible-solutions">
    Security and Privacy</a> document.
  </p>
  <p>
    In this specification the following threats are handled with the highest
    priority:
    <ul>
      <li>
        User data privacy: involuntary sharing of user data (such as location,
        contacts, personal data, etc) from an NFC-capable device such as a
        phone, tablet, or PC.
      </li>
      <li>
        Protecting existing <a>NFC tag</a>s from being overwritten by malicious
        web pages.
      </li>
    </ul>
  </p>
  </section>

  <section> <h3>Permissions and user prompts</h3>
  <p>
    This specification attempts to minimize user prompting and uses implicit
    security policies to address the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#threats-and-possible-solutions">
    threats</a>.
    However, this specification does not describe, nor does it
    mandate specific user prompting policies. The term <a>obtain permission</a>
    is used for acquiring trust for a given operation.
  </p>
  <p class="note">
    The Permissions API [[!PERMISSIONS]] is suggested to be used by
    UAs for implementing NFC related [[permissions]] in order to minimize
    the need for user prompting.
  </p>
  <p>
    All <a>expressed permission</a>s that are preserved beyond the current
    browsing session MUST be revocable.
  </p>
  </section>

  <section class="informative"> <h3>Security policies</h3>
    <p>
      This section summarizes the security policies which are specified as
      normative requirements in the respective algorithms of this
      specification:
    </p>
    <ul>
      <li>
        Only <a>secure context</a>s are allowed to access <a>NFC content</a>.
        Browsers may ignore this rule for development purposes only.
      </li>
      <li>
        In order to use NFC, the <code><a>Window</a></code> object associated
        with the <code><a>Document</a></code> contained by the
        <a>top-level browsing context</a> using the Web NFC API must be
        <a>visible</a> and in <a>focus</a>.
        This also means that UAs should block access to the NFC radio if
        the display is off or the device is locked.
        For backgrounded web pages, receiving and pushing <a>NFC content</a>
        must be <a id="#nfc-suspended">suspended</a>.
      </li>
      <li>
        When pushing <a>Web NFC content</a>, the <a>serialized origin</a> and
        the <a>URL path</a> of the <a>current settings object</a> when
        requesting the operation must be recorded in each sent <a>NDEF
        message</a>'s <a>Web NFC record</a>.  For details see the <a>Writing
        or pushing content</a> section.
      </li>
      <li>
        When listening for and pushing <a>NFC content</a>,
        the UA may warn the user that the given <a>origin</a> may be able to
        infer physical location.
      </li>
      <li>
        Pushing <a>Web NFC content</a> to an <a>NFC tag</a> does not need to
        <a>obtain permission</a>, if the <a>Web NFC message origin</a> of the
        <a>Web NFC message</a> on that <a>NFC tag</a> is equal to the
        <a>serialized origin</a> of the <a>current settings object</a>.
        Otherwise the UA must <a>obtain permission</a> for pushing
        <a>NFC content</a> which overwrites existing information.
        See also the <a>Writing or pushing content</a> section.
      </li>
      <li>
        Pushing <a>NFC content</a> to an <a>NFC peer</a> does not need to
        <a>obtain permission</a>, but the previous rules apply.
        See the <a>Writing or pushing content</a> section.
      </li>
      <li>
        Making an <a>NFC tag</a> read-only must <a>obtain permission</a>, or
        otherwise fail.
      </li>
      <li>
        Setting up listeners for reading <a>NFC content</a> should
        <a>obtain permission</a>.
      </li>
      <li>
        The process of reading an <a>NDEF message</a> does not need to
        <a>obtain permission</a>.
      </li>
      <li>
        The payload data on <a>NFC content</a> is untrusted, and must not be used
        by the UA to do automatic handling such as opening a web page
        with a URL found in an <a>NFC tag</a>, unless the user approves that.
      </li>
      <li>
        Since all local content that a web page has access to can be shared with
        NFC, the user needs to be clearly aware about the permissions granted
        to the web page using the Web NFC API.
      </li>
      <!--li>
        For Bluetooth and WiFi handover (supported in later versions),
        the user should have to grant access to the secondary API and must be
        able to properly understand what they are granting.
      </li-->
    </ul>
  </section> <!-- Policies -->
</section> <!-- Security and Privacy  -->

<!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
<section> <h2>Data Representation</h2>
  <section> <h3>The <dfn>NDEFMessage</dfn> dictionary</h3>
    <p>
      The content of any <a>Web NFC message</a> is exposed by the
      <a>NDEFMessage</a> dictionary:
    </p>
    <pre class="idl">
      dictionary NDEFMessage {
        DOMString? serialNumber;
        sequence&lt;NDEFRecord&gt; records;
        USVString url;
      };
    </pre>
    <p>
      The <dfn>NDEFMessage.serialNumber</dfn>
      property represents a serial number used for
      anti-collision and identification, or <code>null</code> in case none is available.
    </p>
    <p class="note">
      Though most tags will have a stable unique identifier (UID), not all
      have one and some tags even create a random number on each read.
      The serial number usually consists of 4 or 7 numbers, separated by <code>:</code>.
    </p>
    <p>
      The <dfn>NDEFMessage.url</dfn>
      property represents the <a>Web NFC Id</a> of a received
      <a>Web NFC message</a>. When used in the <code><a>NFCWriter.push()</a></code>
      method, it represents a <a>URL path</a> used for constructing the
      <a>Web NFC Id</a> of the pushed <a>Web NFC content</a>.
    </p>
    <p>
      The <dfn>NDEFMessage.records</dfn>
      property represents a <a>list</a> of <a>NDEF message</a>s defining the
      <a>Web NFC message</a>.
    </p>
  </section>

  <section> <h3>The <dfn>NDEFRecord</dfn> dictionary</h3>
    <p>
      The content of any <a>NDEF record</a> is exposed by the
      <a>NDEFRecord</a> dictionary:
    </p>
    <pre class="idl">
      typedef (DOMString or unrestricted double or ArrayBuffer or Dictionary) NDEFRecordData;

      dictionary NDEFRecord {
        NDEFRecordType recordType;
        USVString mediaType;
        NDEFRecordData data;
      };
    </pre>
    <p>
      The <dfn>NDEFRecordData</dfn> is a union type representing data types allowed
      for <a>NDEFRecord.data</a> property.
    </p>
    <p>
      The <dfn>NDEFRecord.mediaType</dfn>
      property represents the <a>MIME type</a> of the <a>NDEF record</a>
      payload.
    </p>
    <p>
      The <dfn>NDEFRecord.data</dfn> property represents the
      payload data of the <a>NDEF record</a> with an appropriate [[!ECMAScript]]
      type, which depends on the <a>MIME type</a>.
    </p>
    <p>
      The <dfn>NDEFRecord.recordType</dfn> property represents the
      <a>NDEF record</a> types.
      The mapping from data types of an <code><a>NDEFRecord</a></code> to and
      from <a>NDEF record</a> types is presented in the algorithmic steps which
      handle the data and described in the
    <a href="#steps-receiving">Receiving and parsing content</a>
    and <a>Writing or pushing content</a> sections.
    </p>
  </section> <!-- NDEFRecord dictionary -->

  <section data-dfn-for="NDEFRecordType">
    <h2>The <dfn>NDEFRecordType</dfn> enum</h2>
      <p>
        This enum defines the set of known types for a <a>NDEFRecord</a>. The
        <a href="#data-mapping">data mapping</a> section describes how
        <a>NDEFRecordType</a> is mapped to <a>NDEF record</a> types.
      </p>

      <pre class="idl">
        enum NDEFRecordType {
          "empty",
          "text",
          "url",
          "json",
          "opaque"
        };
      </pre>
      <dl>
        <dt><dfn>empty</dfn></dt>
        <dd>
          The enum value representing <a href="#dfn-empty">empty</a> <a>NDEFRecord</a>.
        </dd>
        <dt><dfn>text</dfn></dt>
        <dd>
          The enum value representing <a>NDEFRecord</a> of a <a href="#dfn-text">text</a> type.
        </dd>
        <dt><dfn>url</dfn></dt>
        <dd>
          The enum value representing <a>NDEFRecord</a> of a <a href="#dfn-url">url</a> type.
        </dd>
        <dt><dfn>json</dfn></dt>
        <dd>
          The enum value representing <a>NDEFRecord</a> of a <a href="#dfn-json">json</a> type.
        </dd>
        <dt><dfn>opaque</dfn></dt>
        <dd>
          The enum value representing <a>NDEFRecord</a> of an <a href="#dfn-opaque">opaque</a> type.
        </dd>
      </dl>
  </section> <!-- NDEFRecordType enum -->

  <section><h3>Data mapping</h3>
  <p>
    The mapping from data types of an <code><a>NDEFRecord</a></code> to
    <a>NDEF record</a> types, as used in the <a>Writing or pushing content</a>
    section is as follows:
  </p>
  <table class="simple">
    <tr>
      <th>NDEFRecord recordType</th>
      <th>NDEFRecord mediaType</th>
      <th>NDEFRecord data</th>
      <th>NDEF record type</th>
    </tr>
    <tr>
      <td><dfn>"empty"</dfn></td>
      <td><i>not used</i></td>
      <td><i>not used</i></td>
      <td>Empty (<a>TNF</a>=0) record</td>
    </tr>
    <tr>
      <td><dfn>"text"</dfn></td>
      <td><i>not used</i></td>
      <td><code>DOMString</code></td>
      <td>NFC Forum <a>well-known type</a> (<a>TNF</a>=1) record with type <i>Text</i></td>
    </tr>
    <tr>
      <td><dfn>"url"</dfn></td>
      <td><i>not used</i></td>
      <td><code>DOMString</code></td>
      <td>NFC Forum <a>well-known type</a> (<a>TNF</a>=1) record with type <i>URI</i></td>
    </tr>
    <tr>
      <td><dfn>"json"</dfn></td>
      <td><a>JSON MIME type</a></td>
      <td>
        <code>null</code> or <code>DOMString</code> or <code>Number</code> or
        <code>Dictionary</code>
      </td>
      <td><a>MIME type</a> (<a>TNF</a>=2) record with
        <a>MIME type</a> specified in the <code>type</code> attribute.
      </td>
    </tr>
    <tr>
      <td rowspan="2"><dfn>"opaque"</dfn></td>
      <td><a>MIME type</a></td>
      <td><code>ArrayBuffer</code></td>
      <td><a>MIME type</a> (<a>TNF</a>=2) record</td>
    </tr>
    <tr>
      <td><code>""</code> (<i>empty</i>)</td>
      <td><code>ArrayBuffer</code> or typed array</td>
      <td>NFC Forum <a>external type</a> (<a>TNF</a>=4) record</td>
    </tr>
  </table>
  <p>
    The mapping from <a>NDEF record</a> types to <code><a>NDEFRecord</a></code>,
    as used for incoming <a>NDEF message</a>s described in the
    <a href="#steps-receiving">Receiving and parsing content</a> section, is as
    follows:
  </p>
  <table class="simple">
    <tr>
      <th>NDEF record type</th>
      <th>NDEFRecord recordType</th>
      <th>NDEFRecord mediaType</th>
      <th>NDEFRecord data</th>
    </tr>
    <tr>
      <td>Empty (<a>TNF</a>=0) record</td>
      <td>"empty"</td>
      <td>""</td>
      <td><code>null</code></td>
    </tr>
    <tr>
      <td>NFC Forum <a>well-known type</a> (<a>TNF</a>=1) record with type <i>Text</i></td>
      <td>"text"</td>
      <td>"text/plain"</td>
      <td><code>DOMString</code></td>
    </tr>
    <tr>
      <td>NFC Forum <a>well-known type</a> (<a>TNF</a>=1) record with type <i>URI</i></td>
      <td>"url"</td>
      <td>"text/plain"</td>
      <td><code>DOMString</code></td>
    </tr>
    <tr>
      <td>NFC Forum <a>well-known type</a> (<a>TNF</a>=1) record with type
          <i>Smart Poster</i></td>
      <td>"url"</td>
      <td>"text/plain"</td>
      <td><code>DOMString</code></td>
    </tr>
    <tr>
      <td><a>Absolute-URL string</a> (<a>TNF</a>=3) record</td>
      <td>"url"</td>
      <td>"text/plain"</td>
      <td><code>DOMString</code></td>
    </tr>
    <tr>
      <td><a>MIME type</a> (<a>TNF</a>=2) record with
        <a>JSON MIME type</a>
      </td>
      <td>"json"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td>
        <code>null</code> or <code>DOMString</code> or <code>Number</code> or
        <code>Dictionary</code>
      </td>
    </tr>
    <tr>
      <td><a>MIME type</a> (<a>TNF</a>=2) record</td>
      <td>"opaque"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td><code>ArrayBuffer</code></td>
    </tr>
    <tr>
      <td>NFC Forum <a>external type</a> type (<a>TNF</a>=4) record with type other than
        <code>urn:nfc:ext:w3.org:webnfc*</code></td>
      <td>"opaque"</td>
      <td>"application/octet-stream"</td>
      <td><code>ArrayBuffer</code></td>
    </tr>
    <tr>
      <td>Any other <a>NDEF record</a> type</td>
      <td>"opaque"</td>
      <td>"application/octet-stream"</td>
      <td><code>ArrayBuffer</code></td>
    </tr>
  </table>
  <p>
    The <a>Web NFC record</a>s MUST NOT be exposed to client
    <a>browsing context</a>s.
  </p>
  </section>
</section> <!-- Data types and content -->


<section> <h2>The NFCReader and NFCWriter objects</h2>
  The objects provide a way for the <a>browsing context</a> to
  use NFC functionality.
  They allow for pushing <a>Web NFC message</a>s to <a>NFC tag</a>s
  or <a>NFC peer</a>s within range, and to act on incoming
  <a>Web NFC message</a>s either from an <a>NFC tag</a> or an
  <a>NFC peer</a>.
  <pre class="idl">
    typedef (DOMString or ArrayBuffer or NDEFMessage) NDEFMessageSource;

    [Constructor(), SecureContext, Exposed=Window]
    interface NFCWriter {
      Promise&lt;void&gt; push(NDEFMessageSource message, optional NFCPushOptions options);
    };

    [Constructor(optional NFCReaderOptions options), SecureContext, Exposed=Window]
    interface NFCReader : EventTarget {
      attribute EventHandler onreading;
      attribute EventHandler onerror;

      void start();
      void stop();
    };

    [Constructor(DOMString type, NFCReadingEventInit readingEventInitDict), SecureContext, Exposed=Window]
    interface NFCReadingEvent : Event {
      readonly attribute NDEFMessage message;
    };

    dictionary NFCReadingEventInit : EventInit {
      required NDEFMessage message;
    };

    [Constructor(DOMString type, NFCErrorEventInit errorEventInitDict), SecureContext, Exposed=Window]
    interface NFCErrorEvent : Event {
      readonly attribute DOMException error;
    };

    dictionary NFCErrorEventInit : EventInit {
      required DOMException error;
    };

  </pre>
  <p>
    The <dfn>NDEFMessageSource</dfn> is a union type representing argument types
    accepted by the <a href="#dom-nfcwriter-push"><code>push()</code></a> method.
  </p>
  <p>
    The <dfn>NFCReadingEvent</dfn> is the event being dispatch on new NFC readings,
    with the <a>NDEFMessage</a> object as the <dfn>NFCReadingEvent.message</dfn>
    attribute. <dfn>NFCReadingEventInit</dfn> is used in order to initialize a new
    event with a the <a>NDEFMessage</a> data via the <dfn>NFCReadingEventInit.message</dfn>
    member.
  </p>
  <p>
    The <dfn>NFCErrorEvent</dfn> is the event being dispatch on errors,
    with the <code><a>DOMException</a></code> object as the <dfn>NFCErrorEvent.error</dfn>
    attribute. <dfn>NFCErrorEventInit</dfn> is used in order to initialize a new
    event with a <code><a>DOMException</a></code> data via the <dfn>NFCErrorEventInit.error</dfn>
    member.
  </p>
  <p>
    The <dfn>NFCWriter</dfn> is an object used for writing data to NFC devices
    such as tags.
  </p>
  <p>
    The <dfn>NFCReader</dfn> is an object used for reading data when a device,
    such as a tag, is within the magnetic induction field.
  </p>
  <p>
    The <dfn>NFCReader.onreading</dfn> is an <a>EventHandler</a> which is called to notify
    that new reading is available.
  </p>
  <p>
    The <dfn>NFCReader.onerror</dfn> is an <a>EventHandler</a> which is called to notify
    that an error happened.
  </p>
  <section><h3>NFC state associated with the settings object</h3>
  <p>
    The <a>relevant settings object</a> of the <a>active document</a> of a
    <a>browsing context</a> which supports NFC has an associated
    <dfn>NFC state</dfn> record with the following <a>internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>[[\Suspended]]</td>
      <td>
        A boolean flag indicating whether NFC functionality is
        <a href="#nfc-suspended">suspended</a> or not, initially
        <code>false</code>.
      </td>
     </tr>
     <tr>
      <td>[[\ActivatedReaderList]]</td>
      <td>
        A <a>set</a> of <a>NFCReader</a> instances initially set to the empty <a>set</a>.
      </td>
     </tr>
    </tbody>
  </table>
  <p class="note">
    Internal slots are used only as a notation in this specification, and
    implementations do not necessarily have to map them to explicit internal
    properties.
  </p>
  </section>

  <section> <h3>Handling NFC adapters</h3>
    Implementations MAY use multiple <a>NFC adapter</a>s
    according to the algorithmic steps described in this specification.
  </section>

  <section><h3>Handling Window visibility and focus</h3>
    <p>
      Each <code><a>Window</a></code> object where <code>NFC</code> is
      <code>exposed</code> has a separate <code>NFC</code> instance. The
      <a>visibility</a> and <a>focus</a> state of the
      <code><a>Window</a></code> object determines the
      <a href="#nfc-suspended">suspended</a> state of the associated
      <code>NFC</code> instance.
    </p>
    <p>
      The term <dfn id="nfc-suspended">suspended</dfn> in this specification
      refers to NFC operations being suspended, i.e. no <a>NFC content</a> is
      pushed by <a>NFCWriter</a>s, and no received <a>NFC content</a> is
      presented to any <a>NFCReader</a> while suspended.

      However, platform level timers for the
      <code><a>NFCWriter.push()</a></code> method continue running,
      and if they expire, the event should be recorded and handled
      when execution next resumes, i.e. when the <code>focus</code>
      event is fired on the <code><a>Window</a></code> object.
    </p>
    <p>
      To <dfn id="suspend-nfc">suspend NFC</dfn>, set the [[\Suspended]] internal slot of the
      <a>current settings object</a>'s associated <a>NFC state</a> to <code>true</code>.
    </p>
    <p>
      To <dfn id="resume-nfc">resume NFC</dfn>, set the [[\Suspended]] internal slot of the
      <a>current settings object</a>'s associated <a>NFC state</a> to <code>false</code>.
    </p>
    <p>
      <dfn id="nfc-is-suspended">NFC is suspended</dfn> if the [[\Suspended]] internal slot of the
      <a>current settings object</a>'s associated <a>NFC state</a> is <code>true</code>.
    </p>
    <p>
      The <dfn>activated reader objects</dfn> is the value of the [[\ActivatedReaderList]] internal slot
      of the <a>current settings object</a>'s associated <a>NFC state</a>.

    </p>
    <p>
      When the <code><a>Window</a></code> object associated with the
      <code><a>Document</a></code> using the Web NFC API
      becomes <a>visible</a> and in
      <a>focus</a>,
      <a>resume NFC</a>.
    </p>
    <p>
      When the <code><a>Window</a></code> object associated with the
      <code><a>Document</a></code> using the Web NFC API
      <a href="#dfn-lose-focus">loses focus</a>,
      <a>suspend NFC</a>.
    </p>
  </section> <!-- visibility & focus: the suspended state -->

  <section><h3>Releasing NFC</h3>
  <p>
    To <dfn>release NFC</dfn> on an <a>environment settings object</a> <var>settings</var>, perform the following steps:
  </p>
  <ol id="steps-nfc-release">
    <li>
      <a>Suspend NFC</a>.
    </li>
    <li>
      <a>For each</a> pending <code><a>NFCWriter.push()</a></code> associated with <var>settings</var>:
      <ol>
        <li>
          Stop the instance's <var>timer</var> if it is active.
        </li>
        <li>
          If the instance has already initiated NFC data transfer,
          <a>continue</a>.
        </li>
        <li>
          Reject <var>p</var> with an <code>"<a>AbortError</a>"</code> <code><a>DOMException</a></code>
          and abort these steps.
        </li>
      </ol>
    </li>
    <li>
      Stop the <a>dispatch NFC content</a> steps.
    </li>
    <li>
      Clear the <a>activated reader objects</a>.
    </li>
    <li>
      Release the NFC resources associated with <var>nfc</var> on the
      underlying platform.
    </li>
  </ol>
  <p>
    The UA must <a>release NFC</a> given the document's <a>relevant settings object</a> as
    additional <a>unloading document cleanup steps</a>.
  </p>
  </section> <!-- release NFC -->

  <section data-dfn-for="NDEFCompatibility">
      <h3>The <dfn>NDEFCompatibility</dfn> enum</h3>
        <p>
          To describe what NDEF compatible devices are accepted as
          vendor specific tags exist that support NDEF but which
          are not universally supported by all NFC readers, or by
          the NFC standard.
        </p>
        <pre class="idl">
          enum NDEFCompatibility {
            "nfc-forum",
            "vendor",
            "any"
          };
        </pre>
        <p>
          <dl>
            <dt><dfn>nfc-forum</dfn></dt>
            <dd>
              The enum value representing all active and passive NFC
              devices, supported by the NFC standard.
            </dd>
          </dl>
          <dl>
            <dt><dfn>vendor</dfn></dt>
            <dd>
              The enum value representing vendor specific NFC tags
              (passive device) that require specific reader chips.
            </dd>
          </dl>
          <dl>
            <dt><dfn>any</dfn></dt>
            <dd>
              The enum value representing all NDEF compatible devices
              that the reader chip can read.
            </dd>
          </dl>
        </p>
  </section>

  <section> <h3>The <dfn>NFCPushOptions</dfn> dictionary</h3>
    <pre class="idl">
      dictionary NFCPushOptions {
        NFCPushTarget target = "any";
        unrestricted double timeout = Infinity;
        boolean ignoreRead = true;
        AbortSignal? signal;
        NDEFCompatibility compatibility = "nfc-forum";
      };
    </pre>
    <p>
      The <dfn>NFCPushOptions.target</dfn> property
      denotes the intended target for the pending
      <a href="#dom-nfcwriter-push"><code>push()</code></a>
      operation.
    </p>
    <p>
      The <dfn>NFCPushOptions.timeout</dfn> property
      denotes the timeout for the pending
      <a href="#dom-nfcwriter-push"><code>push()</code></a>
      operation expressed in milliseconds. The default value is
      implementation-dependent. The value <code>Infinity</code> means there is
      no timeout, i.e. no timer is started. After the <var>timeout</var>
      expires, the message set for pushing is cleared, an error is returned,
      and a new <a>Web NFC message</a> can be set for pushing.
    </p>
    <p>
      When the value of the <dfn>NFCPushOptions.ignoreRead</dfn> property is
      <code>true</code>, the <a href="#steps-push">push algorithm</a>
      will skip invoking the <a href="#steps-receiving">
      receiving and parsing steps</a> for an <a>NFC tag</a>.
    </p>
    <p>
      The <dfn>NFCPushOptions.signal</dfn> property allows to abort
      the <a href="#dom-nfcwriter-push"><code>push()</code></a> operation.
    </p>
    <p>
      The <dfn>NFCPushOptions.compatibility</dfn> property denotes
      the accepted kind of NFC devices.
    </p>
  </section>

  <section data-dfn-for="NFCPushTarget">
    <h2>The <dfn>NFCPushTarget</dfn> enum</h2>
    <p>
      This enum defines the set of intended target values for the
      <a href="#dom-nfcwriter-push"><code>push()</code></a> operation.
    </p>
    <pre class="idl">
      enum NFCPushTarget {
        "tag",
        "peer",
        "any"
      };
    </pre>
    <dl>
      <dt><dfn>tag</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push"><code>push()</code></a> operation to be
        a <a>NFC tag</a>.
      </dd>
      <dt><dfn>peer</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push"><code>push()</code></a> operation to be
        a <a>NFC peer</a>.
      </dd>
      <dt><dfn>any</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push"><code>push()</code></a> operation to be
        a <a>NFC tag</a> or a <a>NFC peer</a>.
      </dd>
    </dl>
  </section> <!-- NFCPushTarget enum -->

  <section>
    <h3>The <dfn>NFCReaderOptions</dfn> dictionary</h3>
      <p>
        To describe which messages an application is interested in, the
        <a>NFCReaderOptions</a> dictionary is used:
      </p>
      <pre class="idl">
        dictionary NFCReaderOptions {
          USVString url = "";
          NDEFRecordType recordType;
          USVString mediaType = "";
          NDEFCompatibility compatibility = "nfc-forum";
        };
      </pre>
      <p>
        The <dfn>NFCReaderOptions.url</dfn> property
        denotes the <a>URL pattern</a> which is used for matching the
        <a>Web NFC Id</a> of <a>Web NFC message</a>s which are being read.
        The default value <code>""</code> means that no matching happens.
      </p>
      <p>
        The <dfn>NFCReaderOptions.recordType</dfn> property
        denotes the enum value which is used for matching the
        <code>
        <a href="#idl-def-ndefrecordtype">recordType</a></code> property of each
        <code><a>NDEFRecord</a></code> object in a <a>Web NFC message</a>.
        If the dictionary member is <a>not present</a>, then it will be ignored by the
        <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>NFCReaderOptions.mediaType</dfn> property
        denotes the <a>match pattern</a> which is used for matching the
        <code><a href="#dom-ndefrecord-mediatype">mediaType</a></code> property of each
        <code><a>NDEFRecord</a></code> object in a <a>Web NFC message</a>.
        The default value <code>""</code> means that no matching happens.
      </p>
      <p>
        The <dfn>NFCReaderOptions.compatibility</dfn> property denotes
        the accepted kind of NFC devices.
      </p>
      <pre
        title="Filter accepting only JSON content from https://www.w3.org"
        class="example highlight">
        const options = {
          url: "https://www.w3.org/*",  // any path from the domain is accepted
          recordType: "json",
          mediaType: "application/*+json"  // any JSON-based MIME type
        }
      </pre>
      <pre
        title="Filter which only accepts binary content from a given path for w3 domain and its subdomains"
        class="example highlight">
        const options = {
          url: "https://w3.org/info/restaurant/daily-menu/",
          recordType: "opaque",
          mediaType: "application/octet-stream"
        }
      </pre>
  </section> <!-- NFCReaderOptions -->

  <section><h3>Constructing an <a>NFCReader</a> object</h3>
    <p>
      <ol>
        <li>
          Let <var>reader</var> be a new <a><code>NFCReader</code></a> object.
        </li>
        <li>
          Let <var>options</var> be first argument to constructor.
        </li>
        <li>
          <a>For each</a> <var>key</var>  <var>value</var> of <var>options</var>:
          <ul>
            <li>
              If <var>key</var> equals <code>"url"</code>, set
              <var>reader</var>.[[\Url]] to <var>value</var>.
            </li>
            <li>
              Otherwise, if <var>key</var> equals <code>"recordType"</code>, set
              <var>reader</var>.[[\RecordType]] to <var>value</var>.
            </li>
            <li>
              Otherwise, if <var>key</var> equals <code>"mediaType"</code>, set
              <var>reader</var>.[[\MediaType]] to <var>value</var>.
            </li>
            <li>
              Otherwise, if <var>key</var> equals <code>"compatibility"</code>, set
              <var>reader</var>.[[\Compatibility]] to <var>value</var>.
            </li>
          </ul>
        </li>
        <li>
          Return <var>reader</var>.
        </li>
      </ol>
    </p>
  </section>

  <section><h3><dfn>Writing or pushing content</dfn></h3>
    <p>
      This section describes how to write an <a>NDEF message</a>
      to an <a>NFC tag</a> or how to push it to an <a>NFC peer</a>
      device when it is next time in proximity range before a timer expires.
      At any time there is at maximum of two
      <a>Web NFC message</a>s that can be set for pushing for an <a>origin</a>:
      one targeted to <a>NFC tag</a>s and one to <a>NFC peer</a>s, until
      the current message is sent, a timeout happens, or the push is
      aborted.
    </p>
    <section><h3>The <strong>push()</strong> method</h3>
      <p id="steps-push">
        The
        <code><dfn>NFCWriter.push</dfn></code> method, when invoked, MUST run the
        <dfn>push a message</dfn> algorithm:
        <ol>
          <li>
            Let <var>p</var> be a new <a><code>Promise</code></a> object.
          </li>
          <li>
            Let <var>message</var> be the first argument.
          </li>
          <li>
            Let <var>options</var> be the second argument.
          </li>
          <li>
            Let <var>signal</var> be the <var>options</var> dictionary member
            of the same name if present, or <code>null</code> otherwise.
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection cannot
            be established, then reject <var>p</var> with a
            <code>"<a>NotReadableError</a>"</code> <code><a>DOMException</a></code>
            and return <var>p</var>.
          </li>
          <li>
            If pushing data is not supported by the underlying <a>NFC Adapter</a>, then reject
            <var>p</var> with a <code>"<a>NotSupportedError</a>"</code>
            <code><a>DOMException</a></code>and return <var>p</var>.
          </li>
          <li>
            If <var>signal</var>s <a>aborted flag</a> is set, then reject <var>p</var>
            with an <code>"<a>AbortError</a>"</code> <code><a>DOMException</a></code>
            and return <var>p</var>.
          </li>
          <li>
            If <var>signal</var> is not <code>null</code>, then
            <a>add the following abort steps</a> to <var>signal</var>:
              <ol>
                <li>
                  Stop the instance's <var>timer</var> if it is active.
                </li>
                <li>
                  If the instance has already initiated NFC data transfer,
                  reject <var>p</var> with
                  <code>"<a>NoModificationAllowedError</a>"</code>
                  <code><a>DOMException</a></code> and abort these steps.
                </li>
                <li>
                  Reject <var>p</var> with an <code>"<a>AbortError</a>"</code>
                  <code><a>DOMException</a></code> and abort these steps.
                </li>
              </ol>
          </li>
          <li>
            Run the following steps <a>in parallel</a>:
            <ol>
              <li>
                An implementation MAY reject <var>p</var> with
                <code>"<a>NotSupportedError</a>"</code> <code><a>DOMException</a></code>
                and abort these steps.
                <div class="note">
                  The UA might terminate message push at this point. The reasons
                  for terminations are implementation details. For example, the user
                  could have has set a preference to allow a given origin only to
                  read, write, or push data to peers. Also, the implementation might
                  be unable to support the operation requested.
                </div>
              </li>
              <li>
                Let <var>target</var> be <var>options</var>'s target.
              </li>
              <li>
                Let <var>timeout</var> be <var>options</var>'s timeout.
              </li>
              <li>
                Let <var>compatibility</var> be <var>options</var>'s compatibility.
              </li>
              <li>
                If the <var>message</var> parameter is not of type defined by
                the <code>NDEFMessageSource</code> union, reject <var>p</var>
                with <code><a>TypeError</a></code>, and abort these steps.
              </li>
              <li>
                If the <var>message</var> parameter is of
                <code>NDEFMessage</code> type, and <var>message</var>'s records
                <a>is empty</a>, reject <var>p</var> with
                <code><a>TypeError</a></code> and abort these steps.
              </li>
              <li>
                If <var>timeout</var> value is NaN or negative, reject
                <var>p</var> with <code><a>TypeError</a></code> and abort
                these steps.
              </li>
              <li>
                If <var>timeout</var> value is not supported by the UA, reject
                <var>p</var> with <code>"<a>NotSupportedError</a>"</code>
                <code><a>DOMException</a></code> and abort these steps.
              </li>
              <li>
                Let <var>output</var> be the notation for the <a>NDEF message</a>
                to be created by UA, as the result of passing
                <var>message</var> to <a>create Web NFC message</a>.
                If this throws an exception, reject <var>p</var> with that
                exception and abort these steps.
              </li>
              <li>
                If <var>target</var> is <code>"any"</code>, run the following
                steps twice, once with <var>slot</var> set to the value
                <code>"tag"</code>, and once set to the value <code>"peer"</code>;
                otherwise run the following step once, with
                <var>slot</var> set to the value of <var>target</var>.
              </li>
              <ul>
                <li>
                  If there are any existing instance of this algorithm running whose
                  <var>target</var> is equal to <var>slot</var>, abort that
                  instance of this algorithm by rejecting its <var>p</var>
                  with <code>"<a>AbortError</a>"</code> <code><a>DOMException</a></code>.
                  <p class="note">
                    In other words, the current invocation of
                    <a href="#dom-nfcwriter-push"><code>push()</code></a>
                    rejects and replaces existing running invocations handling the
                    same <var>slot</var>. At any given moment there may be
                    maximum two instances of this algorithm running: one targeting
                    <a>NFC tag</a>s, and another targeting <a>NFC peer</a>s.
                  </p>
                  <p class="note">
                    Implementations are expected to clean up state on aborting these
                    steps, e.g. stop the related timer, clear the related push
                    message, as well as release any resources bound to NFC
                    functionality, so that new invocations of this algorithm do not
                    depend on previous invocations.
                  </p>
                </li>
                <li>
                  Associate <var>output</var> with <var>slot</var>.
                </li>
              </ul>
              <li>
                If <var>timeout</var> value is not equal to <code>Infinity</code>,
                start a timer <var>timer</var> with the timeout value set to
                <var>timeout</var>.
              </li>
              <li>
                Wait until one of the following events happens:
                <ul>
                  <li>
                    Promise <var>p</var> is rejected for a reason such as being
                    aborted by the user. In that case, abort these steps.
                  </li>
                  <li>
                    If <var>timer</var> expires, reject <var>p</var> with
                    <code>"<a>TimeoutError</a>"</code> <code><a>DOMException</a></code>
                    and abort these steps.
                  </li>
                  <li>
                    If an <a>NFC device</a> <var>device</var> comes within
                    communication range, verify the following conditions:
                    <ul>
                      <li>
                        if <var>device</var> is is not officially supported
                        by the NFC Forum, <var>compatibility</var> is
                        <code>"vendor"</code> or <code>"any"</code>.
                      </li>
                      <li>
                        if <var>device</var> is an <a>NFC tag</a>, <var>target</var>
                        is <code>"tag"</code> or <code>"any"</code>.
                      </li>
                      <li>
                        if <var>device</var> is an <a>NFC peer</a>,
                        <var>target</var> is <code>"peer"</code> or
                        <code>"any"</code>.
                      </li>
                      <li>
                        <a href="#nfc-is-suspended">NFC is not suspended</a>.
                      </li>
                    </ul>
                    In case of success, run the following sub-steps:
                    <ol>
                      <li>
                        Stop <var>timer</var> if active.
                      </li>
                      <li>
                        If <var>device</var> is an <a>NFC tag</a>,
                        <ul>
                          <li>Read the tag.</li>
                          <li>
                            If <var>options</var>'s ignoreRead is not equal to
                            <code>true</code>, run the
                            <a href="#steps-receiving">receiving steps</a>.
                          </li>
                          <li>
                            If the <a>Web NFC message origin</a> of the read
                            <a>NFC content</a> is <code>null</code>, or it is
                            different than the <a>serialized origin</a> of the
                            <a>current settings object</a>, and the
                            <a>obtain push permission</a> steps return
                            <code>false</code>, then reject <var>p</var> with
                            <code>"<a>SecurityError</a>"</code>
                            <code><a>DOMException</a></code>
                            and abort these steps.
                          </li>
                        </ul>
                      </li>
                      <li>
                        Initiate data transfer to <var>device</var> using
                        <var>output</var> as buffer, using the <a>NFC adapter</a>
                        in communication range with (connected to)
                        <var>device</var>.
                      </li>
                      <li>
                        If the transfer fails, reject <var>p</var> with
                        <code>"<a>NetworkError</a>"</code> <code><a>DOMException</a></code>
                        and abort these
                        steps.
                        <p class="note">
                          Multiple adapters should be used sequentially by users.
                          There is very small likelihood that a simultaneous tap
                          will happen on two or multiple different and connected
                          <a>NFC adapter</a>s.
                          If it happens, the user will likely need to repeat the
                          taps until success, preferably one device at a time.
                          The error here gives an indication that the operation
                          needs to be repeated. Otherwise the user may think the
                          operation succeeded on all connected <a>NFC adapter</a>s.
                        </p>
                      </li>
                      <li>
                        When the transfer has completed, clear <var>output</var>
                        associated with <var>target</var>, resolve
                        <var>p</var>.
                      </li>
                    </ol>
                  </li>
                </ul>
              </li>
            </ol>
            <p class="note">
              If <a>NFC is suspended</a>,
              continue waiting until <var>timer</var> expires (if set), or
              promise is aborted by the user, or until an <a>NFC device</a>
              comes within communication range.
            </p>
          </li>
        </ol>
      </p>

      <section><h3>Obtaining push permission</h3>
      <p>
        To <dfn>obtain push permission</dfn>, run these steps:
        <ol>
          <li>
            If there is a <a>prearranged trust relationship</a>,
            return <code>true</code>.
          </li>
          <li>
            Run the
            <a>query a permission</a> steps for the
            <a>Web NFC permission name</a> until completion.
            <ul>
              <li>
                If it resolved with <code><a>"granted"</a></code>
                (i.e. an <a>expressed permission</a> has been granted
                to the <a>origin</a> and <a>global object</a> using
                the Permissions API [[!PERMISSIONS]]), return <code>true</code>.
              </li>
              <li>
                Otherwise, if it resolved with <code><a>"prompt"</a></code>, then optionally
                <a>request permission</a> from the user for the
                <a>Web NFC permission name</a>.
                If that is granted, return <code>true</code>.
                <p class="issue">
                  The <a>request permission</a> steps are not yet clearly defined.
                  At this point the UA asks the user about the policy to be used
                  with the <a>Web NFC permission name</a> for the given
                  <a>origin</a> and <a>global object</a>, if the user grants permission,
                  return <code>true</code>.
                </p>
              </li>
            </ul>
          </li>
          <li>
            Return <code>false</code>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating Web NFC message</h3>
        <p>
          To <dfn>create Web NFC message</dfn> given a <var>message</var> run
          these steps:
        </p>
        <ol id="create-web-nfc-message">
          <li>
            Let <var>output</var> be the notation for the <a>NDEF message</a>
            to be created by the UA as a result of these steps.
          </li>
          <li>
            <a>For each</a> <a>NDEFRecord</a> <var>record</var> in the <a>list</a>
            <var>message</var>'s records, run the following steps, or make sure
            that the underlying platform provides equivalent values to
            <var>ndef</var>:
            <ol>
              <li>
                If <var>record</var>'s recordType is <code>undefined</code>, then:
                <ol> <!-- guess type and mediaType from data -->
                  <li>
                    If the type of <var>record</var>'s data is an
                    <code>ArrayBuffer</code>, then set <var>record</var>'s recordType
                    to <code>"opaque"</code>.
                  </li>
                  <li>
                    Otherwise, if the type of <var>record</var>'s data is an
                    <code>Object</code>, then set <var>record</var>'s recordType
                    to <code>"json"</code>.
                  </li>
                  <li>
                    Otherwise, if the type of <var>record</var>'s data is
                    <code>UnrestrictedDouble</code> or <code>String</code>, then
                    set <var>record</var>'s recordType to <code>"text"</code>.
                  </li>
                  <li>
                    Otherwise reject <var>promise</var> with
                    <code><a>TypeError</a></code> and abort these steps.
                  </li>
                </ol>
              </li>
              <li>
                If <var>record</var>'s recordType is <code>"empty"</code>, then
                Let <var>ndef</var> be the result of passing <var>record</var>
                to <a>map empty record to NDEF</a>.
                If this throws an exception, reject <var>promise</var> with
                that exception and abort these steps.
              </li>
              <li>
                Otherwise, if <var>record</var>'s recordType is <code>"text"</code>,
                then let <var>ndef</var> be the result of passing
                <var>record</var> to <a>map text to NDEF</a>.
                If this throws an exception, reject
                <var>promise</var> with that exception and abort these steps.
              </li>
              <li>
                Otherwise, if <var>record</'s recordType is <code>"url"</code>,
                then let <var>ndef</var> the be result of passing
                <var>record</var> to <a>map a URL to NDEF</a>.
                If this throws an exception, reject <var>promise</var> with that
                exception and abort these steps.
              </li>
              <li>
                Otherwise, if <var>record</var>'s recordType is <code>"json"</code>,
                then let <var>ndef</var> the be result of passing
                <var>record</var> to <a>map a JSON object to NDEF</a>.
                If this throws an exception, reject <var>promise</var> with that
                exception and abort these steps.
              </li>
              <li>
                Otherwise, if <var>record</var>'s recordType is <code>"opaque"</code>,
                then let <var>ndef</var> the be result of passing
                <var>record</var> to <a>map binary data to NDEF</a>.
                If this throws an exception, reject <var>promise</var> with that
                exception and abort these steps.
              </li>
              <li>
                Add <var>ndef</var> to <var>output</var>.
              </li>
            </ol> <!-- converting each record -->
          </li> <!-- converting message -->
          <li>
            Let <var>webnfc</var> be the result of invoking
            <a>create a Web NFC record</a> given <var>message</var>'s url.
            If this throws an exception, reject <var>promise</var> with that
            exception and abort these steps.
          </li>
          <li>
            Add <var>webnfc</var> to <var>output</var>.
            <p class="note">
              Implementations may choose the location of the Web NFC record
              within the <a>NDEF message</a>.
            </p>
          </li>
        </ol>
      </section>

      <section><h3>Mapping empty record to NDEF</h3>
      <p>
        To <dfn>map empty record to NDEF</dfn> given a <var>record</var>, run
        these steps:
        <ol>
          <li>
            Let <var>ndef</var> be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>Set the
            <var>ndef</var>'s TNF field to 0 (empty).
          </li>
          <li>Set
            <var>ndef</var>'s TYPE_LENGTH,
            ID_LENGTH and PAYLOAD_LENGTH fields to 0,
            and omit the associated fields from the <a>NDEF record</a>:
            TYPE, ID, and PAYLOAD.
          </li>
          <li>
            Return <var>ndef</var>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping string to NDEF</h3>
      <p>
        To <dfn>map text to NDEF</dfn> given a <var>record</var>, run these
        steps:
        <p class="note">
          This is useful when clients specifically want to write an
          NDEF <a href="#dfn-well-known-type">Well Known Type</a> Text
          record. Other options would be to use the value <code>"opaque"</code>
          with an explicit <a>MIME type</a> text type, which allows for
          better differentiation, e.g. when using <code>"text/xml"</code>, or
          <code>"text/vcard"</code>.
        </p>
        <ol>
          <li>
            If the type of a <var>record</var>'s data is not a <code>String</code>
            or a <code>UnrestrictedDouble</code>, <a>throw</a> a <code><a>TypeError</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>MIME type</var> be the <a data-lt="MIME type">MIME type record</a>
            returned by running <a>parsing a MIME type</a> on
            <var>record</var>'s mediaType.
          </li>
          <li>
            If <var>MIME type</var> is failure, set <var>record</var>'s mediaType to
            <code>"text/plain"</code>.
          </li>
          <li>
            If <var>MIME type</var>'s type is not <code>"text"</code>, then <a>throw</a> a
            <code>"<a>SyntaxError</a>"</code> <code><a>DOMException</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>language</var> be <code>"en"</code>.

            If <var>MIME type</var>'s parameters[<code>"lang"</code>] <a>exists</a>,
            then set <var>language</var> to
            <var>MIME type</var>'s parameters[<code>"lang"</code>].

            <p class="note">
              Note that <code>lang=</code> is not standard parameter
              to <a>MIME type</a>s, but it is used in this specification
              in order to maintain compatibility with [[NFC-STANDARDS]].
            </p>
          </li>
          <li>
            Let <var>ndef</var> be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>
            Set the <var>ndef</var>'s TNF field to 1 (<a>well-known type</a>).
          </li>
          <li>
            Set the <var>ndef</var>'s TYPE field to <code>"T"</code>
            (value 0x54 following NFC binary encoding).
          </li>
          <li>
            Set the <var>ndef</var>'s PAYLOAD field to
            <var>record</var>'s data encoded according to the
            [[!NFC-STANDARDS]], NFC Forum Text Record Type
            Definition specification:
            <ol>
              <li>
                To set the first <a>byte</a> of the <a>byte sequence</a>
                of <var>ndef</var>'s PAYLOAD field, perform the following steps:
                <ol>
                  <li>
                    If <var>MIME type</var>'s parameters[<code>"charset"</code>]
                    <a>exists</a>, set <var>charset</var> to be the
                    result of running <a>ASCII lowercase</a> on the value.
                  </li>
                  <li>
                    If <var>charset</var> is not equal to <code>"utf-8"</code>,
                    <a>throw</a> a <code><a>TypeError</a></code>.
                  </li>
                  <li>
                    Set bit 7 (most significant bit) to the value 0
                    (meaning <a>UTF-8 encoding</a>).
                  </li>
                  <li>
                    Set bit 6 to the value 0 (reserved).
                  </li>
                  <li>
                    Let <var>offset</var> be the length of the
                    <var>language</var> <a>string</a>.
                  </li>
                  <li>
                    Set bit 5 to bit 0 to <var>offset</var>.
                  </li>
                </ol>
              </li>
              <li>
                Set position 1 to <var>offset</var> + 1, inclusive, of the <a>byte sequence</a>
                of <var>ndef</var>'s PAYLOAD field to the result of running <a>ASCII encode</a>
                on <var>language</var>.
              </li>
              <li>
                Set position from <var>offset</var> + 1 to end, of the <a>byte sequence</a>
                of <var>ndef</var>'s PAYLOAD field to the result of running <a>UTF-8 encode</a>
                on <var>record</var>'s data.
              </li>
            </ol>
          </li>
          <li>
            Return <var>ndef</var>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping URL to NDEF</h3>
      <p>
        To <dfn>map a URL to NDEF</dfn> given a <var>record</var>, run these
        steps:
        <ol>
          <li>
            If <var>record</var>'s data is not a <a>string</a>,
            <a>throw</a> a <code><a>TypeError</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>urlRecord</var> be the result of
            <a href="dfn-parse-a-url">parsing</a> <var>record</var>'s data.
          </li>
          <li>
            If <var>urlRecord</var> is failure, <a>throw</a> a
            <code>"<a>SyntaxError</a>"</code> <code><a>DOMException</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>ndef</var> be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>
            Set the <var>ndef</var>'s TNF field to 1 (<a>well-known type</a>).
          </li>
          <li>
            Set the <var>ndef</var>'s TYPE field to "U" (0x55
            following NFC binary encoding).
          </li>
          <li>
            Match the URI prefixes as defined in [[!NFC-STANDARDS]]
            URI Record Type Definition specification, Section 3.2.2, against
            the <var>urlRecord</var>.
          </li>
          <li>
            Let <var>prefix</var> be the matched prefix or else the
            <a href="#dfn-empty">empty</a> <a>string</a>.
          </li>
          <li>
            Let <var>prefix code</var> be the corresponding prefix number,
            or else 0.
          </li>
          <li>
            Let <var>shortened url</var> be <var>urlRecord</var> with
            <var>prefix</var> removed from the start of the <a>string</a>.
          </li>
          <li>
            Set the first <a>byte</a> of <var>ndef</var>'s PAYLOAD field to
            the <var>prefix code</var>.
          </li>
          <li>
            Set position 1 to end, of the <a>byte sequence</a> of <var>ndef</var>'s
            PAYLOAD field to the result of running <a>UTF-8 encode</a> on
            <var>shortened url</var>.
          </li>
          <li>
            Return <var>ndef</var>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping JSON to NDEF</h3>
      <p>
        To <dfn>map a JSON object to NDEF</dfn> given a <var>record</var>,
        run these steps:
        <ol>
          <li>
            If the type of a <var>record</var>'s data is not an <code>Object</code>,
            <a>throw</a> a <code><a>TypeError</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>MIME type</var> be the <a data-lt="MIME type">MIME type record</a>
            returned by running <a>parsing a MIME type</a> on
            <var>record</var>'s mediaType.
          </li>
          <li>
            If <var>MIME type</var> is failure, set <var>record</var>'s mediaType to
            <code>"application/json"</code>.
          </li>
          <li>
            If <var>MIME type</var> is not a <a>JSON MIME type</a>, then <a>throw</a> a
            <code>"<a>SyntaxError</a>"</code> <code><a>DOMException</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>data</var> be the result of executing
            <a>serialize JSON to bytes</a> on <var>record</var>'s data.
          </li>
          <li>
            Let <var>ndef</var> be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>
            Set the <var>ndef</var>'s TNF field to 2 (<a>MIME type</a>).
          </li>
          <li>
            Set the <var>ndef</var>'s TYPE field to the result of
            <a>serializing a MIME type</a> with <var>MIME type</var> as
            the input.
          </li>
          <li>
            Set the <var>ndef</var>'s PAYLOAD field to <var>data</var>
            according to the [[!NFC-STANDARDS]], i.e. as an opaque byte sequence.
          </li>
          <li>
            Return <var>ndef</var>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping binary data to NDEF</h3>
      <p>
        To <dfn>map binary data to NDEF</dfn> given a <var>record</var>,
        run these steps:
        <ol>
          <li>
            If the type of a <var>record</var>'s data is not an
            <code>ArrayBuffer</code>, <a>throw</a> a <code><a>TypeError</a></code>
            and abort these steps.
          </li>
          <li>
            Let <var>MIME type</var> be the <a data-lt="MIME type">MIME type record</a>
            returned by running <a>parsing a MIME type</a> on
            <var>record</var>'s mediaType.
          </li>
          <li>
            If <var>MIME type</var> is failure, set <var>record</var>'s mediaType to
            <code>"application/octet-stream"</code>.
          </li>
          <li>
            Let <var>ndef</var> be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>
            Set the <var>ndef</var>'s TNF field to 2 (<a>MIME type</a>).
          </li>
          <li>
            Set the <var>ndef</var>'s TYPE field to the result of
            <a>serializing a MIME type</a> with <var>MIME type</var> as
            the input.
          </li>
          <li>
            Set the <var>ndef</var>'s PAYLOAD field to <var>record</var>'s data
            according to the [[!NFC-STANDARDS]], i.e. as an opaque byte sequence
          </li>
          <li>
            Return <var>ndef</var>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating a Web NFC record</h3>
      <p>
        To <dfn>create a <a>Web NFC record</a></dfn> given <a>URL path</a> <var>urlPath</var>,
        run these steps:
        <ol>
          <li>
            Let <var>ndef</var> be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>
            Set <var>ndef</var>'s TNF to 4 (<a>external type</a>).
          </li>
          <li>
            Set <var>ndef</var>'s TYPE to
            <code>"urn:nfc:ext:w3.org:webnfc"</code>.
          </li>
          <li>
            Set <var>ndef</var>'s PAYLOAD to the result of invoking
            <a>create a Web NFC Id</a> given <var>urlPath</var>.
            If this throws an exception, re-<a>throw</a> it.
          </li>
          <li>
            Return <var>ndef</var>.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating a Web NFC Id</h3>
      <p>
        To <dfn>create a <a>Web NFC Id</a></dfn> given <a>URL path</a> <var>urlPath</var>,
        run these steps:
        <ol>
          <li>
            Let <var>id</var> be the <a>serialized origin</a> of the
            <a>current settings object</a>.
          </li>
          <li>
            Append <var>urlPath</var> to <var>id</var>.
          </li>
          <li>
            Let <var>urlRecord</var> be the result of
            <a href="dfn-parse-a-url">parsing</a> <var>id</var>.
          </li>
          <li>
            If <var>urlRecord</var> is failure, <a>throw</a> a
            <code>"<a>SyntaxError</a>"</code> <code><a>DOMException</a></code>
            and abort these steps.
          </li>
          <li>
            Return <var>id</var>.
          </li>
        </ol>
      </p>
      </section>
    </section> <!-- push() -->

  </section> <!-- Writing or pushing content -->

  <section> <h3>Listening for content</h3>
    <p>
      In order to receive <a>NFC content</a>, the client needs to attach an
      attach an event listener for the <code>"reading"</code> event on an
      <a>NFCReader</a> instance and then activate it by calling
      <a>NFCReader.start()</a>.
    </p>
    <p>
      Each <a>NFCReader</a> can filter the <a>NFC content</a> based on
      data type, and the <a>URL path</a> of the
      <a>browsing context</a> which has been saved to the <a>Web NFC record</a>
      of the <a>NFC content</a>.
    </p>
    <p>
      If you filter by <a>URL path</a>, that means it will be matched against
      the <a>Web NFC record</a>, thus the presence of such is required.
      If you don't filter by <a>URL path</a>, then all NFC devices are accepted.
    </p>
    <p>
      The latter is matched against the <a>URL pattern</a>s associated with
      the <a>activated reader objects</a>.
    </p>

    <section> <h3>Match patterns</h3>
      <p>
        A <dfn>match pattern</dfn> is defined by the following ABNF:
        <pre>
          match-pattern       = top-level-type-name <code>"/"</code> [ tree <code>"."</code> ] subtype-name [ <code>"+"</code> suffix ] [ <code>";"</code> parameters ]
          top-level-type-name = <code>"*"</code> / &lt; VCHAR except <code>"/"</code> and <code>"*"</code> &gt;
          subtype-name        = <code>"*"</code> / &lt; VCHAR except <code>"+"</code> &gt;
        </pre>
        A <a>match pattern</a> is a
        <a href="http://pubs.opengroup.org/onlinepubs/007904875/utilities/xcu_chap02.html#tag_02_13_03">
        glob</a> used for matching <a>MIME type</a>s,
        for instance the pattern <code>'application/*+json'</code> matches
        <code>'application/calendar+json'</code>, but does not match
        <code>'application/json'</code>. The pattern
        <code>'*/*json'</code>, on the other hand, matches both.
      </p>
    </section>
    <section> <h3>URL patterns</h3>
        A <dfn>URL pattern</dfn> is a <a>URL record</a> that can be used to match
        the <a>Web NFC Id</a> of a <a>Web NFC message</a>.
        A <dfn>valid URL pattern</dfn> is a valid <a>URL record</a> whose
        <a href="#dfn-url-scheme">scheme</a> component is equal to
        <code>"https"</code>.

      <p>
        A <a>URL pattern</a>'s <a href="#dfn-url-scheme">scheme</a>,
        <a href="#dfn-url-host">host</a> and <a href="#dfn-url-path">path</a>
        components that are used by the
        <a href="#dfn-match-web-nfc-id-with-url-pattern">URL pattern match algorithm</a>
        have the following matching rules:

        <table class="simple">
          <tr>
            <th><strong>URL pattern component</strong></th>
            <th><strong>Matching rule for Web NFC Id</strong></th>
          </tr>
          <tr>
            <td><a href="#dfn-url-scheme">scheme</a></td>
            <td>exact match</td>
          </tr>
          <tr>
            <td><a href="#dfn-url-host">host</a></td>
            <td>
              exact match or ends with (<a>URL pattern</a>'s
              <a href="#dfn-url-host">host</a> prepended
              with <code>"."</code>).
            </td>
          </tr>
          <tr>
            <td><a href="#dfn-url-path">path</a></td>
            <td>
              If <a>URL pattern</a>'s path is <code>"/*"</code>, match any
              <a>Web NFC Id</a> path. Otherwise, begins with <a>URL pattern</a>'s
              <a href="#dfn-url-path">path</a>.
            </td>
          </tr>
        </table>
      </p>

      <p class="note">
        For example, <code>'https://mydomain.com/*'</code> will match
        <code>'https://service.mydomain.com/myapp/'</code> and
        <code>'https://info.mydomain.com/general/'</code>, while
        <code>'https://app.mydomain.com/contacts'</code> will match
        <code>'https://app.mydomain.com/contacts'</code> and
        <code>'https://app.mydomain.com/contacts/all'</code>

        The <code>'*'</code> is a valid character for the URL path component,
        therefore,
        <code>'https://www.mydomain.com/*'</code> pattern will match both
        <code>'https://www.mydomain.com/*'</code> and
        <code>'https://www.mydomain.com/service'</code> URLs.
      </p>
    </section>

    <section> <h3>URL pattern match algorithm</h3>
        To <dfn>match Web NFC Id with URL pattern</dfn> for a given
        <code><a>Web NFC Id</a></code> and <code><a>URL pattern</a></code>, run
        these steps:
        <ol>
          <li>
            Let <var>raw id</var> be a <code><a>Web NFC Id</a></code> passed to this algorithm.
          </li>
          <li>
            Let <var>raw pattern</var> be a <a>URL pattern</a> passed to this algorithm.
          </li>
          <li>
            If <var>raw id</var> and <var>raw pattern</var> are empty <a>string</a>s,
            return <code>true</code>.
          </li>
          <li>
            Let <var>id</var> be the result of running the
            <a>basic URL parser</a> on <var>raw id</var>.
          </li>
          <li>
            If <var>id</var> is failure, return <code>false</code>.
          </li>
          <li>
            Let <var>pattern</var> be the result of running the
            <a>basic URL parser</a> on <var>raw pattern</var>.
          </li>
          <li>
            If <var>pattern</var> is failure, return <code>false</code>.
          </li>
          <li>
            If <var>id</var>'s <a href="#dfn-url-scheme">scheme</a>
            does not match <code>pattern</code>'s <a href="#dfn-url-scheme">scheme</a>,
            return <code>false</code>.
          </li>
          <li>
            Let <var>subdomain pattern</var> be the result of prepending <code>"."</code>
            to <var>pattern</var>'s <a href="#dfn-url-host">host</a>.
          </li>
          <li>
            If <var>id</var>'s <a href="#dfn-url-host">host</a> does not end with
            <var>subdomain pattern</var> and <var>id</var>'s
            <a href="#dfn-url-host">host</a> is not equal to <var>pattern</var>'s
            <a href="#dfn-url-host">host</a>, return <code>false</code>.
          </li>
          <li>
            If <var>pattern</var>'s <a href="#dfn-url-path">path</a> is equal to
            <code>"/*"</code>, return <code>true</code>.
          </li>
          <li>
            If <var>id</var>'s <a href="#dfn-url-path">path</a> begins with
            <var>pattern</var>'s <a href="#dfn-url-path">path</a>,
            return <code>true</code>.
          </li>
          <li>
            Otherwise, return <code>false</code>.
          </li>
        </ol>
    </section>

    <section> <h3>The <strong>start()</strong> method</h3>
      <p>
        The section <a href="#steps-receiving">
        Receiving and parsing content</a> uses <a>NFCReader</a> instances to match
        incoming <a>NFC content</a>.
      </p>
      <p>
        Multiple consecutive calls to the <a href="#dom-nfcreader-start"><code>start()</code></a>
        method from the same <a>origin</a> create filters which are in OR relationship.
      </p>
      <p>
        When the <code><dfn>NFCReader.start</dfn></code> method is invoked, the UA
        MUST run the following
        <dfn id="steps-listen">NFC listen algorithm</dfn>:
        <ol>
          <li>
            Let <var>reader_instance</var> be the <a>NFCReader</a> instance.
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection cannot
            be established, then
            <ol>
              <li>
                Let <var>e</var> be the result of <a>creating</a> a
                <code>"<a>NotReadableError</a>"</code> <code><a>DOMException</a></code>.
              </li>
              <li>
                <a>Fire an event</a> named <code>"error"</code> at <var>reader_instance</var>
                using <a>NFCErrorEvent</a> with its <code>error</code> attribute
                initialized to <var>e</var>.
              </li>
              <li>
                Return.
              </li>
            </ol>
          </li>
          <li>
            Run the following steps <a>in parallel</a>:
            <ol>
              <li>
                If the <a>obtain reading permission</a> steps return
                <code>false</code>, then
                <ol>
                  <li>
                    Let <var>e</var> be the result of <a>creating</a> a
                    <code>NotAllowedError</code>.
                  </li>
                  <li>
                    <a>Fire an event</a> named <code>"error"</code> at <var>reader_instance</var>
                    using <a>NFCErrorEvent</a> with its <code>error</code> attribute
                    initialized to <var>e</var>.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                If this is the first listener being set up, then make a request to
                all <a>NFC adapter</a>s to listen to <a>NDEF message</a>s.
              </li>
              <li>
                If the request fails, then
                <ol>
                  <li>
                    Let <var>e</var> be the result of <a>creating</a> a
                    <code>"<a>NotSupportedError</a>"</code> <code><a>DOMException</a></code>.
                  </li>
                  <li>
                    <a>Fire an event</a> named <code>"error"</code> at <var>reader_instance</var>
                    using <a>NFCErrorEvent</a> with its <code>error</code> attribute
                    initialized to <var>e</var>.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                If the <var>reader_instance</var>.[[\Url]] is not an empty <a>string</a>
                and it is not a <a>valid URL pattern</a>, then
                <ol>
                  <li>
                    Let <var>e</var> be the result of <a>creating</a> a
                    <code>"<a>SyntaxError</a>"</code> <code><a>DOMException</a></code>.
                  </li>
                  <li>
                    <a>Fire an event</a> named <code>"error"</code> at <var>reader_instance</var>
                    using <a>NFCErrorEvent</a> with its <code>error</code> attribute
                    initialized to <var>e</var>.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                Add <var>reader_instance</var> to the <a>activated reader objects</a>.
              </li>
              <li>
                If the <a>browsing context</a> loses <a>focus</a> (e.g. the user navigated
                to another page), then the registered <a>activated reader objects</a>
                still SHOULD continue to exist, but SHOULD become paused, i.e. the UA
                SHOULD NOT check and use them until the <a>focus</a> is regained.
              </li>
            </ol>
          </li>
        </ol>
      </p>
      <p>
        To <dfn>obtain reading permission</dfn>, run these steps:
        <ol>
          <li>
            If there is a <a>prearranged trust relationship</a>,
            return <code>true</code>.
          </li>
          <li>
            Otherwise, if the user has earlier denied permission for the calling
            <a>origin</a> for all future calls of
            <a href="#dom-nfcreader-start"><code>start()</code></a>
            as well, then return <code>false</code>.
          </li>
          <li>
            Otherwise, UAs SHOULD
            <a href="#askforgiveness">ask for forgiveness</a> with relevant
            information displayed to the user.
            <p class="note">
              The <a href="#askforgiveness">ask for forgiveness</a> interaction
              might show choices like "block now" or "block forever", etc.
              If the user has chosen to "block forever" the given
              <a>origin</a>, it is the responsibility of the UA to remember
              these user choices for each <a>origin</a>, regardless of which
              <a>NFC adapter</a> is used, and consult them on later invocations.
            </p>
            <p class="note">
             In this step UAs are advised to notify users about
             that reading <a>NFC content</a> may indirectly reveal the physical
             location of the user.
            </p>
          </li>
          <li>
            Return <code>true</code>.
          </li>
        </ol>
      </p>
    </section>

    <section> <h3>The <strong>stop()</strong> method</h3>
      <p>
        When the <code><dfn>NFCReader.stop</dfn></code> method is invoked, the UA
        MUST run the following algorithm:
        <ol>
          <li>
            Remove the <a>NFCReader</a> instance from the <a>activated reader objects</a>.
          </li>
          <li>
            If the <a>activated reader objects</a> <a>is empty</a>, then make a request
            to stop listening to <a>NDEF message</a>s on all <a>NFC adapter</a>s.
          </li>
        </ol>
      </p>
    </section>

  </section>

  <section id="steps-receiving">
  <h3>Receiving and parsing content</h3>
  <p>
    If there are any <a>NFCReader</a> instances in <a>activated reader objects</a>
    then UAs MUST listen to <a>NDEF message</a>s, according to step 7
    of the <a href="#steps-listen">NFC listen algorithm</a>.
  </p>
  <section><h3>The NFC reading algorithm</h3>
    When the <a>UA</a> is to <dfn>receive NFC content</dfn> it MUST run the
    following algorithm:
    <p class="note">
       The UA SHOULD represent an unformatted <a>NFC tag</a> as an
       <a>NDEF message</a> containing a single empty <a>NDEF record</a>.
    </p>
    <ol id ="parse-ndef">
      <li>
        If <a>NFC is suspended</a>, abort these steps.
      </li>
      <li>
        Let <var>compatibility</var> be <code>"vendor"</code> if the read NDEF
        compatible device is not officially supported by the NFC Forum, or else
        <code>"universal"</code>.
      </li>
      <li>
        Let <var>message</var> be a new <code>NDEFMessage</code> object, with
        <var>message</var>'s url set to <code>null</code> and
        <var>message</var>'s records set to the empty <a>list</a>.
      </li>
      <li>
        Let <var>serialNumber</var> be the device identifier as a series of
        numbers, or <code>null</code> if unavailable.
      </li>
      <li>
        Set <var>message</var>'s serialNumber to the <a>string</a> of
        U+003A (:) concatenating each number represented as
        <a>ASCII hex digit</a>, in the same order.
      </li>
      <li>
        Let <var>input</var> be the notation for the <a>NDEF message</a>
        which has been received.
      </li>
      <li>
        <a>For each</a> <a>NDEF record</a> which is part of <var>input</var>, run the
        following sub-steps for <dfn>parsing NDEF record</dfn>:
        <ol>
          <li>
            Let <var>ndef</var> be the notation for the current
            <a>NDEF record</a>. The fields of <var>ndef</var> are described by
            the [[!NFC-STANDARDS]].
          </li>
          <li>
            Let <var>record</var> be a new <code><a>NDEFRecord</a></code> object.
          </li>
          <li>
            If <var>ndef</var>'s TNF field is 0 (empty), then set
            <var>record</var>'s recordType to <code>"empty"</code> and set
            <var>record</var>'s mediaType to <code>""</code>.
          </li>
          <li>
            If <var>ndef</var>'s TNF field is 1 (<a>well-known type</a>), and
            <var>ndef</var>'s TYPE field is <code>"T"</code> (value 0x54 following NFC
            binary encoding), then run the following sub-steps for
            <dfn>parsing NDEF Text record</dfn>, or ensure that the
            underlying platform provides equivalent values to the
            <var>record</var> object properties:
            <ol>
              <li>
                Let <var>header</var> be the first <a>byte</a> of <var>ndef</var>'s PAYLOAD field.
              </li>
              <li>
                Let <var>charset</var> be <code>"utf-8"</code> if bit 7 (most significant bit) of
                <var>header</var> is equal to the value 0, or else <code>"utf-16be"</code>.
              </li>
              <li>
                Let <var>offset</var> be the value given by bit 5 to bit 0 of the
                <var>header</var>.
              </li>
              <li>
                Let <var>MIME type</var> be a <a data-lt="MIME type">MIME type record</a>
                with type <code>"text"</code>, subtype <code>"plain"</code> and parameters
                equal to an empty ordered map.
              </li>
              <li>
                Let <var>MIME type</var>'s parameters[<code>"lang"</code>] be the
                result of running <a>ASCII decode</a> on second <a>byte</a> to the
                <var>offset</var> + 1 byte, inclusive.
              </li>
              <li>
                Set <var>record</var>'s recordType to <code>"text"</code>.
              </li>
              <li>
                Set <var>record</var>'s mediaType to the result of
                <a>serializing a MIME type</a> with <var>MIME type</var> as
                the input.
              </li>
              <li>
                Let <var>buffer</var> be the <a>byte sequence</a> of <var>
                ndef</var>'s PAYLOAD field, from position <var>offset</var> + 1 to the end.
              </li>
              <li>
                If <var>charset</var> is equal to <code>"utf-8"</code>,
                set <var>record</var>'s data to the result of running
                <a>UTF-8 decode</a> on <var>buffer</var>.
              </li>
              <li>
                Otherwise, set <var>record</var>'s data to the result of running
                <a>decode</a> on <var>buffer</var> with <var>encoding</var> set
                to <code>"utf-16be"</code>.
              </li>
            </ol>
            <p class="note">
              Using the encoder from [[!ENCODING]], it is only possible
              to encode as UTF-8, unless you do the encoding manually
              and use the <code>"opaque"</code>
              <a href="#the-ndefrecordtype-enum">recordType</a>, which
              allows you to write any opaque data.
              <br><br>
              When you write a <a>string</a> to the <code>"text"</code>
              <a href="#the-ndefrecordtype-enum">recordType</a>, it will
              be written as UTF-8.
              External applications have the ability to additionally encode
              this field as UTF-16BE, but that is transparent from the use
              of the <a>NFCReader</a> which will always return the data
              as a <a>string</a>.
              <br><br>
              As external applications may have encoded the <code>"opaque"</code>
              <a href="#the-ndefrecordtype-enum">recordType</a> using a different
              encoding, which can be decoded using [[!ENCODING]] if you know
              the encoding.
            </p>
          </li> <!-- reading NDEF Text record -->
          <li>
            If <var>ndef</var>'s TNF field is 1 (<a>well-known type</a>), and
            <var>ndef</var>'s TYPE field is <code>"U"</code> (value 0x55 in NFC binary
            encoding), then run the following sub-steps for
            <dfn>parsing NDEF URL record</dfn>, or make sure that the
            underlying platform provides equivalent values to the
            <var>record</var> object properties:
            <ol>
              <li>Set <var>record</var>'s recordType to <code>"url"</code>.</li>
              <li>
                Set <var>record</var>'s mediaType to <code>"text/plain"</code>.
              </li>
              <li>
                Let <var>prefix code</var> be the value of the first <a>byte</a> of
                <var>ndef</var>'s PAYLOAD field.
              </li>
              <li>
                If <var>prefix code</var> is not 0, then set <var>record</var>'s data
                to the prefix <a>string</a> obtained from mapping the value of
                <var>prefix code</var> to the URL prefix as specified in the
                [[!NFC-STANDARDS]] URI Record Type Definition specification,
                Section 3.2.2.
              </li>
              <li>
                Let <var>buffer</var> be the <a>byte sequence</a> of <var>
                ndef</var>'s PAYLOAD field from the second <a>byte</a> to the end.
              </li>
              <li>
                Concat <var>record</var>'s data with the result of running
                <a>UTF-8 decode</a> on <var>buffer</var>.
              </li>
            </ol>
          </li> <!-- parsing NDEF URL record -->
          <li>
            If <var>ndef</var>'s TNF field is 3 (<a>absolute-URL string</a>), then
            set <var>record</var>'s recordType to <code>"url"</code>,
            set <var>record</var>'s mediaType to <code>"text/plain"</code> and
            set <var>record</var>'s data to the <a>string</a> converted from
            <var>ndef</var>'s PAYLOAD field.
          </li> <!-- parsing NDEF Absolute URI record -->
          <li>
            If <var>ndef</var>'s TFN field is 2 (<a>MIME type</a>), then run
            the following sub-steps for <dfn>parsing NDEF Media record</dfn>, or
            make sure that the underlying platform provides equivalent values to
            the <var>record</var> object properties:
            <ol>
              <li>
                Let <var>MIME type</var> be the <a data-lt="MIME type">MIME type record</a>
                returned by running <a>parsing a MIME type</a> on
                <var>ndef</var>'s TYPE field.
              </li>
              <li>
                If <var>MIME type</var> is a <a>JSON MIME type</a>, then
                <ol>
                  <li>
                    Set <var>record</var>'s recordType to <code>"json"</code>.
                  </li>
                  <li>
                    Set <var>record</var>'s mediaType to the result of
                    <a>serializing a MIME type</a> with <var>MIME type</var> as
                    the input.
                  </li>
                  <li>
                    Set <var>record</var>'s data to the result of executing
                    <a>parse JSON from bytes</a> on <var>ndef</var>'s PAYLOAD field.
                    If an error is thrown, skip to the next <a>NDEF record</a>.
                  </li>
                </ol>
              </li>
              <li>
                Otherwise,
                <ol>
                  <li>
                    Set <var>record</var>'s recordType to <code>"opaque"</code>.
                  </li>
                  <li>
                    Set <var>record</var>'s mediaType to the result of
                    <a>serializing a MIME type</a> with <var>MIME type</var> as
                    the input.
                  </li>
                  <li>
                    Set <var>record</var>'s data to a new <code>ArrayBuffer</code>
                    object constructed from the <a>byte</a> sequence of
                    <var>ndef</var>'s PAYLOAD field.
                  </li>
                </ol>
              </li>
            </ol>
          </li> <!-- parsing NDEF Media record -->
          <li>
            If <var>ndef</var>'s TNF field is 4 (<a>external type</a>), and
            <var>ndef</var>'s TYPE field is <code>urn:nfc:ext:w3.org:webnfc</code>,
            then set <var>message</var>'s url to the <var>ndef</var>'s PAYLOAD field.
          </li> <!-- parsing Web NFC record -->
          <li>
            Otherwise, if <var>ndef</var>'s TNF field is 4 (<a>external type</a>),
            or 5 (unknown) then run the following sub-steps,
            or make sure that the underlying platform provides equivalent values
            to the <var>record</var> object properties:
            <ol>
              <li>Set <var>record</var>'s recordType to <code>"opaque"</code>.</li>
              <li>
                If <var>ndef</var>'s TYPE field is defined, then set
                <var>record</var>'s mediaType to that <a>string</a> value, otherwise to
                <code>"application/octet-stream"</code>.
              </li>
              <li>
                Set <var>record</var>'s data to a new <code>ArrayBuffer</code>
                object constructed from the <a>bytes</a> of <var>ndef</var>'s PAYLOAD field.
              </li>
            </ol>
          </li> <!-- parsing NDEF External/Unknown record -->
          <li>
            Otherwise, skip to the next <a>NDEF record</a> in <var>input</var>.
          </li>
          <li>
            <a>Append</a> <var>record</var> to <var>message</var>'s records.
          </li>
        </ol>
      </li>
      <li>
        If <a href="#nfc-is-suspended">NFC is not suspended</a> and
        <var>message</var>'s records <a>is not empty</a>, run the
        <a>dispatch NFC content</a> steps given <var>message</var>
        and <var>compatibility</var>.
      </li>
    </ol>
    </section>

    <section><h3>Dispatching NFC content</h3>
    <p>
      To <dfn>dispatch NFC content</dfn> given a <var>message</var> of type
      <code><a>NDEFMessage</a></code> and <var>compatibility</var> of type
      <code><a>NDEFCompatibility</a></code>, run these steps:
    </p>
    <ol>
      <li>
        <a>For each</a> <a>NFCReader</a> instance <var>reader_instance</var> in
        the <a>activated reader objects</a>, run the following sub-steps:
        <ol>
          <li>
            Let <var>match</var> be the result of running
            <a href="#dfn-match-web-nfc-id-with-url-pattern">URL pattern match</a>,
            with <var>reader_instance</var>.[[\Url]] as the
            <a>URL pattern</a> and
            <var>message</var>'s url as the <code><a>Web NFC Id</a></code>.
          </li>
          <li>
            If <var>match</var> is <code>false</code>, <a>continue</a>.
          </li>
          <li>
            If <var>reader_instance</var>.[[\RecordType]] is <a href=#dfn-not-present>present</a> and
            it is not equal to any <var>record</var>.[[\RecordType]] where <var>record</var>
            is an element of <var>message</var>, <a>continue</a>.
          </li>
          <li>
            If <var>reader_instance</var>.[[\MediaType]] is not <code>""</code> and
            it is not equal to any <var>record</var>'s mediaType where <var>record</var> is
            an element of <var>message</var>, <a>continue</a>.
          </li>
          <li>
            If <var>reader_instance</var>.[[\Compatibility]] is not <code>"any"</code>, and
            not equal to <var>compatibility</var>, <a>continue</a>.
          </li>
          <li>
            <a>Fire an event</a> named <code>"reading"</code> at <var>reader_instance</var>
            using <a>NFCReadingEvent</a> with its <code>message</code> attribute
            initialized to <var>message</var>.
          </li>
        </ol>
      </li>
    </ol>
    </section>
  </section> <!-- receiving content -->
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>

<!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
<section> <h2>Acknowledgments</h2>
  <p>
    The editors would like to thank Jeffrey Yasskin, Anne van Kesteren,
    Anssi Kostiainen, Domenic Denicola, Daniel Ehrenberg, Jonas Sicking,
    Don Coleman, Salvatore Iovene and Rijubrata Bhaumik for their
    contributions to this document.
  </p>
  <p>
    Also thanks to Luc Yriarte and Samuel Ortiz for their initial work
    on exposing NFC to the web platform, and for their supports for the
    new approach.
  </p>
</section>

</body>
</html>
