<!DOCTYPE html>
<html>
<head>
  <title>Web NFC API</title>
  <meta charset="UTF-8">
  <script type=module src="ndef-record.js"></script>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' async class=
  'remove'></script>
  <script class="remove">
    var respecConfig = {
      specStatus: "CG-DRAFT",
      shortName: "web-nfc",
      editors: [
        {
          name: "Kenneth Rohde Christiansen",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
        { name: "Zoltan Kis", company: "Intel", companyURL: "https://intel.com/" },
      ],
      formerEditors: [
        {
          name: "Alexander Shalamov",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
      ],
      wg: "Web NFC Community Group",
      wgURI: "https://www.w3.org/community/web-nfc/",
      github: "w3c/web-nfc",
      xref: "web-platform",
      localBiblio: {
        "NFC-SECURITY": {
          href: "https://github.com/w3c/web-nfc/security-privacy.html",
          title: "Web NFC Security and Privacy",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-USECASES": {
          href: "https://github.com/w3c/web-nfc/use-cases.html",
          title: "Web NFC Use Cases",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-STANDARDS": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Technical Specifications",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-NDEF": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Data Exchange Format (NDEF) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-RTD": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Record Type Definition (RTD) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-TEXT": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Text Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-URI": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum URI Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-SIGNATURE": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Signature Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-SMARTPOSTER": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Smart Poster Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "ISO-639.2": {
          href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
          title: "Codes for the Representation of Names of Languages",
          publisher: "ISO",
          date: "18 March 2014",
        },
      },
    };
  </script>
  <style>
    table.simple { border: 1px solid #000; }
    table.simple td { border-right: 1px solid #000; }
  </style>
</head>

<body data-cite="MIMESNIFF SECURE-CONTEXTS PERMISSIONS ENCODING PAGE-VISIBILITY">

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz.

    The hardware standard is deined in [[[NFC-STANDARDS]]].
  </p>
  <p>
    This document defines an API to enable selected use-cases based on
    NFC technology.
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered
    unstable.
    Implementers who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This document defines conformance criteria that apply to a single
    product: the <dfn>UA</dfn> (user agent) that implements the interfaces it
    contains.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <p>
    In general, there are following groups of user scenarios for NFC:
    <ul>
      <li>
        Hold a device in close proximity to a passively powered tag, such as
        a plastic card or sticker, in order to read and/or write data.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to push an <a>NDEF message</a> from one device to the other.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to initiate a connection using another wireless carrier such
        as Bluetooth or WiFi.
      </li>
      <li>Card emulation
       <ol>
        <li>
          With a secure element: for payments by holding your phone close to a
          point-of-sales terminal, instead of swiping a payment card.
        </li>
        <li>With host card emulation: for allowing use-cases like using a phone
          acting as a hotel room keycard.
        </li>
       </ol>
      </li>
    </ul>
  </p>
  <p>
    NFC works using magnetic induction, meaning that the reader will emit a
    small electric charge which then creates a magnetic field. This field powers
    the passive device which turns it into electrical impulses to communicate
    data. Thus, when the devices are within range, a read is always performed
    (see NFC Analog Specification and NFC Digital Protocol, NFC Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, then later to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As NFC is based on existing RFID standards, many NFC chipsets support
    reading RFID tags, but some of these are only supported by single
    vendors and not part of the NFC standards. As such this document
    specifies ways to interact with the NFC Data Exchange Format (NDEF).
  </p>
</section> <!-- Introduction -->

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology and conventions</h2>
  <p>
    The Augmented Backus-Naur Form (ABNF) notation used is specified in
    [[RFC5234]].
  </p>

  <section> <h3>Security related terms</h3>
  <p>
    The term <dfn>expressed permission</dfn> refers to an act by the user, e.g.
    via user interface or setting or host device platform features, using which
    the user approves the permission of a <a>browsing context</a> to access the
    given functionality.
  </p>
  <p>
    The term <dfn data-lt="asked for forgiveness">ask for forgiveness</dfn> refers to some
    form of unobtrusive notification that informs the user of an operation
    while it is running.
    UAs SHOULD provide the user with means to ignore similar future
    operations from the same <a>origin</a> and advertise this to the user.
  </p>
  <p>
    The term <dfn>prearranged trust relationship</dfn> means that the
    UA has already established a trust relationship for a
    certain operation using a platform specific mechanism, so that an
    <a>expressed permission</a> from the user is not any more needed.
    See also this
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#prearranged-trust-relationship">
    section</a> in the Security and Privacy document.
  </p>
  <p>
    The term <dfn>obtain permission</dfn> for a certain operation indicates
    that the UA has either obtained <a>expressed permission</a>, or
    <a>asked for forgiveness</a>, or ensured a
    <a>prearranged trust relationship</a> exists.
  </p>
  <p>
    The
    <a href="https://www.w3.org/TR/permissions/#dictdef-permissiondescriptor">
    <dfn>Web NFC permission name</dfn></a> is
    <a href="https://github.com/w3c/permissions/issues/47">defined</a> as
    "`nfc`".
  </p>
  </section>
  <section> <h3>NFC specific terms</h3>
  <p>
    <b>NFC</b> stands for Near Field Communications, short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See <a href="https://www.nfc-forum.org/specs/spec_list/">
    NFC Forum Technical Specifications</a> for a complete
    listing.
  </p>
  <p>
    An <dfn>NFC adapter</dfn> is the software entity in the underlying
    platform which provides access to NFC functionality implemented in a
    given hardware element (NFC chip). A device may have multiple NFC
    adapters, for instance a built-in one, and one or more attached via USB.
  </p>
  <p>
    An <dfn>NFC tag</dfn> is a passive NFC device.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. An <a>NFC tag</a> contains a single
    <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. Implementations are expected to encapsulate this.
    </p>
  </p>
  <p>
    An <dfn>NFC peer</dfn> is an active, powered device, which can interact
    with other devices in order to exchange data using NFC.
  </p>
  <p>
    An <dfn>NFC device</dfn> is either an <a>NFC peer</a>, or an <a>NFC tag</a>.
  </p>
  <p>
    <dfn>NDEF</dfn> is an abbreviation for NFC Forum Data Exchange Format, a
    lightweight binary message format that is standardized in [[!NFC-NDEF]].
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. NDEF messages can be stored on an <a>NFC tag</a> or exchanged between NFC-enabled devices.
  </p>
  <p>
    The term <dfn>NFC content</dfn> denotes all bytes sent to or received from
    an <a>NFC tag</a> or an <a>NFC peer</a>. In the current API it is synonym to
    <a>NDEF message</a>.
  </p>
  </section>
</section> <!-- Terminology -->


<section class="informative">
  <h2>The NFC Standard</h2>
  <p>
    NFC is standardized in the NFC Forum and described in [[NFC-STANDARDS]].
  </p>
  <section class="informative"> <h3>NDEF compatible tag types</h3>
    <p>
      The NFC Forum has mandated the support of five different tag types to be
      operable with NFC devices. The same is required on operating systems such
      as Android.
    </p>
    <p>
      In addition to that, the <a>MIFARE Standard</a> specifies a way
      for NDEF to work on top of the older <a>MIFARE Standard</a>, which may
      be optionally supported by implementors.
    </p>
    <p>
      A note about the NDEF mapping can be found here:
      <a href="https://www.nxp.com/docs/en/application-note/AN1305.pdf">
      MIFARE Classic as NFC Type MIFARE Classic Tag</a>
    </p>
    <p>
      <ol>
        <li>
          <dfn>NFC Forum Type 1</dfn>: This tag is based on the ISO/IEC 14443-3A
          (NFC-A). The tags are rewritable and can be
          configured to become read-only. Memory size can be between `96` bytes and
          `2` Kbytes. Communication speed is `106` kbit/sec. In contract to all other
          types, these tags have no anti-collision protection for dealing with multiple
          tags within the NFC field.
        </li>
        <li>
          <dfn>NFC Forum Type 2</dfn>: This tag is based on the
          ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
          to become read-only. Memory size can be between `48` bytes and `2` Kbytes.
          Communication speed is `106` kbit/sec.
        </li>
        <li>
          <dfn>NFC Forum Type 3</dfn>: This tag is based on the Japanese Industrial
          Standard (JIS) X 6319-4 (ISO/IEC 18092), commonly known as FeliCa. The tags are
          preconfigured to be either rewritable or read-only. Memory is `2` kbytes.
          Communication speed is `212` kbit/sec or `424` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 4</dfn>: This tag is based on the ISO/IEC 14443-4 A/B
          (NFC A, NFC B) and thus supports either NFC-A or NFC-B
          for communication. On top of that the tag may optionally support ISO-DEP
          (Data Exchange Protocol defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
          Part 4: Transmission protocol). The tags are preconfigured
          to be either rewritable or read-only. Variable memory, up to `32` kbytes.
          Supports three different communication speeds `106` or `212` or
          `424` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 5</dfn>: This tag is based on ISO/IEC 15693 (NFC-V) and
          allows reading and writing an NDEF message on a ISO/IEC 15693 RF tag
          that is accessible by long range RFID readers as well. The NFC communication
          is limited to short distance and may use the <i>Active Communication Mode</i> of
          ISO/IEC 18092 where the sending peer generates the field which balances
          power consumption and improves link stability. Variable memory, up to `64` kbytes.
          Communiction speed `26.48` kbit/s
        </li>
        <li>
          <dfn>MIFARE Standard</dfn>: This tag, often sold under the brand names MIFARE
          Classic or MIFARE Mini, is based on the ISO/IEC 14443-3A (also known as NFC-A,
          as defined in ISO/IEC 14443-3:2011, Part 3: Initialization and anticollision).
          The tags are rewritable and can be configured to become read-only. Memory size
          can be between `320` and `4` kbytes. Communication speed is `106` kbit/sec.
          <p class=note>
            <a>MIFARE Standard</a> is a not an NFC Forum type and can only be read by devices
            using NXP hardware. Support for reading and writing to tags based on the
            <a>MIFARE Standard</a> is thus non-nominative, but the type is included
            due to the popularity and use in legacy systems.
          </p>
        </li>
      </ol>
    </p>
    <p>
      In addition to data types standardized for <a>NDEF record</a>s by the NFC
      Forum, many commercial products such as bus cards, door openers may be based
      on the <a>MIFARE Standard</a> which require specific NFC chips (same vendor of
      card and reader) in order to function.
    </p>
    <p>
      Card emulation mode capabilities also depend on the NFC chip in the device.
      For payments, a Secure Element is often needed.
    </p>
    <p class="note">
      This document does not aim supporting all possible use cases of NFC
      technology, but only a few use cases which are considered relevant to be
      used by web pages in browsers, using the browser security model.
    </p>
  </section>

  <section>
  <h3>
    The NDEF record and fields
  </h3>
  <p>
    An <dfn>NDEF record</dfn> is a part of an <a>NDEF message</a>. Each record
    is a binary structure that contains a data payload, as well as associated
    type information. In addition to this, it includes information about how
    the data is structured, like payload size, whether the data is chunked over
    multiple records etc.
  </p>
  <p>
    A generic record looks like the following:
    <ndef-record class="ndef"
      header="*,*,*,*,*,*"
      content="*,PAYLOAD LENGTH - 1 (SR) to 4 bytes,ID LENGTH (optional),TYPE (optional),ID (optional),PAYLOAD (optional)">
    </ndef-record>
  </p>
  <p>
    Only the first three bytes (lines in figure) are mandatory. First the
    header byte, followed by the <a>TYPE LENGTH field</a> and <a>PAYLOAD
    LENGTH field</a>, which may both be zero.
  </p>
  <p>
    The <dfn>TNF field</dfn> (bit `0-2`, type name format) indicates the format
    of the type name and is often exposed by native NFC software stacks. The
    field can take binary values denoting the following NDEF record payload types:
    <table class="simple">
      <tr>
        <th><strong>TNF value</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td><a>Empty record</a></td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum <a>well-known type record</a></td>
      </tr>
      <tr>
        <td>2</td>
        <td><a>MIME type record</a></td>
      </tr>
      <tr>
        <td>3</td>
        <td><a>Absolute-URL record</a></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <a>external type record</a></td>
      </tr>
      <tr>
        <td>5</td>
        <td><a>Unknown record</a></td>
      </tr>
      <tr>
        <td>6</td>
        <td><a>Unchanged record</a></td>
      </tr>
      <tr>
        <td>7</td>
        <td>Reserved for future use</td>
      </tr>
    </table>
  </p>
  <p>
    The <dfn>IL field</dfn> (bit `3`, id length) indicates whether an
    <a>ID LENGTH field</a> is present. If the <a>IL field</a> is `0`, then the
    <a>ID field</a> is not present either.
  </p>
  <p>
    The <dfn>SR field</dfn> (bit `4`, short record) indicates a short record,
    one with a payload length <= `255` bytes. Normal records can have payload
    lengths exceeding `255` bytes up to a maximum of `4` GB. Short records only
    use one byte to indicate length, whether as normal records use `4` bytes
    (`2`<sup>`32`</sup>`-1` bytes).
  </p>
  <p>
    The <dfn>CF field</dfn> (bit `5`, chunk flag) indicates whether the payload
    is chunked across multiple records. The initial chunk record has this flag
    set, its <a>TYPE field</a> set to the type of the whole chunked payload,
    and its <a>ID field</a> MAY be set to an identifier used for the whole
    chunked payload. It's <a>PAYLOAD LENGTH field</a> denotes the size of the
    payload chunk in this record only.
    The middle chunk records have this flag set, have the same <a>ID field</a>
    as the first chunk, their <a>TYPE LENGTH field</a> and <a>IL field</a> MUST
    be `0` and their <a>TNF field</a> MUST be `6` (unchanged).
    The terminating chunk record has this flag cleared, and in rest undergo the
    same rules as the middle chunk records.
    A chunked payload MUST be contained in a single <a>NDEF message</a>,
    therefore the initial and middle chunk records cannot have the
    <a>ME field</a> set.
  </p>
  <p class="note">
    Web NFC turns all received chunked records into logical records and
    transparently chunks sent payload when that is needed.
  </p>
  <p>
    The <dfn>ME field</dfn> (bit `6`, message end) indicates whether this record
    is the last in the <a>NDEF message</a>.
  </p>
  <p>
    The <dfn>MB field</dfn> (bit `7`, message begin) indicates whether this
    record is the first of the <a>NDEF message</a>.
  </p>
  <p>
    The <dfn>TYPE LENGTH field</dfn> is an unsigned 8-bit integer that denotes
    the byte size of the <a>TYPE field</a>.
  </p>
  <p>
    The <dfn>TYPE field</dfn> is a globally unique and maintained identifier
    that describes the type of the <a>PAYLOAD field</a> in a structure,
    encoding and format dictated by value of the <a>TNF field</a>.
  </p>
  <p class="note">
    The [[[!NFC-RTD]]] requires that the <a>TYPE field</a> names MUST be compared in case-insensitive manner.
  </p>
  <p>
    The <dfn>ID LENGTH field</dfn> is an unsigned 8-bit integer that denotes
    the byte size of the <a>ID field</a>.
  </p>
  <p>
    The <dfn>ID field</dfn> is an identifier in the form of a URI reference
    ([[RFC3986]]) that is unique, and can be absolute of relative (in the
    latter case the application must provide a base URI). Middle and terminating
    chunk records MUST NOT have an <a>ID field</a>, other records MAY have it.
  </p>
  <p>
    The <dfn>PAYLOAD LENGTH field</dfn> denotes the byte size of the
    <a>PAYLOAD field</a>. If the <a>SR field</a> is `1`, its size is one byte,
    otherwise 4 bytes, representing an 8-bit or 32-bit unsigned integer,
    respectively.
  </p>
  <p>
    The <dfn>PAYLOAD field</dfn> carries the application bytes. Any internal
    structure of the data is opaque to NDEF. Note that in certain cases
    discussed later, this field MAY contain an <a>NDEF message</a> as data.
  </p>
  </section>

  <section>
  <h3>
    NDEF Record types
  </h3>
    <section>
    <h4>
      Empty NDEF records (TNF 0)
    </h4>
    The <dfn>empty record</dfn>s, which have no payload or type
    and are used to indicate empty tags.

    <ndef-record
      header="1,1,0,1,0,0 (EMPTY)"
      content="0,0,_,_,_,_"
      short>
    </ndef-record>
    </section>
    <section>
    <h4>
       Well-known records (TNF 1)
    </h4>
    <p>
      The NFC Forum has standardized a small set of useful RTD (Record Type
      Definition) types for use in the NFC Forum <dfn  data-no-export="">well-known type record</dfn>s,
      for instance text, URL, and binary data such as media. In addition, there
      are record types designed for more complex interactions, such as smart
      poster (containing optional embedded records for url, text, signature and
      actions), and handover records. Most of these are defined in [[[NFC-RTD]]].
    </p>
    <p>
      For well-known records, the RTD type is stored in the <a>TYPE field</a> and is "`T`"
      (`0x54`) for text, "`U`" (`0x55`) for url and "`Sp`" (`0x53`, `0x70`) for smart poster.
    </p>
    <p>
      Other known RTD types supported by the platform and not Web NFC are
      "`ac`" (`0x61`, `0x63`) for alternative carrier, "`Hc`" (`0x48`, `0x63`) for
      handover carrier, "`Hr`" (`0x48`, `0x72`) for handover request, and "`Hs`"
      (`0x48`, `0x73`) for handover select.
    </p>
    <p>
      An <dfn>NFC handover</dfn> defines RTD and the
      corresponding message structure that allows negotiation and activation of
      an alternative communication carrier, such as Bluetooth or WiFi.
      The negotiated communication carrier would then be used (separately) to
      perform certain activities between the two devices, such as sending photos
      to the other device, printing to a Bluetooth printer or streaming video to
      a television set.
    </p>
    <p>
      Smart poster embeds additional records inside its payload. Below you
      see an example embedding a text and a url record.
      <ndef-record
        header="1,1,0,1,0,1 (WELL KNOWN)"
        content="*,*,_,'Sp' (0x53 0x70),_,*"
        short>
        <ndef-record slot="payload"
          header="1,0,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'T' (0x54),_,*"
          short noindices>
        </ndef-record>
        <ndef-record slot="payload"
          header="0,1,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'U' (0x55),_,*"
          short noindices>
        </ndef-record>
      </ndef-record>
    </p>
    </section>
    <section>
    <h4>
      MIME type records (TNF 2)
    </h4>
    <p>
      The <dfn>MIME type record</dfn>s are records that store `opaque`
      data with associated <a>MIME type</a>.
      <ndef-record
        header="*,*,*,*,*,2 (MIME)"
        content="*,*,*,SERIALIZED MIME TYPE,*,MIME TYPE PAYLOAD"
        short>
      </ndef-record>
    </p>
    <p class=note>
      Web NFC has special handling for working with JSON MIME type data.
    </p>
    </section>
    <section>
    <h4>
      Absolute-URL records (TNF 3)
    </h4>
    <p>
      In <dfn>absolute-URL record</dfn>s the <a>TYPE field</a> contains the
      <a>absolute-URL string</a>, and not the payload.
    </p>
    <p class=note>
      NOTE: Some platforms, like Windows Phone have stored additional data
      in the payload, but any payload data in these records are ignored by
      other platforms such as Android. On Android, reading such a record,
      will attempt to load the URL in Chrome and it is as such not intended
      for client applications.
    </p>
    <p>
      <ndef-record
        header="*,*,*,*,*,3 (ABSOLUTE URL)"
        content="*,*,*,ABSOLUTE URL STRING,*,PAYLOAD (optional/ignored)"
        short>
      </ndef-record>
    </p>
    </section>
    <section>
    <h4>
      External type records (TNF 4)
    </h4>
    <p>
      The NFC Forum <dfn data-no-export="">external type record</dfn>s are for client specified
      data and must have a type name following the [[[NFC-RTD]]] standard.
    </p>
    <p>
      <ndef-record
        header="*,*,*,*,*,4 (EXTERNAL)"
        content="*,*,*,EXTERNAL TYPE (eg. w3.org:member),*,*"
        short>
      </ndef-record>
    </p>
    </section>

    <section>
    <h4>
      Unknown type records (TNF 5)
    </h4>
    <p>
      The <dfn>unknown record</dfn>s are records that store
      `opaque` data without associated <a>MIME type</a>.
    </p>
    <p>
      <ndef-record
        header="*,*,*,*,*,5 (UNKNOWN)"
        content="0,*,*,_,*,*"
        short>
      </ndef-record>
    </p>
  </section>
  <section>
    <h4>
      Unchanged type records (TNF 6)
    </h4>
    <p>
      The <dfn>unchanged record</dfn>s are record chunks of
      a chunked data set, and is used for any, but the first record.
    </p>
    <p>
      First record:
      <ndef-record
        header="1,0,1,1,0,*"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Intermediate record:
      <ndef-record
        header="0,0,1,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Last record:
      <ndef-record
        header="0,1,0,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
    </p>
    <p>
      Any implementation of Web NFC MUST transparently expose chunked records
      as single logical records.
    </p>
    </section>
  </section>
</section>  <!-- NFC Standard -->

<section class="informative"> <h3>Use Cases</h3>
  <p>
    A few Web NFC user scenarios are described in the
    <a href="https://w3c.github.io/web-nfc/use-cases.html">Use Cases</a>
    document. These user scenarios can be grouped by criteria based on
    security, privacy and feature categories, resulting in generic flows as
    follows.
  </p>
  <section> <h3>Reading an <a>NFC tag</a></h3>
    <ol>
      <li>
        Reading an <a>NFC tag</a> containing an <a>NDEF message</a>, when the
        {{Document}} of the <a>top-level browsing context</a> using the Web NFC API
        is <a>visible</a>. For instance, a web page instructs the user
        to tap an NFC tag, and then receives information from the tag.
      </li>
      <li>
        Reading an <a>NFC tag</a> containing other than <a>NDEF message</a>,
        when the {{Document}} of the <a>top-level browsing context</a> using the
        Web NFC API is <a>visible</a>.
      </li>
      <li>
        Reading an <a>NFC tag</a> when no {{Document}} using the Web NFC API is
        <a>visible</a>.
        <p class="note">
          This use case is not supported in this version of the specification,
          and it has low priority for future versions as well.
        </p>
      </li>
    </ol>
  </section>
  <section> <h3>Writing to an <a>NFC tag</a></h3>
    <p>
      The user opens a web page which can write an <a>NFC tag</a>. The write
      operations may be one of the following:
      <ol>
        <li>
          Writing to an empty <a>NFC tag</a>.
        </li>
        <li>
          Writing to an <a>NFC tag</a> which already contains a
          <a>NDEF message</a> with a different <a>record identifier</a>
          (i.e. overwriting a web-specific tag).
        </li>
        <li>
          Writing to an <a>NFC tag</a> which already contains a
          <a>NDEF message</a> with the same <a>record identifier</a>
          (i.e. updating own tag).
        </li>
        <li>
          Writing to other, writable <a>NFC tag</a>s (i.e. overwriting a
          generic tag).
        </li>
      </ol>
    </p>
    <p class="note">
      Note that an NFC write operation to an <a>NFC tag</a> always involves
      also a read operation.
    </p>
  </section>
  <section> <h3>Pushing data to an <a>NFC peer</a> device</h3>
    <p>
      In general, pushing data to another Web NFC capable device requires that
      on the initiating device the user would first have to navigate to a web
      site. The user would then touch the device against another Web NFC
      equipped device, and data transfer would occur.
    </p>
    <p>
      On the receiving device the UA will dispatch the content to an application
      registered and eligible to handle the content, and if that application is
      a browser which has a {{Document}} of the <a>top-level browsing context</a>
      <a>visible</a> with active {{NFCReader}},
      then the content is delivered to the page through the <a>NFCReadingEvent</a>.
    </p>
  </section>
  <section> <h3>Handover to another wireless connection type</h3>
    <p>
      NFC supports handover protocols to Bluetooth or WiFi connectivity for
      the purpose of larger volume data transfer. The user touches another
      NFC capable device, and as a result configuration data is sent for a
      new Bluetooth or WiFi connection, which is then established between the
      devices.
    </p>
    <p class="note">
      This use case is not supported in this version of the specification.
    </p>
  </section>
  <section> <h3>Payment scenarios</h3>
    <p>
      Payment scenarios with Web NFC generally do not refer to supporting
      the payment process itself, but associating the payment status with
      a web page in order to have secondary actions. For instance,
      the user buys goods in a store, and payments options include contactless
      payment using NFC technology.
      In general, touching the device to the point of sales terminal receiver
      area will result in a transaction between the secure element from the
      device and the point of sales terminal. With the Web NFC API, if the
      user navigates to a web site before paying, there may be interaction
      with that site regarding the payment, e.g. the user could get points and
      discounts, or get delivered application or service specific data (e.g.
      tickets, keys, etc) to the device.
    </p>
    <p class="note">
      This use case is not supported in this version of the specification.
    </p>
  </section>
  <section> <h3>Support for multiple NFC adapters</h3>
    <p>
      Users may attach one or more external <a>NFC adapter</a>s to their
      devices, in addition to a built-in adapter. Users may use either
      <a>NFC adapter</a>.
    </p>
  </section>
</section> <!-- Use Cases -->

<section class="informative"> <h3>Features</h3>
  <p>High level features for the Web NFC specification include the following:
    <ol>
      <li>
        Support devices with single or multiple <a>NFC adapter</a>s.
        If there are multiple adapters present when invoking an NFC function
        then the UA operates all <a>NFC adapter</a>s in parallel.
      </li>
      <li>
        Support communication with active (powered devices such as readers,
        phones) and passive (smart cards, tags, etc) devices.
      </li>
      <li>
        Allow users to act on (e.g. read, write or transceive) discovered
        NFC devices (passive and active), as well as access the payload
        which were read in the process as <a>NDEF message</a>s.
      </li>
      <li>
        Allow users to write a payload via <a>NDEF record</a>s to compatible
        devices, such as writeable tags, when they come in range, as
        <a>NDEF message</a>s.
      </li>
      <li>
        [future] Allow manual connection for various technologies such as
        NFC-A and NFC-F depending on the secondary device.
      </li>
      <li>
        [future] Allow <a>NFC handover</a> to Bluetooth or WiFi.
      </li>
      <li>
        [future] Allow card emulation with secure element or host card
        emulation.
      </li>
    </ol>
  </p>
  <p>
    This specification makes a few simplifications in what use cases
    and data types the Web NFC API can handle:
    <ul>
      <li>
        Expose data types already known to web browsers as
        <a>MIME type</a>s.
      </li>
      <li>Use the web security model.</li>
      <li>
        Implementations encapsulate <a>NDEF record</a> handling and the API
        exposes only data and control events.
      </li>
    </ul>
  </p>
</section> <!-- Features -->

<!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>

  <section><h3>Push a text string to either a tag or peer</h3>
    <p>
      Pushing a text string to any kind of device is straightforward.
      Options can be left out, as they default to pushing to both tags
      and peers.
    </p>
    <pre class="example">
      const writer = new NFCWriter();
      writer.push(
        "Hello World"
      ).then(() => {
        console.log("Message pushed.");
      }).catch(error => {
        console.log(`Push failed :-( try again: ${error}.`);
      });
    </pre>
  </section>

  <section><h3>Push a text string to a peer device</h3>
    <p>
      It is possible to restrict to which devices (tags or peers) data
      should be pushed. Below we specify to only push to peers,
      and thus, no data is pushed when the user taps a tag.
    </p>
    <pre class="example">
      const writer = new NFCWriter();
      writer.push(
        "Text meant for peers only", { target: "peer" }
      ).then(() => {
        console.log("Message pushed.");
      }).catch(_ => {
        console.log("Push failed :-( try again.");
      });
    </pre>
  </section>

  <section> <h3>Push a URL to either a tag or peer</h3>
    <p>
      In order to push an NDEF record of URL type, simply use NDEFMessage.
    </p>
    <pre class="example">
      const writer = new NFCWriter();
      writer.push({
        records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
      }).then(() => {
        console.log("Message pushed.");
      }).catch(_ => {
        console.log("Push failed :-( try again.");
      });
    </pre>
  </section>

  <section> <h3>Read data from tag, and write to empty ones</h3>
    <p>
      Below we read various different kinds of data which can be stored on a tag.
      In the case the tag is empty, we write a text message with the value
      "Hello World".
    </p>
    <pre class="highlight">
      const writer = new NFCWriter();
      const reader = new NFCReader();

      reader.onreading = event => {
        const message = event.message;
        if (message.records[0].recordType == 'empty') {
          writer.push({
            url: "/custom/path",
            records: [{ recordType: "text", data: 'Hello World' }]
          });
          return;
        }

        console.log(`Read message written by ${message.url}`);

        for (let record of message.records) {
          switch (record.recordType) {
            case "text":
              console.log(`Text: ${record.toText()}`);
              break;
            case "url":
              console.log(`URL: ${record.toText()}`);
              break;
            case "json":
              console.log(`JSON: ${record.toJSON().myProperty}`);
              break;
            case "opaque":
              if (record.mediaType.startsWith('image/')) {
                const blob = new Blob([record.toArrayBuffer()], {type: record.mediaType});

                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                img.onload = () => window.URL.revokeObjectURL(this.src);

                document.body.appendChild(img);
              }
              break;
          }
        }
      };

      reader.scan();
    </pre>
  </section>

  <section> <h3>Save and restore game progress with another device</h3>
    <p>
      Filtering of relevant data sources can be done by the use of
      the <a>NFCScanOptions</a>. Below we accept the record identifier URL with
      "`/mypath/mygame/`" in its path from "`mygame.com`"
      domain and its subdomains. When we read the data, we immediately update
      the game progress by issueing a push with a custom NDEF data layout.
    </p>
    <p>
      The example allows reading and pushing to both peers and tags,
      whichever one is tapped first.
    </p>
    <pre class="example">
      const reader = new NFCReader();
      reader.scan({ id: "https://mygame.com/mypath/mygame" });
      reader.onreading = async event => {
        console.log(`Source:     ${ event.message.url }`);
        console.log(`Game state: ${ JSON.stringify(event.message.records) }`);

        const newMessage = {
          records: [{
            id: "/mypath/mygame/update",
            recordType: "json",
            mediaType: "application/json",
            data: { level: 3, points: 4500, lives: 3 }
          }]
        };
        const writer = new NFCWriter();
        await writer.push(newMessage);
        console.log("Pushed message");
      };
    </pre>
  </section>

  <section> <h3>Push and read JSON (serialized and deserialized)</h3>
    <p>
      Storing and receiving JSON data is easy with serialization and deserialization.
    </p>
    <pre class="example">
      const reader = new NFCReader();

      reader.addEventListener("reading", event => {
        for (let record of event.message.records) {
          const json = record.toJSON();
          const article =/[aeio]/.test(json.title) ? "an" : "a";
          console.log(`${json.name} is ${article} ${json.title}`);
        }
      });

      reader.scan({ url: document.baseURI, recordType: "json" });

      const writer = new NFCWriter();
      writer.push({
        records: [
          {
            recordType: "json",
            mediaType: "application/json",
            data: {
              name: "Benny Jensen",
              title: "Banker"
            }
          },
          {
            recordType: "json",
            mediaType: "application/json",
            data: {
              name: "Zoey Braun",
              title: "Engineer"
            }
          }]
      });
    </pre>
  </section>

  <section> <h3>Write data to tag and print out existing data</h3>
    <p>
      Pushing data to a tag requires tapping it. If existing data should be
      read during the same tap, we need to set the ignoreRead
      property to `false` for the <a>NFCWriter</a>.
    </p>
    <pre class="example">
      const reader = new NFCReader();
      reader.onreading = event => {
        for (let record of event.message.records) {
          console.log("Record type:  " + record.recordType);
          console.log("MIME type:    " + record.mediaType);
          console.log("=== data ===\n" + record.toText());
        }
      };
      reader.scan();

      const writer = new NFCWriter();
      writer.push("Pushing data is fun!", {target: "tag", ignoreRead: false});
    </pre>
  </section>

  <section> <h3>Stop listening to NDEF messages</h3>
    <p>
      Read NDEF messages for 3 seconds by using <a
      href="#dom-nfcscanoptions-signal">signal</a> in the <a>NFCScanOptions</a>.
    </p>
    <pre class="example">
      const reader = new NFCReader();
      reader.onreading = event => {
        console.log("NDEF message read.");
      };

      const controller = new AbortController();
      controller.signal.onabort = event => {
        console.log("We're done waiting for NDEF messages.");
      };

      reader.scan({ signal: controller.signal });

      // Stop listening to NDEF messages after 3s.
      setTimeout(() => controller.abort(), 3000);
    </pre>
  </section>

  <section> <h3>Read an external record with an NDEF message as payload</h3>
    <p>
      External type records can be used to create application defined records.
      These records may contain an <a>NDEF message</a> as payload,
      with its own <a>NDEF records</a>, including local types.
    </p>
    <p>
      The smart poster type also contains an <a>NDEF message</a> as
      payload.
    </p>
    <p>
      Local types are well-known types, local to a every
      individual record type that carries an <a>NDEF message</a> as payload.
    </p>
    <p>
      As NDEF gives no guarantee on the ordering of records, using
      an external type record with an <a>NDEF message</a> as payload,
      can be useful for encapsulating related data.
    </p>
    <p>
      For external type records, local types are application specific.
      Local types are exposed as a recordType, in this example prefixed with "`-`".
    </p>
    <p>
      This example shows how to read an external record for social posts,
      which contains an <a>NDEF message</a>, containing a text record and
      a record with the local type "act" (action), just like smart posters.
    </p>
    <pre class="example">
      const reader = new NFCReader();
      reader.onreading = event => {
        const socialPost = event.message.records[0];
        if (!socialPost) {
          return;
        }

        let action;
        let text = "";

        for (let record of socialPost.toRecords()) {
          switch (record.recordType) {
            case "text":
              text = record.toText();
              break;
            case "-act":
              const buffer = record.toArrayBuffer();
              const view = new DataView(buffer);
              action = view.getUint8(0);
              break;
          }
        }

        switch (action) {
          case 0: // do the action
            console.log(`Post "${text}" to timeline`);
            break;
          case 1: // save for later
            console.log(`Save "${text}" as a draft`);
            break;
          case 2: // open for editing
            console.log(`Show editable post with "${text}"`);
            break;
        }
      };

      reader.scan({ recordType: "example.com:sp"});
    </pre>
  </section>

  <section> <h3>Push a smart poster message</h3>
    <p>
      Smart poster is defined in the NFC Forum Smart Poster Record Type
      Definition specification as an NDEF record that contains an
      <a>NDEF message</a> as payload, which may contain several records: a
      mandatory URI record that refers to a content, and additional optional
      records for that content's title, icon, size, type and possible action
      (e.g. the value `0` for doing an action associated to the content, like
      send SMS, make call, launch browser, or the value `1` for saving the
      content, or the value `2` for opening for editing).
    </p>
    <pre class="example">
      const writer = new NFCWriter();
      writer.push({ records: [
        {
          recordType: "smart-poster",
          data: { records: [
            {
              recordType: "url",
              data: "https://my.org/content/19911"
            },
            {
              recordType: "t", // smart poster type, a local type to Sp
              data: "image/gif"
            },
            {
              recordType: "text",
              data: "Funny dance"
            },
            {
              recordType: "s",  // size, a local type to Sp
              data: 4096  // byte size of the content at the URL above
            },
            {
              recordType: "act",  // action, a local type to Sp
              data: 0  // do the action, in this case open in the browser
            }
          ]}
        }
      ]}).catch(_ => {
        console.log("Push failed");
      });
    </pre>
  </section>

  <section> <h3>Push an external record with an NDEF message as payload</h3>
    <p>
      External type records can be used to create application defined records
      that may even contain an <a>NDEF message</a> as payload.
    </p>
    <pre class="example">
      const writer = new NFCWriter();
      writer.push({ records: [
        {
          recordType: "external",
          data: {
            records: [
              {
                recordType: "url",
                data: "https://my.org/game/19911"
              },
              {
                recordType: "text",
                data: "Game context given here"
              },
              {
                recordType: "opaque",
                mediaType: "image/png"
                data: getImageBytes(fromURL);
              }
            ]
          }
        }
      ]}).catch(_ => {
        console.log("Push failed");
      });
    </pre>
  </section>
</section> <!-- Usage examples -->

<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2 id="security">Security and Privacy</h2>
  <p>
    The trust model, attacker model, threat model and possible mitigation
    proposals for the Web NFC API are presented in the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html">
    Security and Privacy</a> document. This section presents the chosen
    security and privacy model through normative requirements to
    implementations.
  </p>

  <section> <h3>Chain of trust</h3>
  <p>
    Web pages using the Web NFC API are not trusted.
    This means that the user needs to be aware of exactly what a web page is
    intending to do with NFC at any given moment. Implementations need to
    make sure that when the user authorizes a method of this API, then only that
    action is run, without side effects, and exactly in the context and the
    number of times the user allows the execution of NFC related operations,
    according to the algorithmic steps detailed in this specification.
  </p>
  <p>
    The integrity of <a>NFC content</a> SHOULD NOT be trusted when
    used for implementing security policies, for instance the authenticity of
    <a>record identifier</a>, unless a <a>prearranged trust relationship</a> exists.
  </p>
  </section>

  <section> <h3>Threats</h3>
  <p>
    The main threats are summarized in the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#threats-and-possible-solutions">
    Security and Privacy</a> document.
  </p>
  <p>
    In this specification the following threats are handled with the highest
    priority:
    <ul>
      <li>
        User data privacy: involuntary sharing of user data (such as location,
        contacts, personal data, etc) from an NFC-capable device such as a
        phone, tablet, or PC.
      </li>
      <li>
        Protecting existing <a>NFC tag</a>s from being overwritten by malicious
        web pages.
      </li>
    </ul>
  </p>
  </section>

  <section> <h3>Permissions and user prompts</h3>
  <p>
    This specification attempts to minimize user prompting and uses implicit
    security policies to address the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#threats-and-possible-solutions">
    threats</a>.
    However, this specification does not describe, nor does it
    mandate specific user prompting policies. The term <a>obtain permission</a>
    is used for acquiring trust for a given operation.
  </p>
  <p class="note">
    The [[[PERMISSIONS]]] API is suggested to be used by
    UAs for implementing NFC related [[[PERMISSIONS]]] in order to minimize
    the need for user prompting.
  </p>
  <p>
    All <a>expressed permission</a>s that are preserved beyond the current
    browsing session MUST be revocable.
  </p>
  </section>

  <section class="informative"> <h3>Security policies</h3>
    <p>
      This section summarizes the security policies which are specified as
      normative requirements in the respective algorithms of this
      specification.
    </p>
    <section> <h4>Secure Context</h4>
      <p>
        Only <a>secure contexts</a> are allowed to access <a>NFC content</a>.
        Browsers may ignore this rule for development purposes only.
      </p>
    </section>
    <section> <h4>Visible document</h4>
      <p>
        Web NFC functionality is allowed only for the {{Document}} of the
        <a>top-level browsing context</a>, which must be
        <dfn data-cite="PAGE-VISIBILITY#dom-visibilitystate-visible">visible</dfn>.
      </p>
      <p>
        This also means that UAs should block access to the NFC radio if
        the display is off or the device is locked.
        For backgrounded web pages, receiving and pushing <a>NFC content</a>
        must be <a id="#nfc-suspended">suspended</a>.
      </p>
    </section>
    <section> <h4>Permissions controls</h4>
      <p>
        Making an <a>NFC tag</a> read-only must <a>obtain permission</a>, or
        otherwise fail.
      </p>
      <p>
        Setting up listeners for reading <a>NFC content</a> should
        <a>obtain permission</a>.
      </p>
      <p>
        The process of reading an <a>NDEF message</a> does not need to
        <a>obtain permission</a>.
      </p>
      <p>
        Pushing <a>NFC content</a> to an <a>NFC peer</a> does not need to
        <a>obtain permission</a>, but the other rules in this section apply.
        See the [[[#writing-or-pushing-content]]] section.
      </p>
      <p>
        Pushing an <a>NDEF message</a> to an <a>NFC tag</a> does not need to
        <a>obtain permission</a>, if the existing <a>NDEF message</a> only
        contains <a>NDEF record</a>s without <a>ID field</a>s, or with <a>
        ID field</a>s matching the [=host/registrable domain=] of the
        <a>current settings object</a>'s origin.
        Otherwise the UA must <a>obtain permission</a> for pushing
        <a>NFC content</a> which overwrites existing information.
        See also the [[[#writing-or-pushing-content]]] section.
        <div class=issue>
          Verify with security folks.
        </div>
      </p>
      <p>
        Since all local content that a web page has access to can be shared with
        NFC, the user needs to be clearly aware about the permissions granted
        to the web page using the Web NFC API.
      </p>
    </section>
    <section> <h4>Store site URL as record identifier when writing data</h4>
      <p>
        When pushing an <a>NDEF message</a>, the [= host/registrable domain =],
        <a data-cite="dom#concept-host-serializer">serialized</a>,
        of the <a>current settings object</a> must be stored as the <a>record
        identifier</a> in each top-level <a>NDEF Record</a>.
      </p>
    </section>
    <section> <h4>Warn risk of physical location leak</h4>
      <p>
        When listening for and pushing <a>NFC content</a>,
        the UA may warn the user that the given <a>origin</a> may be able to
        infer physical location.
      </p>
    </section>
    <section> <h4>Restrict automatic handling</h4>
      <p>
        The payload data on <a>NFC content</a> is untrusted, and must not be used
        by the UA to do automatic handling such as opening a web page
        with a URL found in an <a>NFC tag</a>, unless the user approves that.
      </p>
    </section>
      <!--p>
        For Bluetooth and WiFi handover (supported in later versions),
        the user should have to grant access to the secondary API and must be
        able to properly understand what they are granting.
      </p-->
  </section> <!-- Policies -->
</section> <!-- Security and Privacy  -->

<!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
<section> <h2>Data Representation</h2>
  <section> <h3>The <dfn>NDEFMessage</dfn> interface</h3>
    <p>
      The content of any <a>NDEF message</a> is exposed by the
      <a>NDEFMessage</a> interface:
    </p>
    <pre class="idl">
      [Exposed=Window]
      interface NDEFMessage {
        constructor(NDEFMessageInit messageInit);
        readonly attribute FrozenArray&lt;NDEFRecord&gt; records;
      };

      dictionary NDEFMessageInit {
        sequence&lt;NDEFRecordInit&gt; records;
      };
    </pre>
    <p>
      The <dfn data-dfn-for="NDEFMessage">records</dfn>
      property represents a <a>list</a> of <a>NDEF record</a>s defining the
      <a>NDEF message</a>.
    </p>
    <p data-dfn-for="NDEFMessageInit">
      The <dfn>NDEFMessageInit</dfn> dictionary is used to initialize a
      <a>NDEF message</a>.
    </p>
  </section>

  <section data-dfn-for="NDEFRecord"> <h3>The <dfn>NDEFRecord</dfn> interface</h3>
    <p>
      The content of any <a>NDEF record</a> is exposed by the
      <a>NDEFRecord</a> interface:
    </p>
    <pre class="idl">
      [Exposed=Window]
      interface NDEFRecord {
        constructor(NDEFRecordInit recordInit);

        readonly attribute NDEFRecordType recordType;
        readonly attribute USVString mediaType;
        readonly attribute USVString id;

        USVString? toText();
        [NewObject] ArrayBuffer? toArrayBuffer();
        [NewObject] any toJSON();
        sequence&lt;NDEFRecord&gt; toRecords();
      };

      dictionary NDEFRecordInit {
        NDEFRecordType recordType;
        USVString mediaType;
        USVString id;

        any data;
      };
    </pre>

    <p>
      A <a>NDEFRecord</a> object has the following <a data-cite=
      "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal slots</a>:
    </p>
    <table class="simple">
      <thead>
        <tr>
          <th>
            Internal slot
          </th>
          <th>
            Initial value
          </th>
          <th>
            Description (<em>non-normative</em>)
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <dfn>[[\PayloadData]]</dfn>
          </td>
          <td>
            Empty <a>byte sequence</a>.
          </td>
          <td>
            A <a>byte sequence</a> representing the whole or a subset of the
            <a>PAYLOAD field</a> data.
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      The <dfn>mediaType</dfn> property represents the <a>MIME type</a> of
      the <a>NDEF record</a> payload.
    </p>
    <p>
      The <dfn>recordType</dfn> property represents the <a>NDEF record</a> types.
    </p>
    <p>
      The <dfn>id</dfn> property represents the <a>record identifier</a>, which is an
      absolute or relative URL. The required uniqueness of the identifier is
      guaranteed by the generator, as such only absolute URLs based on the origin
      of the browsing content can be written using this specification.
      <ul>
        <li>
          The <dfn>record identifier host</dfn> is a <a data-cite="url#concept-host-serializer">
          serialized host</a>.
        </li>
        <li>
          The <dfn>record identifier</dfn> is a <a>record identifier host</a>, optionally followed
          by a <a>path-absolute-URL string</a>.
        </li>
      </ul>
      <div class=note>
        The NFC NDEF specifications uses the terms "message identifier" and "payload identifier"
        instead of <a>record identifier</a>, but the identifier is tied to each record and not
        the message (collection of records), and it may be present when no payload is.
      </div>
    </p>
    <p>
      The <dfn>toText()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object and `text` target.
    </p>
    <p>
      The <dfn>toArrayBuffer()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object and `arrayBuffer` target.
    </p>
    <p>
      The <dfn>toJSON()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object and a `JSON` target.
    </p>
    <p>
      The <dfn>toRecords()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object and `records` target.
    </p>
    <p data-dfn-for="NDEFRecordInit">
      The <dfn>NDEFRecordInit</dfn> dictionary is used to initialize an <a>NDEF record</a>
      with its type, optional <a>MIME type</a>, <a>record identifier</a> and payload
      data via the members of
      <dfn>recordType</dfn>, <dfn>mediaType</dfn>, <dfn>id</dfn>,
      and <dfn>data</dfn>, respectively. The mapping from data types of an
      <a>NDEFRecordInit</a> to <a>NDEF record</a> types is presented
      in the algorithmic steps which handle the data and described in the
      [[[#steps-receiving]]] and [[[#writing-or-pushing-content]]] sections.
    </p>
    <p>
      To <dfn>convert NDEFRecord.[[\PayloadData]] bytes</dfn>, pass a |record:NDEFRecord| and a |target|, run these steps:
    </p>
    <ol class=algorithm>
      <li>
        Let |bytes:byte sequence| be |record|.<a>[[\PayloadData]]</a>.
      </li>
      <li>
        Let |recordType:NDEFRecordType| be the value of |record|'s
        <a data-link-for="NDEFRecord">recordType</a> attribute.
      </li>
      <li>Switch on |target|:
        <dl>
          <dt>text</dt>
          <ol>
            <li>
              If the |recordType| value is equal to "`empty`", return `null`.
            </li>
            <li>
              If the |recordType| value is equal to "`text`", then run the following sub-steps:
              <ol>
                <li>
                  Let |header| be the first <a>byte</a> of |bytes|.
                </li>
                <li>
                  Let |charset| be "`utf-8`" if bit `7` (<a>MB field</a>) of
                  |header| is equal to the value 0, or else "`utf-16be`".
                </li>
                <li>
                  Let |offset| be the value given by bit `5` to bit `0` of the
                  |header|.
                </li>
                <li>
                  Let |buffer| be the |bytes|,
                  from position |offset| + `1` to the end.
                </li>
                <li>
                  If |charset| is equal to "`utf-8`", return the result of
                  running <a>UTF-8 decode</a> on |buffer|.
                </li>
                <li>
                  Otherwise, return the result of running <a>decode</a> on
                  |buffer| with `encoding` set to "`utf-16be`".
                </li>
              </ol>
            </li>
            <li>
              Otherwise, return the result of running <a>UTF-8 decode</a> on |bytes|.
            </li>
          </ol>
          <dt>arrayBuffer</dt>
          <ol>
            <li>
              If the |recordType| value is equal to "`json`" or "`opaque`", then
              return an {{ArrayBuffer}} whose contents are the
              |bytes|. Re-[= exception/throw =] any exceptions.
            </li>
            <li>
              Otherwise, return `null`.
            </li>
          </ol>
          <dt>JSON</dt>
          <ol>
            <li>
              If the |recordType| value is equal to "`json`" or "`opaque`", then
              return the result of running <a>parse JSON from bytes</a>
              on |bytes|. Re-[= exception/throw =] any exceptions.
            </li>
            <li>
              Otherwise, return `null`.
            </li>
          </ol>
          <dt>records</dt>
          <ol>
            <li>
              If the |recordType| value is "`smart-poster`", or "`opaque`", or
              an <a>external type</a>, then return the result of running
              <a>parse records from bytes</a> on |bytes|.
              Re-[= exception/throw =] any exceptions.
            </li>
            <li>
              Otherwise, return `null`.
            </li>
          </ol>
        </dl>
      </li>
    </ol>
  </section> <!-- NDEFRecord dictionary -->

  <section data-dfn-for="NDEFRecordType">
    <h2>The <dfn>NDEFRecordType</dfn> string</h2>
      <p>
        This string defines the allowed types for a <a>NDEFRecord</a>. The
        [[[#data-mapping]]] section describes how
        <a>NDEFRecordType</a> is mapped to <a>NDEF record</a> types.
      </p>
      <pre class="idl">
        typedef DOMString NDEFRecordType;
      </pre>
      <p>
        A set of known standardized values exists, but it is also possible
        for organizations to create their own custom <a>external type</a>s.
      </p>
      <dl>
        <dt>The "<dfn>empty</dfn>" string</dt>
        <dd>
          The value representing <a href="#dfn-empty">empty</a> <a>NDEFRecord</a>.
        </dd>
        <dt>The "<dfn>text</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-text">text</a> type.
        </dd>
        <dt>The "<dfn>url</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-url">url</a> type.
        </dd>
        <dt>The "<dfn>smart-poster</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-smart-poster">smart-poster</a> type.
        </dd>
        <dt>The "<dfn>json</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-json">json</a> type.
        </dd>
        <dt>The "<dfn>opaque</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of an <a href="#dfn-opaque">opaque</a> type.
        </dd>
        <dt>An <dfn>external type</dfn></dt>
        <dd>
          A {{DOMString}} representing a custom type for the <a>external type record</a>.
          The type must follow the <a>external type</a> ABNF.
          <pre class="abnf">
            ext-type             = reg-name ":" custom-type
            custom-type          = 1*(ALPHA / DIGIT / other)

            DIGIT                = %x30-39
            ALPHA                = %x41-5A / %x61-7A   ; A-Z / a-z
            other                = "(" / ")" / "+" / "," / "-" / ":" / "=" /
                                   "@" / ";" / "$" / "_" / "!" / "*" / "'" / "."
          </pre>
          The `reg-name` value is a [=host/registrable domain=] owned by the issuing organization, a "`:`" and a type, e.g. "`w3.org:member`".
          And additional ABNF exists for <a>well-known type record</a>s:
          <pre class="abnf">
            wkt-type             = (ALPHA / DIGIT) *(ALPHA / DIGIT / other)
          </pre>
          <p class=note>
            The [[[NFC-RTD]]] defines every type in the <a>well-known type record</a>s and <a>external type records</a> in terms of URNs, but only a subset of the URN is actually stored in the <a>NDEF record</a>'s <a>TYPE field</a>, which corresponds to the above two ABNFs.
          </p>
        </dd>
      </dl>
  </section> <!-- NDEFRecordType enum -->

  <section id="data-mapping"><h3>Data mapping</h3>
  <p>
    The mapping from data types of an <a>NDEFRecordInit</a> to
    <a>NDEF record</a> types, as used in the [[[#writing-or-pushing-content]]]
    section is as follows:
  </p>
  <table class="simple">
    <tr>
      <th>NDEFRecordInit recordType</th>
      <th>NDEFRecordInit mediaType</th>
      <th>NDEFRecordInit data</th>
      <th>NDEF record type</th>
    </tr>
    <tr>
      <td><dfn>"`empty`"</dfn></td>
      <td><i>unused</i></td>
      <td><i>unused</i></td>
      <td><a>Empty record</a></td>
    </tr>
    <tr>
      <td><dfn>"`text`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}}</td>
      <td><a>Well-known type record</a> with type "`T`"</td>
    </tr>
    <tr>
      <td><dfn>"`url`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}}</td>
      <td><a>Well-known type record</a> with type "`U`"</td>
    </tr>
    <tr>
      <td><dfn>"`json`"</dfn></td>
      <td><a>JSON MIME type</a></td>
      <td>
        [= JSON type =]
      </td>
      <td><a>MIME type record</a> with type equal to
        <a>MIME type</a>.
      </td>
    </tr>
    <tr>
      <td><dfn>"`opaque`"</dfn></td>
      <td><a>MIME type</a></td>
      <td>{{ArrayBuffer}}</td>
      <td><a>MIME type record</a></td>
    </tr>
    <tr>
      <td><a>external type</a></td>
      <td><i>unused</i></td>
      <td>
        {{ArrayBuffer}} or<br>
        any <a>typed array type</a>
      </td>
      <td><a>External type record</a></td>
    </tr>
  </table>
  <p>
    The mapping from <a>NDEF record</a> types to <a>NDEFRecord</a>,
    as used for incoming <a>NDEF message</a>s described in the
    [[[#steps-receiving]]] section, is as
    follows:
  </p>
  <table class="simple" data-link-for="NDEFRecord">
    <tr>
      <th>NDEF record type</th>
      <th>NDEFRecord recordType</th>
      <th>NDEFRecord mediaType</th>
      <th>NDEFRecord data getters</th>
    </tr>
    <tr>
      <td><a>Empty record</a></td>
      <td>"`empty`"</td>
      <td><i>empty</i></td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>Well-known type record</a> with type "`T`"</td>
      <td>"`text`"</td>
      <td>"`text/plain`"</td>
      <td><a>toText()</a></td>
    </tr>
    <tr>
      <td><a>Well-known type record</a> with type "`U`"</td>
      <td>"`url`"</td>
      <td>"`text/plain`"</td>
      <td><a>toText()</a></td>
    </tr>
    <tr>
      <td><a>Well-known type record</a> with type "`Sp`"</td>
      <td>"`smart-poster`"</td>
      <td>""</td>
      <td>
        toRecords() or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>Absolute-URL record</a></td>
      <td>"`url`"</td>
      <td>"`text/plain`"</td>
      <td><a>toText()</a></td>
    </tr>
    <tr>
      <td><a>MIME type record</a> with
        <a>JSON MIME type</a>
      </td>
      <td>"`json`"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>MIME type record</a></td>
      <td>"`opaque`"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>External type record</a></td>
      <td><a>external type</a></td>
      <td>"`application/octet-stream`"</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td>Any other <a>NDEF record</a> type</td>
      <td>"`opaque`"</td>
      <td>"`application/octet-stream`"</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
  </table>
  </section>
</section> <!-- Data types and content -->


<section> <h2>The NFCReader and NFCWriter objects</h2>
  The objects provide a way for the <a>browsing context</a> to
  use NFC functionality.
  They allow for pushing <a>NDEF message</a>s to <a>NFC tag</a>s
  or <a>NFC peer</a>s within range, and to act on incoming
  <a>NDEF message</a>s either from an <a>NFC tag</a> or an
  <a>NFC peer</a>.
  <pre class="idl">
    typedef (DOMString or ArrayBuffer or NDEFMessageInit) NDEFMessageSource;

    [SecureContext, Exposed=Window]
    interface NFCWriter {
      constructor();

      Promise&lt;void&gt; push(NDEFMessageSource message, optional NFCPushOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NFCReader : EventTarget {
      constructor();

      attribute EventHandler onreading;
      attribute EventHandler onerror;

      void scan(optional NFCScanOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NFCReadingEvent : Event {
      constructor(DOMString type, NFCReadingEventInit readingEventInitDict);

      readonly attribute DOMString serialNumber;
      [SameObject] readonly attribute NDEFMessage message;
    };

    dictionary NFCReadingEventInit : EventInit {
      DOMString? serialNumber = "";
      required NDEFMessageInit message;
    };

    [SecureContext, Exposed=Window]
    interface NFCErrorEvent : Event {
      constructor(DOMString type, NFCErrorEventInit errorEventInitDict);

      readonly attribute DOMException error;
    };

    dictionary NFCErrorEventInit : EventInit {
      required DOMException error;
    };

  </pre>
  <p>
    The <dfn>NDEFMessageSource</dfn> is a union type representing argument types
    accepted by the <a href="#dom-nfcwriter-push">push()</a> method.
  </p>
  <p data-dfn-for="NFCReadingEvent">
    The <dfn>NFCReadingEvent</dfn> is the event being dispatched on new NFC readings.
    The <dfn>serialNumber</dfn> property represents the serial number of
    the device used for anti-collision and identification, or empty string in case none
    is available. The <dfn>message</dfn> is an <a>NDEFMessage</a> object.
  </p>
  <p data-dfn-for="NFCReadingEventInit">
    <dfn>NFCReadingEventInit</dfn> is used to initialize a new event with a serial number
    and the <a>NDEFMessageInit</a> data via the <dfn>message</dfn> member.
    If <dfn>serialNumber</dfn> is
    [= dictionary member/not present =] or is `null`,
    empty string will be used to init the event.
  </p>
  <p class="note">
    Though most tags will have a stable unique identifier (UID), not all
    have one and some tags even create a random number on each read.
    The serial number usually consists of 4 or 7 numbers, separated by `:`.
  </p>
  <p data-dfn-for="NFCErrorEvent">
    The <dfn>NFCErrorEvent</dfn> is the event being dispatched on errors,
    with the {{DOMException}} object as the <dfn>error</dfn>
    attribute.
  </p>
  <p data-dfn-for="NFCErrorEventInit">
    <dfn>NFCErrorEventInit</dfn> is used in order to initialize a new
    event with a {{DOMException}} data via the <dfn>error</dfn>
    member.
  </p>
  <p>
    The <dfn>NFCWriter</dfn> is an object used for writing data to NFC devices
    such as tags.
  </p>
  <p>
    An {{NFCWriter}} object has the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
    internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody data-link-for="NFCWriter">
     <tr>
      <td><dfn>[[\PushOptions]]</dfn></td>
      <td>`null`</td>
      <td>
        The {{NFCPushOptions}} value for writer.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\PushMessage]]</dfn></td>
      <td>`null`</td>
      <td>
        The {{NDEFMessage}} to be written.
        It is initially unset.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\PushTimer]]</dfn></td>
      <td>`null`</td>
      <td>
        A timer associated with the writer.
      </td>
     </tr>
    </tbody>
  </table>

  <p>
    The <dfn>NFCReader</dfn> is an object used for reading data when a device,
    such as a tag, is within the magnetic induction field.
  </p>
  <p>
    An {{NFCReader}} object has the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
    internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody data-link-for="NFCScanOptions">
     <tr>
      <td><dfn>[[\Id]]</dfn></td>
      <td>An empty <a>string</a>.
      <td>
        The {{NFCScanOptions}}.<a>id</a> value.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\RecordType]]</dfn></td>
      <td>`undefined`</td>
      <td>
        The {{NFCScanOptions}}.<a>recordType</a> value.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\MediaType]]</dfn></td>
      <td>An empty <a>string</a>.
      <td>
        The {{NFCScanOptions}}.<a>mediaType</a> value.
      </td>
      </tr>
      <tr>
        <td><dfn>[[\Signal]]</dfn></td>
        <td>`undefined`</td>
        <td>
          The {{NFCScanOptions}}.<a>signal</a> to abort the operation.
        </td>
      </tr>
    </tbody>
  </table>

  <p class="note">
    Note that the internal slots of {{NFCReader}} come from the
    |options:NFCScanOptions| passed to <a>NFCReader.scan()</a>.
    Therefore there is maximum one filter associated with any given
    {{NFCReader}} object and successive invocations of <a>NFCReader.scan()</a>
    with new |options:NFCScanOptions| will replace existing filters.
  </p>
  <p>
    The <dfn data-dfn-for="NFCReader">onreading</dfn> is an {{EventHandler}} which is called to notify
    that new reading is available.
  </p>
  <p>
    The <dfn data-dfn-for="NFCReader">onerror</dfn> is an {{EventHandler}} which is called to notify
    that an error happened.
  </p>
  <section><h3>NFC state associated with the settings object</h3>
  <p>
    The <a>relevant settings object</a> of the <a>active document</a> of a
    <a>browsing context</a> which supports NFC has an associated
    <dfn>NFC state</dfn> record with the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal
    slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><dfn>[[\Suspended]]</dfn></td>
      <td>`false`</td>
      <td>
        A boolean flag indicating whether NFC functionality is
        <a href="#nfc-suspended">suspended</a> or not, initially
        `false`.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\ActivatedReaderList]]</dfn></td>
      <td>empty <a>set</a></td>
      <td>
        A <a>set</a> of {{NFCReader}} instances.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\PendingPush]]</dfn></td>
      <td>empty</td>
      <td>
        A &lt;|promise:Promise|, |writer:NFCWriter|&gt; tuple where |promise|
        holds a pending {{Promise}} and |writer| holds an {{NFCWriter}}.
      </td>
      </tr>
    </tbody>
  </table>
  <p>
    The <dfn>activated reader objects</dfn> is the value of the <a>[[\ActivatedReaderList]]</a> internal slot.
  </p>
  <p>
    The <dfn>pending push tuple</dfn> is the value of the <a>[[\PendingPush]]</a> internal slot.
  </p>
  <p>
    <dfn id="nfc-is-suspended">NFC is suspended</dfn> if the <a>[[\Suspended]]</a> internal slot is `true`.
  </p>
  <p>
    To <dfn id="suspend-nfc">suspend NFC</dfn>, set the <a>[[\Suspended]]</a> internal slot to `true`.
  </p>
  <p>
    To <dfn id="resume-nfc">resume NFC</dfn>, set the <a>[[\Suspended]]</a> internal slot to `false`.
  </p>
  <p class="note">
    Internal slots are used only as a notation in this specification, and
    implementations do not necessarily have to map them to explicit internal
    properties.
  </p>
  </section>

  <section> <h3>Handling NFC adapters</h3>
    Implementations MAY use multiple <a>NFC adapter</a>s
    according to the algorithmic steps described in this specification.
  </section>

  <section><h3>Handling visibility change</h3>
    <p>
      When the user agent determines that the
      <dfn data-cite="PAGE-VISIBILITY#dfn-visibility-states">visibility
      state</dfn> of the [=environment settings object / responsible document=]
      of the <a>current settings object</a> changes, it must run these steps:
    </p>
    <ol class="algorithm">
      <li>Let |document:Document| be the [=environment settings object /
      responsible document=] of the <a>current settings object</a>.
      </li>
      <li>
        If |document|'s <a>visibility state</a> is `"visible"`,
        <a>resume NFC</a> and abort these steps.
      </li>
      <li>
        Otherwise, <a>suspend NFC</a> and attempt to <a>abort a pending
        push operation</a>.
      </li>
    </ol>
    <p>
      The term <dfn id="nfc-suspended">suspended</dfn> refers to NFC
      operations being suspended, which means that no <a>NFC content</a> is
      pushed by <a>NFCWriter</a>s, and no received <a>NFC content</a> is
      presented to any {{NFCReader}} while being suspended.
    </p>
  </section>

  <section><h3>Clearing the pending push tuple</h3>
  <p>
    To <dfn>clear the pending push tuple</dfn> on an
    <a>environment settings object</a>, perform the following steps:
    <ol class=algorithm>
      <li>
        If there is no <a>pending push tuple</a> |tuple|, abort these steps.
      </li>
      <li>
        Let |writer| be the <a>pending push tuple</a>'s writer.
      </li>
      <li>
        Stop |writer|.[[\PushTimer]] if active.
      </li>
      <li>
        Clear |tuple|.
      </li>
    </ol>
  </p>
</section>

  <section><h3>Aborting pending push operation</h3>
  <p>
    To attempt to <dfn>abort a pending push operation</dfn> on an
    <a>environment settings object</a>, perform the following steps:
    <ol class=algorithm>
      <li>
        If there is no <a>pending push tuple</a> |tuple|, abort these steps.
      </li>
      <li>
        If |tuple|'s writer has already initiated an ongoing NFC data transfer,
        abort these steps.
      </li>
      <li>
        Reject |tuple|'s promise with an {{"AbortError"}} {{DOMException}}
        and abort these steps.
        <p class=note>
          Rejecting the promise will clear the <a>pending push tuple</a>.
        </p>
      </li>
    </ol>
  </p>
  </section>

  <section><h3>Releasing NFC</h3>
  <p>
    To <dfn>release NFC</dfn> on an <a>environment settings object</a>,
    perform the following steps:
  </p>
  <ol id="steps-nfc-release">
    <li>
      <a>Suspend NFC</a>.
    </li>
    <li>
      Attempt to <a>abort a pending push operation</a>.
    </li>
    <li>
      Stop the <a>dispatch NFC content</a> steps.
    </li>
    <li>
      Clear the <a>activated reader objects</a>.
    </li>
    <li>
      Release the NFC resources associated with |nfc| on the
      underlying platform.
    </li>
  </ol>
  <p>
    The UA must <a>release NFC</a> given the document's <a>relevant settings object</a> as
    additional <a>unloading document cleanup steps</a>.
  </p>
  </section> <!-- release NFC -->

  <section data-dfn-for="NFCPushOptions"> <h3>The <dfn>NFCPushOptions</dfn> dictionary</h3>
    <pre class="idl">
      dictionary NFCPushOptions {
        NFCPushTarget target = "any";
        unrestricted double timeout = Infinity;
        boolean ignoreRead = true;
        AbortSignal? signal;
      };
    </pre>
    <p>
      The <dfn>target</dfn> property
      denotes the intended target for the pending
      <a href="#dom-nfcwriter-push">push()</a>
      operation.
    </p>
    <p>
      The <dfn>timeout</dfn> property
      denotes the timeout for the pending
      <a href="#dom-nfcwriter-push">push()</a>
      operation expressed in milliseconds. The default value is
      implementation-dependent. The value `Infinity` means there is
      no timeout, i.e. no timer is started. After the |timeout|
      expires, the message set for pushing is cleared, an error is returned,
      and a new <a>NDEF message</a> can be set for pushing.
    </p>
    <p>
      When the value of the <dfn>ignoreRead</dfn> property is
      `true`, the <a href="#steps-push">push algorithm</a>
      will skip invoking the <a href="#steps-receiving">
      receiving and parsing steps</a> for an <a>NFC tag</a>.
    </p>
    <p>
      The <dfn>signal</dfn> property allows to abort
      the <a href="#dom-nfcwriter-push">push()</a> operation.
    </p>
  </section>

  <section data-dfn-for="NFCPushTarget">
    <h2>The <dfn>NFCPushTarget</dfn> enum</h2>
    <p>
      This enum defines the set of intended target values for the
      <a href="#dom-nfcwriter-push">push()</a> operation.
    </p>
    <pre class="idl">
      enum NFCPushTarget {
        "tag",
        "peer",
        "any"
      };
    </pre>
    <dl>
      <dt><dfn>tag</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push">push()</a> operation to be
        a <a>NFC tag</a>.
      </dd>
      <dt><dfn>peer</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push">push()</a> operation to be
        a <a>NFC peer</a>.
      </dd>
      <dt><dfn>any</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push">push()</a> operation to be
        a <a>NFC tag</a> or a <a>NFC peer</a>.
      </dd>
    </dl>
  </section> <!-- NFCPushTarget enum -->

  <section data-dfn-for="NFCScanOptions">
    <h3>The <dfn>NFCScanOptions</dfn> dictionary</h3>
      <p>
        To describe which messages an application is interested in, the
        <a>NFCScanOptions</a> dictionary is used:
      </p>
      <pre class="idl">
        dictionary NFCScanOptions {
          USVString id = "";
          NDEFRecordType recordType;
          USVString mediaType = "";
          AbortSignal? signal;
        };
      </pre>
      <p>
        The <dfn>signal</dfn> property allows to abort the
        <a href="#dom-nfcreader-scan">scan()</a> operation.
      </p>
      <p>
        The <dfn>id</dfn> property
        denotes the <a>URL pattern</a> which is used for matching the
        <a>record identifier</a> of individual <a>NDEF Record</a>s which are being read.
        The default value `""` means that no matching is performed.
      </p>
    <p>
        The <dfn>recordType</dfn> property
        denotes the enum value which is used for matching the
        <a href="#idl-def-ndefrecordtype">recordType</a> property of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        If the dictionary member is [= dictionary member/not present =],
        then it will be ignored by the <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>mediaType</dfn> property
        denotes the <a>match pattern</a> which is used for matching the
        <a href="#dom-ndefrecord-mediatype">mediaType</a> property of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        The default value `""` means that no matching is performed.
      </p>
      <pre
        title="Filter accepting only JSON content from https://www.w3.org"
        class="example highlight">
        const options = {
          id: "https://www.w3.org/*",  // any path from the domain is accepted
          recordType: "json",
          mediaType: "application/*+json"  // any JSON-based MIME type
        }
      </pre>
      <pre
        title="Filter which only accepts binary content from a given path for w3 domain and its subdomains"
        class="example highlight">
        const options = {
          id: "https://w3.org/info/restaurant/daily-menu/",
          recordType: "opaque",
          mediaType: "application/octet-stream"
        }
      </pre>
  </section> <!-- NFCScanOptions -->

  <section id="writing-or-pushing-content">
    <h3><dfn>Writing or pushing content</dfn></h3>
    <p>
      This section describes how to write an <a>NDEF message</a>
      to an <a>NFC tag</a> or how to push it to an <a>NFC peer</a>
      device when it is next time in proximity range before a timer expires.
      At any time there is at maximum of two
      <a>NDEF message</a>s that can be set for pushing for an <a>origin</a>:
      one targeted to <a>NFC tag</a>s and one to <a>NFC peer</a>s, until
      the current message is sent, a timeout happens, or the push is
      aborted.
    </p>
    <section><h3>The <strong>push()</strong> method</h3>
      <p id="steps-push">
        The
        <dfn>NFCWriter.push</dfn> method, when invoked, MUST run the
        <dfn>push a message</dfn> algorithm:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be a new {{Promise}} object.
          </li>
          <li>
            Let |message:NDEFMessageSource| be the first argument.
          </li>
          <li>
            Let |options:NFCPushOptions| be the second argument.
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection cannot
            be established, then reject |p| with a
            {{"NotSupportedError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If the UA is not allowed to access the underlying <a>NFC Adapter</a>
            (e.g. a user preference), then reject |p| with a
            {{"NotReadableError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If pushing data is not supported by the underlying
            <a>NFC Adapter</a>, then reject |p| with a {{"NotSupportedError"}}
            {{DOMException}} and return |p|.
          </li>
          <li>
            Let |signal:AbortSignal| be the |options| dictionary member
            of the same name if present, or `null` otherwise.
          </li>
          <li>
            If |signal|s [= AbortSignal/aborted flag =] is set, then reject |p|
            with an {{"AbortError"}} {{DOMException}} and return |p|.
          </li>
          <li>
            If |signal| is not `null`, then
            <a data-cite="dom#abortsignal-abort-algorithms">
            add the following abort steps</a> to |signal|:
              <ol>
                <li>
                  Run the <a>abort a pending push operation</a> on the
                  <a>environment settings object</a>.
                </li>
              </ol>
          </li>
          <li>
            [=promise/React=] to |p|:
            <ol>
              <li>
                if |p| was settled (fulfilled or rejected), then run the
                <a>clear the pending push tuple</a> steps.
              </li>
            </ol>
          </li>
          <li>
            Return |p| and run the following steps <a>in parallel</a>:
            <ol>
              <li>
                An implementation MAY reject |p| with
                a {{"NotSupportedError"}} {{DOMException}}
                and abort these steps.
                <p class="note">
                  The UA might abort message push at this point. The reasons
                  for termination are implementation details. For example, the
                  user could have has set a preference to allow a given origin
                  only to read, write, or push data to peers. Also, the
                  implementation might be unable to support the requested
                  operation.
                </p>
                <li>
                  Let |output| be the notation for the <a>NDEF message</a>
                  to be created by UA, as the result of passing
                  |message| to <a>create NDEF message</a>.
                  If this throws an exception, reject |p| with that
                  exception and abort these steps.
                </li>
                <li>
                  Attempt to <a>abort a pending push operation</a>.
                  <p class="note">
                    A push replaces all previously configured push operations.
                  </p>
                </li>
                <li>
                  Set `this`.[[\PushOptions]] to |options|.
                </li>
                <li>
                  Set `this`.[[\PushMessage]] to |output|.
                </li>
                <li>
                  Set <a>pending push tuple</a> to (`this`, |p|).
                </li>
                <li>
                  Run the <a>start the push timer</a> steps.
                </li>
                <li>
                  Run the <a>start the NFC push</a> steps whenever an
                  <a>NFC device</a> |device| comes within communication range.
                </li>
                <p class="note">
                  If <a>NFC is suspended</a>,
                  continue waiting until |timer| expires (if set), or
                  promise is aborted by the user, or until an <a>NFC device</a>
                  comes within communication range.
                </p>
              </ol>
            </li>
          </li>
        </ol>
      </p>

      <p id="steps-push-timer">
        To <dfn>start the push timer</dfn>, run these steps:
        <ol class=algorithm>
          <p>
            Let |p:Promise| be the <a>pending push tuple</a>'s promise.
          </p>
          <li>
            Let |writer:NFCWriter| be the <a>pending push tuple</a>'s writer.
          </li>
          <li>
            Let |timeout:number| be |writer|.[[\PushOptions]]'s timeout.
            <ul>
              <li>
                If |timeout| value is `NaN` or negative, reject
                |p| with a {{TypeError}} and abort these steps.
              </li>
              <li>
                If |timeout| value is not supported by the UA, reject
                |p| with a {{"NotSupportedError"}}
                {{DOMException}} and abort these steps.
              </li>
              <li>
                If |timeout| value is equal to `Infinity`, abort these
                steps.
              </li>
            </ul>
          </li>
          <li>
            Start a timer |timer| with the timeout value set to
            |timeout| and set |writer|.[[\PushTimer]] to |timer|.
          </li>
          <li>
            When |timer| expires, reject |p| with {{"TimeoutError"}}
            {{DOMException}}.
          </li>
        </ol>
      </p>

      <p id="steps-start-nfc-push">
        To <dfn>start the NFC push</dfn>, run these steps:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be the <a>pending push tuple</a>'s promise.
          </li>
          <li>
            Let |writer| be the <a>pending push tuple</a>'s writer.
          </li>
          <li>
            Let |options:NFCPushOptions| be |writer|.[[\PushOptions]].
          </li>
          <li>
            Let |target:NFCPushTarget| be |options|' target.
          </li>
          <li>
            Verify the following conditions:
            <ul>
              <li>
                if |device| is an <a>NFC tag</a>, |target| is
                "`tag`" or "`any`".
              </li>
              <li>
                if |device| is an <a>NFC peer</a>, |target| is
                "`peer`" or "`any`".
              </li>
              <li>
                <a href="#nfc-is-suspended">NFC is not suspended</a>.
              </li>
            </ul>
          </li>
          <li>
            In case of success, run the following steps:
            <ol>
              <li>
                Stop |writer|.[[\PushTimer]] if active.
              </li>
              <li>
                If |device| is an <a>NFC tag</a>,
                <ul>
                  <li>Read the tag.</li>
                  <li>
                    If |options|'s ignoreRead is not equal to
                    `true`, run the
                    <a href="#steps-receiving">receiving steps</a>.
                  </li>
                  <li>
                    Let |idHost| be the <a>record identifier host</a> of the
                    tag.
                  </li>
                  <li>
                    If |idHost| is `null`, or different than the
                    <a data-cite="url#concept-host-serializer">
                    serialized host</a> of the <a>current settings object</a>'s
                    origin, and the <a>obtain push permission</a> steps return
                    `false`, then reject |p| with {{"NotAllowedError"}}
                    {{DOMException}} and abort these steps.
                  </li>
                </ul>
              </li>
              <li>
                Let |output:NDEFMessage| be |writer|.[[\PushMessage]].
              </li>
              <li>
                Initiate data transfer to |device| using
                |output| as buffer, using the <a>NFC adapter</a>
                in communication range with |device|.
                <p class="note">
                  Multiple adapters should be used sequentially by users.
                  There is very small likelihood that a simultaneous tap
                  will happen on two or multiple different and connected
                  <a>NFC adapter</a>s.
                  If it happens, the user will likely need to repeat the
                  taps until success, preferably one device at a time.
                  The error here gives an indication that the operation
                  needs to be repeated. Otherwise the user may think the
                  operation succeeded on all connected <a>NFC adapter</a>s.
                </p>
              </li>
              <li>
                If the transfer fails, reject |p| with
                {{"NetworkError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                When the transfer has completed, resolve |p|.
              </li>
            </ol>
          </li>
        </ol>
      </p>

      <section><h3>Obtaining push permission</h3>
      <p>
        To <dfn>obtain push permission</dfn>, run these steps:
        <ol class=algorithm>
          <li>
            If there is a <a>prearranged trust relationship</a>,
            return `true`.
          </li>
          <li>
            Run the
            <a>query a permission</a> steps for the
            <a>Web NFC permission name</a> until completion.
            <ol>
              <li>
                If it resolved with {{PermissionState["granted"]}}
                (i.e. an <a>expressed permission</a> has been granted
                to the <a>origin</a> and <a>global object</a> using
                the [[[PERMISSIONS]]] API), return `true`.
              </li>
              <li>
                Otherwise, if it resolved with {{PermissionState["prompt"]}}, then optionally
                <a data-lt="request permission to use">request permission</a>
                from the user for the <a>Web NFC permission name</a>.
                If that is granted, return `true`.
                <p class="issue">
                  The <a data-lt="request permission to use">request permission</a>
                  steps are not yet clearly defined.
                  At this point the UA asks the user about the policy to be used
                  with the <a>Web NFC permission name</a> for the given
                  <a>origin</a> and <a>global object</a>, if the user grants permission,
                  return `true`.
                </p>
              </li>
            </ol>
          </li>
          <li>
            Return `false`.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating NDEF message</h3>
        <p>
          To <dfn>create NDEF message</dfn> given a
          |message:NDEFMessageSource| run these steps:
        </p>
        <ol class=algorithm id="create-web-nfc-message">
          <li>
            If the |message:NDEFMessageSource| parameter is not of type defined
            by the <a>NDEFMessageSource</a> union, throw a {{TypeError}} and
            abort these steps.
          </li>
          <li>
            If the |message:NDEFMessageSource| parameter is of
            <a>NDEFMessageInit</a> type, and |message|'s records
            [= list/is empty =], throw a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |output| be the notation for the <a>NDEF message</a>
            to be created by the UA as a result of these steps.
          </li>
          <li>
            [= list/For each =] |record:NDEFRecordInit| in the <a>list</a>
            |message|'s records, run the following steps, or make sure
            that the underlying platform provides equivalent values to
            |ndef|:
            <ol>
              <li>
                If |record|'s recordType is `undefined`:
                <ol> <!-- guess type and mediaType from data -->
                  <li>
                    If |record|'s data is `undefined`, reject |promise|
                    a {{TypeError}} and abort these steps.
                  </li>
                  <li>
                    Otherwise, if the type of |record|'s data is
                    {{DOMString}}, then set |record|'s recordType to "`text`".
                  </li>
                  <li>
                    Otherwise, if the type of |record|'s data is an
                    {{ArrayBuffer}}, then set |record|'s recordType
                    to "`opaque`".
                  </li>
                  <li>
                    Otherwise, set |record|'s recordType to "`json`".
                  </li>
                </ol>
              </li>
              <li>Let |ndef| be the result of passing |record| to the algorithm below
                switching on |record|'s recordType. If the algorithm throws an exception
                |e|, reject |promise| with |e| and abort these steps.
                <dl>
                  <dt>"`empty`"</dt>
                  <ul>
                    <li>
                      <a>map empty record to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`text`"</dt>
                  <ul>
                    <li>
                      <a>map text to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`url`"</dt>
                  <ul>
                    <li>
                      <a>map a URL to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`json`"</dt>
                  <ul>
                    <li>
                      <a>map JSON to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`opaque`"</dt>
                  <ul>
                    <li>
                      If |record|'s data is {{NDEFMessageSource}}, then return
                      the result of running the <a>create NDEF message</a>
                      given |record|'s data.
                    </li>
                    <li>
                      Otherwise, <a>map binary data to NDEF</a>.
                    </li>
                  </ul>
                  <dt><a>external type</a></dt>
                  <ul>
                    <li>
                      If |record|'s data is of type {{NDEFMessageInit}}, then
                      return the result of running the
                      <a>create NDEF message</a> given |record|'s data.
                    </li>
                    <li>
                      Otherwise, <a>map external data to NDEF</a>
                    </li>
                  </ul>
                  <dt>unmatched type</dt>
                  <ul>
                    <li>
                      [= exception/throw =] a {{TypeError}}
                    </li>
                  </ul>
                </dl>
                <li>
                  If |message|'s |id:string| is not `null`:
                  <ul>
                    <li>
                      Set |identifier| to the result of invoking
                      <a>create a record identifier</a> given |id|.
                      If this throws an exception, re-[= exception/throw =] it.
                    </li>
                    <li>
                      Set |ndef|'s <a>IL field</a> to `1`.
                    </li>
                    <li>
                      Set |ndef|'s <a>ID LENGTH field</a> to the length of |identifier|.
                    </li>
                    <li>
                      Set |ndef|'s <a>ID field</a> to |identifier|.
                    </li>
                  </ul>
                </li>
                <li>
                  Add |ndef| to |output|.
                </li>
              </li> <!-- converting each record -->
            </ol>
          </li> <!-- converting message -->
        </ol>
      </section>

      <section><h3>Mapping empty record to NDEF</h3>
      <p>
        To <dfn>map empty record to NDEF</dfn> given a |record:NDEFRecordInit|, run
        these steps:
        <ol class=algorithm>
          <li>
            Let |ndef| be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>Set the
            |ndef|'s <a>TNF field</a> to `0` (<a>empty record</a>).
          </li>
          <li>Set the
            |ndef|'s <a>IL field</a> to `0`.
          </li>
          <li>Set
            |ndef|'s <a>TYPE LENGTH field</a>,
            and <a>PAYLOAD LENGTH field</a> to `0`,
            and omit <a>TYPE field</a> and <a>PAYLOAD field</a>.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping string to NDEF</h3>
      <p>
        To <dfn>map text to NDEF</dfn> given a |record:NDEFRecordInit|, run these
        steps:
        <p class="note">
          This is useful when clients specifically want to write text in a
          <a>well-known type record</a>.
          Other options would be to use the value "`opaque`"
          with an explicit <a>MIME type</a> text type, which allows for
          better differentiation, e.g. when using "`text/xml`", or
          "`text/vcard`".
        </p>
        <ol class=algorithm>
          <li>
            If the type of a |record|'s data is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on
            |record|'s mediaType.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`text`", and subtype is "`plain`".
              </li>
              <li>
                If |mimeTypeRecord|'s type is not "`text`", then [= exception/throw =] a
                {{"SyntaxError"}} {{DOMException}} and abort these steps.
              </li>
            </ol>
          </li>
          <li>
            Let |language:string| be |mimeTypeRecord|'s parameters["`lang`"] if it
            [= map/exists =], or "`en`".
          </li>
          <li>
            Let |charset:string| be |mimeTypeRecord|'s parameters["`charset`"] if it
            [= map/exists =], or "`utf-8`".
          </li>
          <li>
            If |charset| is not equal to "`utf-8`",
            [= exception/throw =] a {{TypeError}}.
          </li>
          <li>
            Let |header:byte| be a <a>byte</a> constructed the following way:
            <ol>
              <li>
                Set bit `7` to the value `0`
                (meaning <a>UTF-8 encoding</a>).
              </li>
              <li>
                Set bit `6` to the value `0` (reserved).
              </li>
              <li>
                Let |languageLength:octed| be the length of the
                |language| <a>string</a>.
              </li>
              <li>
                If |languageLength| cannot be stored in 6 bit (|languageLength| > 63),
                [= exception/throw =] a {{SyntaxError}}.
              <li>
                Set bit `5` to bit `0` to |languageLength|.
              </li>
            </ol>
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> (position 0) of |data| to |header|.
              </li>
              <li>
                Set position 1 (second <a>byte</a>) to position |languageLength|
                of |data| to |language|.
              </li>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of
                running <a>UTF-8 encode</a> on |record|'s data.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from |stream| into
                |data| (from position |languageLength| + 1) until
                <a data-cite="encoding#concept-stream-read">read</a>
                returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `1` (<a>well-known type record</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to "`T`" (`0x54`).
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      <p class="note">
        The `lang=` parameter is a non-standard parameter
        to <a>MIME type</a>s, but it is used in this specification
        in order to maintain compatibility with [[[NFC-STANDARDS]]].
      </p>
      </section>

      <section><h3>Mapping URL to NDEF</h3>
      <p>
        To <dfn>map a URL to NDEF</dfn> given a |record:NDEFRecordInit|, run these
        steps:
        <ol class=algorithm>
          <li>
            If |record|'s data is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |url:URL| be the result of
            <a data-lt="url parser">parsing</a> |record|'s data.
          </li>
          <li>
            If |url| is failure, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |serializedURL:string| be <a data-cite="url#concept-url-serializer">serialization</a>
            of |url|.
          </li>
          <li>
            Match the URI prefixes as defined in [[[NFC-STANDARDS]]],
            URI Record Type Definition specification, Section 3.2.2, against
            the |serializedURL|.
          </li>
          <li>
            Let |prefixString:string| be the matched prefix or else the
            <a href="#dfn-empty">empty</a> <a>string</a>.
          </li>
          <li>
            Let |prefixByte:byte| be the corresponding prefix number,
            or else `0`.
          </li>
          <li>
            Let |shortenedURL:string| be |serializedURL| with
            |prefixString| removed from the start of the <a>string</a>.
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> of |data| to |prefixByte|.
              </li>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of
                running <a>UTF-8 encode</a> on |shortenedURL|.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from |stream| into
                |data| (from position 1) until <a data-cite="encoding#concept-stream-read">read</a>
                returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `1` (<a>well-known type record</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to "`U`" (`0x55`).
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping JSON to NDEF</h3>
      <p>
        To <dfn>map JSON to NDEF</dfn> given a |record:NDEFRecordInit|,
        run these steps:
        <ol class=algorithm>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on |record|'s mediaType.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`application`", and subtype is "`json`".
              </li>
              <li>
                If |mimeTypeRecord| is not a <a>JSON MIME type</a>,
                then [= exception/throw =] a
                {{"SyntaxError"}} {{DOMException}} and abort these steps.
              </li>
            </ol>
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of executing
                <a>serialize JSON to bytes</a> on |record|'s data.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from |stream| into
                |data| until <a data-cite="encoding#concept-stream-read">read</a> returns
                <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `2` (<a>MIME type</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to the result of
                <a>serialize a MIME type</a> with |mimeTypeRecord| as
                the input.
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      <aside class=note>
        <p>
          JavaScript Object Notation aka JSON can be any of the following [[[ECMASCRIPT]]]
          types: object, array, String, Boolean, Number or null, which covers a lot of
          the [[[WEBIDL]]] types as listed here: [= JSON type =].
        </p>
        <p>
          Serializing JSON to bytes can result in 0 bytes in some cases, like serializing
          the following object, which specifies it own
          <a data-cite="webidl#idl-tojson-operation">toJSON</a> operation:

          <pre class=highlight>
            class ZeroByteJSON {
              toJSON() {
                return undefined;
              }
            }
          </pre>

          This means that the <a>map JSON to NDEF</a> algorithm might result in a
          <a>NDEF record</a> with no <a>PAYLOAD field</a>.
        </p>
      </aside>
      </section>

      <section><h3>Mapping binary data to NDEF</h3>
      <p>
        To <dfn>map binary data to NDEF</dfn> given a |record:NDEFRecordInit|,
        run these steps:
        <ol class=algorithm>
          <li>
            If the type of a |record|'s data is not an
            {{ArrayBuffer}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on |record|'s mediaType.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`application`", and subtype is "`octet-stream`".
              </li>
            </ol>
          </li>
          <li>
            Set |arrayBuffer| to |record|'s data.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `2` (<a>MIME type</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to the result of
                <a>serialize a MIME type</a> with |mimeTypeRecord| as
                the input.
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping external data to NDEF</h3>
      <p>
        To <dfn>map external data to NDEF</dfn> given a |record:NDEFRecordInit|,
        run these steps:
        <ol class=algorithm>
          <li>
            If the type of a |record|'s data is not an
            {{ArrayBuffer}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <div class=issue>
            In addition to supporting ArrayBuffer, we need to support sub records. That
            is really what makes external records interesting.
          </div>
          <li>
            Set |arrayBuffer| to |record|'s data.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set |ndefRecord|'s <a>TNF field</a> to `4` (<a>external type record</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to |record|'s recordType.
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating a record identifier</h3>
      <p>
        To <dfn>create a record identifier</dfn> given URL string |id:string|,
        run these steps:
        <ol class=algorithm>
          <li>
            Let |origin| be the <a>current settings object</a>'s origin.
          </li>
          <li>
            Let |host| be |origin|'s host,
            <a data-cite="url#concept-host-serializer">serialized</a>.
          </li>
          <li>
            Let |urlRecord| be the result of
            <a data-lt="url parser">parsing</a> |id| with "`https://`" + |host| as the base URL.
          </li>
          <li>
            If any of the following cases matches, [= exception/throw =] a
            {{TypeError}} and abort these steps:
            <ul>
              <li>
                If |urlRecord| is failure.
              </li>
              <li>
                If |urlRecord|'s protocol is not equal to `"https:`".
              </li>
              <li>
                If |urlRecord|'s host doesn't end with |host|'s [=host/registrable domain=].
              </li>
            </ul>
          </li>
          <li>
            Let |identifier| be |urlRecord|, <a data-cite="dom#concept-url-serializer">serialized</a>.
          </li>
          <li>
            Return |identifier|.
          </li>
        </ol>
      </p>
      </section>
    </section> <!-- push() -->

  </section> <!-- Writing or pushing content -->

  <section> <h3>Listening for content</h3>
    <p>
      To listen for <a>NFC content</a>, the client MUST activate an
      {{NFCReader}} instance by calling <a>NFCReader.scan()</a>. When attaching
      an event listener for the "`reading`" event on it, <a>NFC content</a> is
      accessible to the client.
    </p>
    <p>
      Each {{NFCReader}} can accept <a>NDEF message</a>s based on
      data type, and a record identifier (URL) filters.
    </p>
    <p>
      Filtering by a <a>record identifier</a> URL pattern, means that it will
      be matched against the URLs found in the <a>NDEF record</a>s' <a>ID field</a>,
      thus the presence of such is required.
    </p>

    <section> <h3>Match patterns</h3>
      <p>
        A <dfn>match pattern</dfn> is defined by the following ABNF:
        <pre class="abnf">
          match-pattern  = top-level-type "/" [ tree "." ] subtype [ "+" suffix ] [ ";" parameters ]
          top-level-type = "*" / &lt; VCHAR except "/" and "*" &gt;
          subtype        = "*" / &lt; VCHAR except "+" &gt;
        </pre>
        A <a>match pattern</a> is a
        <a href="http://pubs.opengroup.org/onlinepubs/007904875/utilities/xcu_chap02.html#tag_02_13_03">
        glob</a> used for matching <a>MIME type</a>s,
        for instance the pattern "`application/*+json`" matches
        "`application/calendar+json`", but does not match
        "`application/json`". The pattern
        "`*/*json`", on the other hand, matches both.
      </p>
    </section>
    <section> <h3>URL patterns</h3>
        A <dfn>URL pattern</dfn> is a <a>URL record</a> that can be used to match
        the optional <a>record identifier</a> of every <a>NDEF record</a> <a>ID field</a>.
        A <dfn>valid URL pattern</dfn> is a valid <a>URL record</a> whose
        [= url/scheme =] component is equal to "`https`".

      <p>
        A <a>URL pattern</a>'s [= url/scheme =], [= url/host =]
        and [= url/path =] components that are used by the
        <a href="#dfn-match-record-identifier-with-url-pattern">URL pattern match algorithm</a>
        have the following matching rules:

        <table class="simple">
          <tr>
            <th><strong>URL pattern component</strong></th>
            <th><strong>Matching rule for record identifier</strong></th>
          </tr>
          <tr>
            <td>[= url/host =]</td>
            <td>
              exact match or ends with (<a>URL pattern</a>'s
              [= url/host =] prepended
              with "`.`").
            </td>
          </tr>
          <tr>
            <td>[= url/path =]</td>
            <td>
              If <a>URL pattern</a>'s path is "`/*`", match any
              <a>record identifier</a> path. Otherwise, begins with <a>URL pattern</a>'s
              [= url/path =].
            </td>
          </tr>
        </table>
      </p>

      <p class="note">
        For example, '`https://mydomain.com/*`' will match
        '`https://service.mydomain.com/myapp/`' and
        '`https://info.mydomain.com/general/`', while
        '`https://app.mydomain.com/contacts`' will match
        '`https://app.mydomain.com/contacts`' and
        '`https://app.mydomain.com/contacts/all`'

        The '`*`' is a valid character for the URL path component,
        therefore,
        '`https://www.mydomain.com/*`' pattern will match both
        '`https://www.mydomain.com/*`' and
        '`https://www.mydomain.com/service`' URLs.
      </p>
    </section>

    <section> <h3>URL pattern match algorithm</h3>
        To <dfn>match record identifier with URL pattern</dfn> for a given
        <a>record identifier</a> and <a>URL pattern</a>, run
        these steps:
        <ol class=algorithm>
          <li>
            Let |raw id| be a <a>record identifier</a> passed to this algorithm.
          </li>
          <li>
            Let |raw pattern| be a <a>URL pattern</a> passed to this algorithm.
          </li>
          <li>
            If |raw id| and |raw pattern| are empty <a>string</a>s,
            return `true`.
          </li>
          <li>
            Let |id| be the result of running the
            <a>basic URL parser</a> on |raw id|.
          </li>
          <li>
            If |id| is failure, return `false`.
          </li>
          <li>
            Let |pattern| be the result of running the
            <a>basic URL parser</a> on |raw pattern|.
          </li>
          <li>
            If |pattern| is failure, return `false`.
          </li>
          <li>
            Let |subdomain pattern| be the result of prepending "`.`"
            to |pattern|'s [= url/host =].
          </li>
          <li>
            If |id|'s [= url/host =] does not end with
            |subdomain pattern| and |id|'s
            [= url/host =] is not equal to |pattern|'s
            [= url/host =], return `false`.
          </li>
          <li>
            If |pattern|'s [= url/path =] is equal to
            "`/*`", return `true`.
          </li>
          <li>
            If |id|'s [= url/path =] begins with
            |pattern|'s [= url/path =],
            return `true`.
          </li>
          <li>
            Otherwise, return `false`.
          </li>
        </ol>
    </section>

    <section> <h3>The <strong>scan()</strong> method</h3>
      <p>
        The section [[[#steps-receiving]]] uses {{NFCReader}} instances to match
        incoming <a>NFC content</a>.
      </p>
      <p>
        When the <dfn>NFCReader.scan</dfn> method is invoked, the UA
        MUST run the following
        <dfn id="steps-listen">NFC listen algorithm</dfn>:
        <ol class=algorithm>
          <li>
            Let |reader:NFCReader| be the {{NFCReader}} instance.
          </li>
          <li>
            Let |options| be first argument.
          </li>
          <li>
            [= list/For each =] |key|  |value| of |options|:
            <ol>
              <li>
                If |key| equals "`signal`" and |value| is not `undefined`, set
                |reader|.<a>[[\Signal]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`id`", set
                |reader|.<a>[[\Id]]</a> to |value|, prepended with "`https://`".
              </li>
              <li>
                Otherwise, if |key| equals "`recordType`", set
                |reader|.<a>[[\RecordType]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`mediaType`", set
                |reader|.<a>[[\MediaType]]</a> to |value|.
              </li>
            </ol>
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection cannot
            be established, then
            <ol>
              <li>
                Let |e| be the result of [= exception/create =] a
                {{"NotSupportedError"}} {{DOMException}}.
              </li>
              <li>
                <a>Fire an event</a> named "`error`" at |reader|
                using <a>NFCErrorEvent</a> with its error attribute
                initialized to |e|.
              </li>
              <li>
                Return.
              </li>
            </ol>
          </li>
          <li>
            If the UA is not allowed to access the underlying <a>NFC Adapter</a>
            (e.g. a user preference), then
            <ol>
              <li>
                Let |e| be the result of [= exception/create =] a
                {{"NotReadableError"}} {{DOMException}}.
              </li>
              <li>
                <a>Fire an event</a> named "`error`" at |reader|
                using <a>NFCErrorEvent</a> with its error attribute
                initialized to |e|.
              </li>
              <li>
                Return.
              </li>
            </ol>
          </li>
          <li>
            If |reader|.<a>[[\Signal]]</a>'s [= AbortSignal/aborted flag =] is set, then return.
          </li>
          <li>
            If |reader|.<a>[[\Signal]]</a> is not `null`, then
            <a data-cite="dom#abortsignal-abort-algorithms">add the following abort steps</a> to |reader|.<a>[[\Signal]]</a>:
            <ol>
              <li>
                Remove the {{NFCReader}} instance from the <a>activated reader objects</a>.
              </li>
              <li>
                If the <a>activated reader objects</a> [= list/is empty =], then make a request
                to stop listening to <a>NDEF message</a>s on all <a>NFC adapter</a>s.
              </li>
            </ol>
          </li>
          <li>
            Run the following steps <a>in parallel</a>:
            <ol>
              <li>
                If the <a>obtain reading permission</a> steps return
                `false`, then
                <ol>
                  <li>
                    Let |e:DOMException| be the result of [= exception/create =] a
                    {{"NotAllowedError"}} {{DOMException}}.
                  </li>
                  <li>
                    <a>Fire an event</a> named "`error`" at |reader|
                    using <a>NFCErrorEvent</a> with its error attribute
                    initialized to |e|.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                If this is the first listener being set up, then make a request to
                all <a>NFC adapter</a>s to listen to <a>NDEF message</a>s.
              </li>
              <li>
                If the request fails, then the UA may run the following sub-steps:
                <ol>
                  <li>
                    Let |e:DOMException| be the result of [= exception/create =] a
                    {{"NotSupportedError"}} {{DOMException}}.
                  </li>
                  <li>
                    <a>Fire an event</a> named "`error`" at |reader|
                    using <a>NFCErrorEvent</a> with its error attribute
                    initialized to |e|.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                If the |reader|.<a>[[\Id]]</a> is not an empty <a>string</a>
                and it is not a <a>valid URL pattern</a>, then
                <ol>
                  <li>
                    Let |e:DOMException| be the result of [= exception/create =] a
                    {{"SyntaxError"}} {{DOMException}}.
                  </li>
                  <li>
                    <a>Fire an event</a> named "`error`" at |reader|
                    using <a>NFCErrorEvent</a> with its error attribute
                    initialized to |e|.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                Add |reader| to the <a>activated reader objects</a>.
              </li>
              <li>
                If the {{Document}} of the <a>top-level browsing context</a> is not
                <a>visible</a> (e.g. the user navigated
                to another page), then the registered <a>activated reader objects</a>
                still SHOULD continue to exist, but SHOULD become paused, i.e. the UA
                SHOULD NOT check and use them until the {{Document}} is
                <a>visible</a> again.
              </li>
            </ol>
          </li>
        </ol>
      </p>
      <p>
        To <dfn>obtain reading permission</dfn>, run these steps:
        <ol>
          <li>
            If there is a <a>prearranged trust relationship</a>,
            return `true`.
          </li>
          <li>
            Otherwise, if the user has earlier denied permission for the calling
            <a>origin</a> for all future calls of
            <a data-link-for="NFCReader">scan()</a>
            as well, then return `false`.
          </li>
          <li>
            Otherwise, UAs SHOULD <a>ask for forgiveness</a> with relevant
            information displayed to the user.
            <p class="note">
              The <a>ask for forgiveness</a> interaction
              might show choices like "block now" or "block forever", etc.
              If the user has chosen to "block forever" the given
              <a>origin</a>, it is the responsibility of the UA to remember
              these user choices for each <a>origin</a>, regardless of which
              <a>NFC adapter</a> is used, and consult them on later invocations.
            </p>
            <p class="note">
             In this step UAs are advised to notify users about
             that reading <a>NFC content</a> may indirectly reveal the physical
             location of the user.
            </p>
          </li>
          <li>
            Return `true`.
          </li>
        </ol>
      </p>
    </section>

  </section>

  <section id="steps-receiving">
  <h3>Receiving and parsing content</h3>
  <p>
    If there are any {{NFCReader}} instances in <a>activated reader objects</a>
    then UAs MUST listen to <a>NDEF message</a>s.
  </p>

  <section><h3>Parsing records from bytes</h3>
    To <dfn>parse records from bytes</dfn> given |bytes:byte sequence|,
    run these steps:
    <ol class=algorithm>
      <li>
        Let |records| be the empty list.
      </li>
      <li>
        As long as there are unread bytes of |bytes|, run the following sub-steps:
        <ol>
          <li>
            If remaining length of |bytes| is less than `3`, abort these sub-steps.
          </li>
          <li>
            If any of the following steps requires reading bytes beyond the
            remaining length of |bytes|, return |records|.
          </li>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a>
          </li>
          <li>
            Let |header:byte| be the next byte of |bytes|.
            <ol>
              <li>
                Let |messageBegin:boolean| (<a>MB field</a>) be the left most bit (bit 7) of |header|.
              </li>
              <li>
                If this is the first iteration of these sub-steps and |messageBegin| is `false`,
                return |records|.
              <li>
                Let |messageEnd:boolean| (<a>ME field</a>) be bit 6 of |header|.
              </li>
              <div class=note>
                As chunked records are not allowed as sub records, we ignore bit 5 (<a>CF field</a>).
              </div>
              <li>
                Let |shortRecord:boolean| (<a>SR field</a>) be bit 4 of |header|.
              </li>
              <li>
                Let |hasIdLength:boolean| (<a>IL field</a>) be bit 3 of |header|.
              </li>
              <li>
                Let |ndef|'s |typeNameField:number| (<a>TNF field</a>) be the integer value of bit 2-0 of |header|.
              </li>
            </ol>
          </li>
          <li>
            Let |typeLength:number| be the integer value of next byte
            (<a>TYPE LENGTH field</a>) of |bytes|.
          </li>
          <li>
            If |shortRecord| is `true`, let |payloadLength:number|
            be the integer value of next byte (<a>PAYLOAD LENGTH field</a>) of |bytes|.
          </li>
          <li>
            Otherwise, let |payloadLength| be the integer value of the next 4 bytes of |bytes|.
          </li>
          <li>
            If |hasIdLength| is `true`, let |idLength:number| be
            the integer value of next byte (<a>ID LENGTH field</a>) of |bytes|,
            otherwise let it be `0`.
          </li>
          <li>
            If |typeLength| > 0, let |ndef|'s |type:string| be result of
            running <a>UTF-8 decode</a> on the next |typeLength| (<a>TYPE field</a>) bytes,
            orelse let |type| be the empty string.
          </li>
          <li>
            If |idLength| > 0, let |ndef|'s |id:string| be result of
            running <a>UTF-8 decode</a> on the next |idLength| (<a>ID field</a>) bytes,
            orelse let |ndef|'s |id| be the empty string.
          </li>
          <li>
            Let |ndef|'s |payload| be the <a>byte sequence</a> of the last |payloadLength|
            (<a>PAYLOAD field</a>) bytes, which may be `0` bytes.
          </li>
          <li>
            Let |record:NDEFRecord| be the result of <a>parse an NDEF record</a> on |ndef|.
          </li>
          <li>
            If |record| is not `null`, <a>append</a> |record| to |records|.
          </li>
          <li>
            If |messageEnd| is `true`, abort these sub-steps.
        </ol>
      </li>
      <li>
        Return |records|.
      </li>
    </ol>
  </section>

  <section><h3>Parsing NDEF records</h3>
  <p>
    To <dfn>parse an NDEF record</dfn> given |ndef| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Set |record|'s id to |ndef|'s |id:string|.
      </li>
      <li>
        If |ndef|'s |typeNameField:number| is `0` (<a>empty record</a>), then set
        |record|'s recordType to "`empty`" and set |record|'s mediaType to `""`.
      </li>
      <li>
        If |ndef|'s |typeNameField| is `1` (<a>well-known type record</a>):
        <ol>
          <li>
            Set |record| to the result of the algorithm below switching on
            |ndef|'s |type:string|:
            <dl>
              <dt>"`T`" (`0x54`)</dt>
              <ul>
                <li>
                  running <a>parse an NDEF text record</a> on |ndef|.
                </li>
              </ul>
              <dt>"`U`" (`0x55`)</dt>
              <ul>
                <li>
                  running <a>parse an NDEF URL record</a> on |ndef|
                </li>
              </ul>
              <dt>"`Sp`" (`0x53` `0x70`)</dt>
              <ul>
                <li>
                  running <a>parse an NDEF smart-poster record</a> on |ndef|
                </li>
              </ul>
            </dl>
          </li>
        </ol>
      </li>
      <li>
        If |ndef|'s |typeNameField| is `2` (<a>MIME type record</a>), then
        set |record| to the result of running <a>parse an NDEF MIME type record</a>
        on |ndef|, or make sure that the underlying platform provides equivalent
        values to the |record| object's properties.
      </li>
      <li>
        Otherwise, if |ndef|'s |typeNameField| is `3` (<a>absolute-URL record</a>), then
        set |record| to the result of running <a>parse an NDEF absolute-URL record</a>
        on |ndef|.
      </li>
      <li>
        Otherwise, if |ndef|'s |typeNameField| is `4` (<a>external type record</a>),
        then set |record| to the result of running <a>parse an NDEF external type record</a>
        on |ndef|, or make sure that the underlying platform provides equivalent values
        to the |record| object's properties.
      <li>
        Otherwise, if |ndef|'s |typeNameField| is `5` (<a>unknown record</a>)
        then set |record| to the result of running <a>parse an NDEF unknown record</a>
        on |ndef|, or make sure that the underlying platform provides equivalent values
        to the |record| object's properties.
      </li>
    </ol>
  </p>
  </section>

  <section><h3>Parsing NDEF well-known `T` records</h3>
  <p>
    To <dfn>parse an NDEF text record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Set |record|'s recordType to "`text`".
      </li>
      <li>
        Let |mimeType| be a <a>MIME type</a>
        with type "`text`", subtype "`plain`" and parameters
        equal to an empty ordered map.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present, set |record|s mediaType to |mimeType|,
        set |record|.<a>[[\PayloadData]]</a> to `undefined` and return |record|.
      </li>
      <li>
        Let |header:byte| be the first <a>byte</a> of |ndefRecord|'s
        <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |languageLength:octet| be the value given by bit `5`
        to bit `0` of the |header|.
      </li>
      <li>
        Let |language:string| be the result of running <a>ASCII decode</a>
        on second <a>byte</a> to the |languageLength| + `1` byte, inclusive.
      <li>
        Set |mimeType|'s parameters["`lang`"] to |language|.
      </li>
      <li>
        Set |record|'s mediaType to the result of
        <a>serialize a MIME type</a> with |mimeType| as
        the input.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|.<a>[[\PayloadData]]</a> to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol> <!-- parsing NDEF text record -->
  </p>
  <p class="note" data-link-for="NDEFRecord">
    Using the <a data-cite="encoding#encoder">encoder</a>, it is only possible
    to encode as UTF-8, unless you do the encoding manually
    and use the "{{opaque}}" {{recordType}}, which
    allows you to write any opaque data.
    <br><br>
    When you write a <a>string</a> to the "{{text}}"
    {{recordType}}, it will be written as UTF-8.
    External applications have the ability to additionally encode
    this field as UTF-16BE, but that is transparent from the use
    of the {{NFCReader}} which will always return the data
    as a <a>string</a>.
    <br><br>
    As external applications may have encoded the "{{opaque}}"
    {{recordType}} using a different
    encoding, which can be decoded using [[[ENCODING]]] if you know
    the encoding.
  </p>
  </section>

  <section><h3>Parsing NDEF well-known `U` records</h3>
  <p>
    To <dfn>parse an NDEF URL record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Set |record|'s recordType to "`url`".
      </li>
      <li>
        Set |record|'s mediaType to "`text/plain`".
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present,
        set |record|.<a>[[\PayloadData]]</a> to `undefined` and return |record|.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |prefixByte:byte| be the value of the first <a>byte</a> of
        |buffer|.
      </li>
      <li>
        If the value of |prefixByte| matches the URL expansion codes in the [[[NFC-STANDARDS]]] URI Record Type Definition specification, Section 3.2.2, Table 3, then
        <ol>
          <li>
            Let |prefixString:string| be the <a>byte sequence</a> value corresponding to the value of |prefixByte|.
          </li>
          <li>
            Set |record|.<a>[[\PayloadData]]</a> to |prefixString| appended to |buffer|.
          </li>
        </ol>
      </li>
      <li>
        Otherwise, if there is no match for |prefixByte|, set |record|.<a>[[\PayloadData]]</a> to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol> <!-- parsing NDEF URL record -->
  </p>
  </section>

  <section><h3>Parsing NDEF well-known `Sp` records</h3>
  <p>
    To <dfn>parse an NDEF smart-poster record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Set |record|'s recordType to "`smart-poster`".
      </li>
      <li>
        Set |record|'s mediaType to "".
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present, set |record|.<a>[[\PayloadData]]</a> to `undefined` and return |record|.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|.<a>[[\PayloadData]]</a> to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol>  <!-- parsing NDEF smart-poster record -->
  </p>
  </section>

  <section><h3>Parsing NDEF MIME type records</h3>
    <p>
      To <dfn>parse an NDEF MIME type record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Let |mimeType| be the <a>MIME type</a>
          returned by running <a>parse a MIME type</a>
          on |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          If |mimeType| is a <a>JSON MIME type</a>, then
          <ol>
            <li>
              Set |record|'s recordType to "`json`".
            </li>
            <li>
              Set |record|'s mediaType to the result of
              <a>serialize a MIME type</a> with |mimeType| as
              the input.
            </li>
          </ol>
        </li>
        <li>
          Otherwise,
          <ol>
            <li>
              Set |record|'s recordType to "`opaque`".
            </li>
            <li>
              Set |record|'s mediaType to the result of
              <a>serialize a MIME type</a> with |mimeType| as
              the input.
            </li>
          </ol>
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise `undefined`.
        </li>
        <li>
          Set |record|.<a>[[\PayloadData]]</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol> <!-- parsing NDEF MIME type record -->
    </p>
  </section>

  <section><h3>Parsing NDEF absolute-URL records</h3>
    <p>
      To <dfn>parse an NDEF absolute-URL record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Set |record|'s recordType to "`url`".
        </li>
        <li>
          Set |record|'s mediaType to "`text/plain`".
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>TYPE field</a>.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF absolute URI record -->
    </p>
  </section>

  <section><h3>Parsing NDEF external type records</h3>
    <p>
      To <dfn>parse an NDEF external type record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Set |record|'s recordType to the value of |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          Set |record|'s mediaType to "`application/octet-stream`".
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise `undefined`.
        </li>
        <li>
          Set |record|.<a>[[\PayloadData]]</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF external type record -->
    </p>
  </section>

  <section><h3>Parsing NDEF unknown type records</h3>
    <p>
      To <dfn>parse an NDEF unknown record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Set |record|'s recordType to "`opaque`".
        </li>
        <li>
          Set |record|'s mediaType to "`application/octet-stream`".
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise `undefined`.
        </li>
        <li>
          Set |record|.<a>[[\PayloadData]]</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF unknown record -->
    </p>
  </section>

  <section><h3>The NFC reading algorithm</h3>
    When the <a>UA</a> is to <dfn>receive NFC content</dfn> it MUST run the
    following algorithm:
    <p class="note">
       The UA SHOULD represent an unformatted <a>NFC tag</a> as an
       <a>NDEF message</a> containing a single empty <a>NDEF record</a>.
    </p>
    <ol class=algorithm id="parse-ndef">
      <li>
        If <a>NFC is suspended</a>, abort these steps.
      </li>
      <li>
        Let |message:NDEFMessage| be a new <a>NDEFMessage</a> object, with
        |message|'s url set to `null` and
        |message|'s records set to the empty <a>list</a>.
      </li>
      <li>
        Let |serialNumber:serialNumber| be the device identifier as a series of
        numbers, or `null` if unavailable.
      </li>
      <li>
        If |serialNumber| is not `null`, set it to the
        <a>string</a> of U+003A (`:`) concatenating each number represented as
        <a>ASCII hex digit</a>, in the same order.
      </li>
      <li>
        Let |input| be the notation for the <a>NDEF message</a>
        which has been received.
      </li>
      <li>
        [= list/For each =] <a>NDEF record</a> which is part of |input|, run the
        following sub-steps:
        <ol>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a> with
            |typeNameField:number| corresponding to the <a>TNF field</a> and
            |payload:byte sequence| corresponding to the <a>PAYLOAD field</a> data.
          </li>
          <li>
            Let |record:NDEFRecord| be the result of <a>parse an NDEF record</a> on |ndef|.
          </li>
          <li>
             If |record| is not `null`, <a>append</a> |record| to |message|'s records.
          </li>
        </ol>
      </li>
      <li>
        If <a href="#nfc-is-suspended">NFC is not suspended</a> and
        |message|'s records [= list/is not empty =], run the
        <a>dispatch NFC content</a> steps with given |serialNumber|
        and |message|.
      </li>
    </ol>
    </section>

    <section data-link-for="NFCReadingEvent"><h3>Dispatching NFC content</h3>
    <p>
      To <dfn>dispatch NFC content</dfn> given a |serialNumber:serialNumber|
      of type <a>serialNumber</a>, |message:NDEFMessage|
      of type <a>NDEFMessage</a>, run these steps:
    </p>
    <ol class=algorithm>
      <li>
        [= list/For each =] {{NFCReader}} instance |reader:NFCReader| in
        the <a>activated reader objects</a>, run the following sub-steps:
        <ol>
          <li>
            If |reader|.<a>[[\Id]]</a> is [= dictionary member/present =]
            and doesn't <a href="#dfn-match-record-identifier-with-url-pattern">match</a>
            any |record:NDEFRecord|'s id where |record|
            is an element of |message|, [= iteration/continue =].
          </li>
          <li>
            If |reader|.<a>[[\RecordType]]</a> is [= dictionary member/present =]
            and it is not equal to any |record|'s recordType where |record|
            is an element of |message|, [= iteration/continue =].
          </li>
          <li>
            If |reader|.<a>[[\MediaType]]</a> is not `""` and
            it is not equal to any |record|'s mediaType where |record| is
            an element of |message|, [= iteration/continue =].
          </li>
          <li>
            <a>Fire an event</a> named "`reading`" at |reader|
            using <a>NFCReadingEvent</a> with its <a>serialNumber</a> attribute
            initialized to |serialNumber| and <a>message</a> attribute
            initialized to |message|.
          </li>
        </ol>
      </li>
    </ol>
    </section>
  </section> <!-- receiving content -->
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>

<!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
<section> <h2>Acknowledgments</h2>
  <p>
    The editors would like to thank Jeffrey Yasskin, Anne van Kesteren,
    Anssi Kostiainen, Domenic Denicola, Daniel Ehrenberg, Jonas Sicking,
    Don Coleman, Salvatore Iovene, Rijubrata Bhaumik, Wanming Lin, and
    Franois Beaufort for their contributions to this document.
  </p>
  <p>
    Special thanks to Luc Yriarte and Samuel Ortiz for their initial
    <a href="https://github.com/w3c/nfc">work</a>
    on exposing NFC to the web platform, and for their support for the current
    approach.
</section>

</body>
</html>
