<!DOCTYPE html>
<html>
<head>
  <title>Web NFC API</title>
  <meta charset="UTF-8">
  <script type=module src="ndef-record.js"></script>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' async class=
  'remove'></script>
  <script class="remove">
    var respecConfig = {
      specStatus: "CG-DRAFT",
      shortName: "web-nfc",
      editors: [
        {
          name: "Kenneth Rohde Christiansen",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
        { name: "Zoltan Kis", company: "Intel", companyURL: "https://intel.com/" },
      ],
      formerEditors: [
        {
          name: "Alexander Shalamov",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
      ],
      wg: "Web NFC Community Group",
      wgURI: "https://www.w3.org/community/web-nfc/",
      github: "w3c/web-nfc",
      xref: "web-platform",
      localBiblio: {
        "NFC-SECURITY": {
          href: "https://github.com/w3c/web-nfc/security-privacy.html",
          title: "Web NFC Security and Privacy",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-USECASES": {
          href: "https://github.com/w3c/web-nfc/use-cases.html",
          title: "Web NFC Use Cases",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-STANDARDS": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Technical Specifications",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-RTD": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Record Type Definition (RTD) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "ISO-639.2": {
          href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
          title: "Codes for the Representation of Names of Languages",
          publisher: "ISO",
          date: "18 March 2014",
        },
      },
    };
  </script>
  <style>
    table.simple { border: 1px solid #000; }
    table.simple td { border-right: 1px solid #000; }
  </style>
</head>

<body data-cite="MIMESNIFF SECURE-CONTEXTS PERMISSIONS ENCODING PAGE-VISIBILITY">

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz.

    The hardware standard is deined in [[[NFC-STANDARDS]]].
  </p>
  <p>
    This document defines an API to enable selected use-cases based on
    NFC technology.
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered
    unstable.
    Implementers who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This document defines conformance criteria that apply to a single
    product: the <dfn>UA</dfn> (user agent) that implements the interfaces it
    contains.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology and conventions</h2>
  <p>
    The Augmented Backus-Naur Form (ABNF) notation used is specified in
    [[RFC5234]].
  </p>

  <section> <h3>Security related terms</h3>
  <p>
    The term <dfn>expressed permission</dfn> refers to an act by the user, e.g.
    via user interface or setting or host device platform features, using which
    the user approves the permission of a <a>browsing context</a> to access the
    given functionality.
  </p>
  <p>
    The term <dfn data-lt="asked for forgiveness">ask for forgiveness</dfn> refers to some
    form of unobtrusive notification that informs the user of an operation
    while it is running.
    UAs SHOULD provide the user with means to ignore similar future
    operations from the same <a>origin</a> and advertise this to the user.
  </p>
  <p>
    The term <dfn>prearranged trust relationship</dfn> means that the
    UA has already established a trust relationship for a
    certain operation using a platform specific mechanism, so that an
    <a>expressed permission</a> from the user is not any more needed.
    See also this
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#prearranged-trust-relationship">
    section</a> in the Security and Privacy document.
  </p>
  <p>
    The term <dfn>obtain permission</dfn> for a certain operation indicates
    that the UA has either obtained <a>expressed permission</a>, or
    <a>asked for forgiveness</a>, or ensured a
    <a>prearranged trust relationship</a> exists.
  </p>
  <p>
    The
    <a href="https://www.w3.org/TR/permissions/#dictdef-permissiondescriptor">
    <dfn>Web NFC permission name</dfn></a> is
    <a href="https://github.com/w3c/permissions/issues/47">defined</a> as
    "`nfc`".
  </p>
  </section>
  <section> <h3>NFC specific terms</h3>
  <p>
    <b>NFC</b> stands for Near Field Communications, short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See <a href="https://www.nfc-forum.org/specs/spec_list/">
    NFC Forum Technical Specifications</a> for a complete
    listing.
  </p>
  <p>
    An <dfn>NFC adapter</dfn> is the software entity in the underlying
    platform which provides access to NFC functionality implemented in a
    given hardware element (NFC chip). A device may have multiple NFC
    adapters, for instance a built-in one, and one or more attached via USB.
  </p>
  <p>
    An <dfn>NFC tag</dfn> is a passive NFC device.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. An <a>NFC tag</a> contains a single
    <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. Implementations are expected to encapsulate this.
    </p>
  </p>
  <p>
    An <dfn>NFC peer</dfn> is an active, powered device, which can interact
    with other devices in order to exchange data using NFC.
  </p>
  <p>
    An <dfn>NFC device</dfn> is either an <a>NFC peer</a>, or an <a>NFC tag</a>.
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. <dfn>NDEF</dfn> is an abbreviation for NFC Forum
    Data Exchange Format, a lightweight binary message format. NDEF messages
    can be stored on an <a>NFC tag</a> or exchanged between NFC-enabled devices.
  </p>
  <p>
    The term <dfn>NFC content</dfn> is a synonym for <a>NDEF message</a>,
    which can originate either from an <a>NFC tag</a> or an <a>NFC peer</a>.
  </p>
</section>
<section>
<h3>
  The NDEF record and fields
</h3>
  <p>
    An <dfn>NDEF record</dfn> is a part of an <a>NDEF message</a>. Each record
    is a binary structure that contains a data payload, as well as associated
    type information. In addition to this, it includes information about how
    the data is structured, like payload size, whether the data is chunked over
    multiple records etc.
  </p>
  <p>
    A <dfn>Web NFC message</dfn> consists of a sequence of <a>NDEF record</a>s.
  </p>
  <p>
    A generic record looks like the following:
    <ndef-record class="ndef"
      header="*,*,*,*,*,*"
      content="*,PAYLOAD LENGTH - 1 (SR) to 4 bytes,ID LENGTH (optional),TYPE (optional),ID (optional),PAYLOAD (optional)">
    </ndef-record>
  </p>
  <p>
    Only the first three bytes (lines in figure) are mandatory. First the
    header byte, followed by the <a>TYPE LENGTH field</a> and <a>PAYLOAD
    LENGTH field</a>, which may both be zero.
  </p>
  <p>
    The <dfn>MB field</dfn> (bit `7`, message begin) indicates whether this is
    the beginning of a message, the <dfn>ME field</dfn> (bit `6`, message end)
    indicates whether it is the end. The <dfn>CF field</dfn> (bit `5`,
    chunk flag) indicates whether the payload is chunked across multiple records.
  </p>
  <p class="note">
    Web NFC turns all chunked records into logical records.
  </p>
  <p>
    The <dfn>SR field</dfn> (bit `4`, short record) indicates whether the record is a
    short record. A short
    record is one with a payload length <= `255` bytes. Normal records can have payload
    lengths exceeding `255` bytes up to a maximum of `4` GB. Short records only use one
    byte to indicate length, whether as normal records use `4` bytes (`2`<sup>`32`</sup>`-1` bytes).
  </p>
  <p>
    The <dfn>IL field</dfn> (bit `3`, id length) indicates whether an <a>ID LENGTH field</a> is
    available. This optional identifier is a URL.
  </p>
  <p>
    The <dfn>TNF field</dfn> (bit `0-2`, type name format) indicates the format of the
    type name and is often exposed by native NFC software stacks. The field can take
    binary values denoting the following NDEF record payload types:
    <table class="simple">
      <tr>
        <th><strong>TNF value</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td><a>Empty record</a></td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum <a>well-known type record</a></td>
      </tr>
      <tr>
        <td>2</td>
        <td><a>MIME type record</a></td>
      </tr>
      <tr>
        <td>3</td>
        <td><a>Absolute-URL record</a></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <a>external type record</a></td>
      </tr>
      <tr>
        <td>5</td>
        <td><a>Unknown record</a></td>
      </tr>
      <tr>
        <td>6</td>
        <td><a>Unchanged record</a></td>
      </tr>
      <tr>
        <td>7</td>
        <td>Reserved for future use</td>
      </tr>
    </table>
  </p>
  <p>
    Other fields include <dfn>TYPE LENGTH field</dfn>, <dfn>TYPE field</dfn>,
    <dfn>ID LENGTH field</dfn>, <dfn>ID field</dfn>, <dfn>PAYLOAD LENGTH field</dfn>
    and the <dfn>PAYLOAD field</dfn>.
  </p>
  <p class="note">
    The [[[NFC-RTD]]] requires that the <a>TYPE field</a> names MUST be compared in case-insensitive manner.
  </p>
  </section>
  <section>
  <h3>
    Record types
  </h3>
    <section>
    <h4>
      Empty NDEF records (TNF 0)
    </h4>
    The <dfn>empty record</dfn>s, which have no payload or type
    and are used to indicate empty tags.

    <ndef-record
      header="1,1,0,1,0,0 (EMPTY)"
      content="0,0,_,_,_,_"
      short>
    </ndef-record>
    </section>
    <section>
    <h4>
       Well-known records (TNF 1)
    </h4>
    <p>
      The NFC Forum has standardized a small set of useful RTD (Record Type
      Definition) types for use in the NFC Forum <dfn  data-no-export="">well-known type record</dfn>s,
      for instance text, URL, and binary data such as media. In addition, there
      are record types designed for more complex interactions, such as smart
      poster (containing optional embedded records for url, text, signature and
      actions), and handover records. Most of these are defined in [[[NFC-RTD]]].
    </p>
    <p>
      For well-known records, the RTD type is stored in the <a>TYPE field</a> and is "`T`"
      (`0x54`) for text, "`U`" (`0x55`) for url and "`Sp`" (`0x53`, `0x70`) for smart poster.
    </p>
    <p>
      Other known RTD types supported by the platform and not Web NFC are
      "`ac`" (`0x61`, `0x63`) for alternative carrier, "`Hc`" (`0x48`, `0x63`) for
      handover carrier, "`Hr`" (`0x48`, `0x72`) for handover request, and "`Hs`"
      (`0x48`, `0x73`) for handover select.
    </p>
    <p>
      An <dfn>NFC handover</dfn> defines RTD and the
      corresponding message structure that allows negotiation and activation of
      an alternative communication carrier, such as Bluetooth or WiFi.
      The negotiated communication carrier would then be used (separately) to
      perform certain activities between the two devices, such as sending photos
      to the other device, printing to a Bluetooth printer or streaming video to
      a television set.
    </p>
    <p>
      Smart poster embeds additional records inside its payload. Below you
      see an example embedding a text and a url record.
      <ndef-record
        header="1,1,0,1,0,1 (WELL KNOWN)"
        content="*,*,_,'Sp' (0x53 0x70),_,*"
        short>
        <ndef-record slot="payload"
          header="1,0,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'T' (0x54),_,*"
          short noindices>
        </ndef-record>
        <ndef-record slot="payload"
          header="0,1,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'U' (0x55),_,*"
          short noindices>
        </ndef-record>
      </ndef-record>
    </p>
    </section>
    <section>
    <h4>
      MIME type records (TNF 2)
    </h4>
    <p>
      The <dfn>MIME type record</dfn>s are records that store `opaque`
      data with associated <a>MIME type</a>.
      <ndef-record
        header="*,*,*,*,*,2 (MIME)"
        content="*,*,*,SERIALIZED MIME TYPE,*,MIME TYPE PAYLOAD"
        short>
      </ndef-record>
    </p>
    <p class=note>
      Web NFC has special handling for working with JSON MIME type data.
    </p>
    </section>
    <section>
    <h4>
      Absolute-URL records (TNF 3)
    </h4>
    <p>
      In <dfn>absolute-URL record</dfn>s the <a>TYPE field</a> contains the
      <a>absolute-URL string</a>, and not the payload.
    </p>
    <p class=note>
      NOTE: Some platforms, like Windows Phone have stored additional data
      in the payload, but any payload data in these records are ignored by
      other platforms such as Android. On Android, reading such a record,
      will attempt to load the URL in Chrome and it is as such not intended
      for client applications.
    </p>
    <p>
      <ndef-record
        header="*,*,*,*,*,3 (ABSOLUTE URL)"
        content="*,*,*,ABSOLUTE URL STRING,*,PAYLOAD (optional/ignored)"
        short>
      </ndef-record>
    </p>
    </section>
    <section>
    <h4>
      External type records (TNF 4)
    </h4>
    <p>
      The NFC Forum <dfn data-no-export="">external type record</dfn>s are for client specified
      data and must have a type name following the [[[NFC-RTD]]] standard.
    </p>
    <p class=note>
      Web NFC defines a special <a>external type record</a> that is not accessible
      to client applications.
    </p>
    <p>
      <ndef-record
        header="*,*,*,*,*,4 (EXTERNAL)"
        content="*,*,*,EXTERNAL TYPE (eg. w3.org:A),*,*"
        short>
      </ndef-record>
    </p>
    </section>
    <section>
    <h4>
      Web NFC author records (TNF 4)
    </h4>
    <p>
      When writing data with Web NFC, a special <dfn>author type record</dfn> is written
      in addition to the other records. This record is specificed by this specification
      and is specific to Web NFC. The record indicates that the containing
      <a>NDEF message</a> is targeted for <a>browsing context</a>s using this API
      and contains information useful for handling the <a>NDEF message</a> with
      the algorithms defined in this specification.
      The format is as follows:
      <ul>
        <li>
          A short, non-chunked record with <a>IL field</a> set to `0` and
          thus no <a>ID LENGTH field</a> and <a>ID field</a>.
        </li>
        <li>
          Uses NFC Forum <a>external type record</a> with the
          <a>TYPE field</a> set to "`w3.org:A`".
        </li>
        <li>
          The payload contains the <a>message author</a> of the
          <a>Web NFC message</a>.
        </li>
      </ul>
      <ndef-record
        header="*,*,0,1,0,4 (EXTERNAL)"
        content="8,*,_,w3.org:A,_,*"
        short>
      </ndef-record>
    </p>
    <p>
      The <dfn>message author host</dfn> is a <a data-cite="url#concept-host-serializer">
      serialized host</a>.
    </p>
    <p>
      The <dfn>message author</dfn> is a <a>message author host</a>, optionally followed
      by a <a>path-absolute-URL string</a>.
      This enables matching <a>Web NFC content</a> with <a>URL pattern</a>s
      specified by {{NFCReader}}s. For <a>NDEF message</a>s that are not <a>Web NFC
      message</a>s, the <a>message author</a> is `null`.
    </p>
    <p>
      The term <dfn>Web NFC content</dfn> denotes all <a>Web NFC message</a>s
      contained within an <a>NDEF message</a>, identified by the <a>message author</a>.
      This version of the specification supports one <a>author type record</a> per
      <a>NDEF message</a>.
    </p>
    <p class="note">
      As part of the <a>NDEF record</a>, an <a>ID field</a> may be
      present in each record for application specific usages. According to the
      [[[NFC-STANDARDS]]] it contains a URL with the maximum length of 256 bytes.
      This URL is used for identifying the <a>NDEF record</a> payload in an
      application specific way.
    </p>
    </section>
    <section>
    <h4>
      Unknown type records (TNF 5)
    </h4>
    <p>
      The <dfn>unknown record</dfn>s are records that store
      `opaque` data without associated <a>MIME type</a>.
    </p>
    <p>
      <ndef-record
        header="*,*,*,*,*,5 (UNKNOWN)"
        content="0,*,*,_,*,*"
        short>
      </ndef-record>
    </p>
  </section>
  <section>
    <h4>
      Unchanged type records (TNF 6)
    </h4>
    <p>
      The <dfn>unchanged record</dfn>s are record chunks of
      a chunked data set, and is used for any, but the first record.
    </p>
    <p>
      First record:
      <ndef-record
        header="1,0,1,1,0,*"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Intermediate record:
      <ndef-record
        header="0,0,1,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Last record:
      <ndef-record
        header="0,1,0,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
    </p>
    <p>
      Any implementation of Web NFC MUST transparently expose chunked records
      as single logical records.
    </p>
    </section>
  </section>
</section> <!-- Terminology -->

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <p>
    In general, there are following groups of user scenarios for NFC:
    <ul>
      <li>
        Hold a device in close proximity to a passively powered tag, such as
        a plastic card or sticker, in order to read and/or write data.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to push a <a>Web NFC message</a> from one device to the other.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to initiate a connection using another wireless carrier such
        as Bluetooth or WiFi.
      </li>
      <li>Card emulation
       <ol>
        <li>
          With a secure element: for payments by holding your phone close to a
          point-of-sales terminal, instead of swiping a payment card.
        </li>
        <li>With host card emulation: for allowing use-cases like using a phone
          acting as a hotel room keycard.
        </li>
       </ol>
      </li>
    </ul>
  </p>
  <p>
    NFC works using magnetic induction, meaning that the reader will emit a
    small electric charge which then creates a magnetic field. This field powers
    the passive device which turns it into electrical impulses to communicate
    data. Thus, when the devices are within range, a read is always performed
    (see NFC Analog Specification and NFC Digital Protocol, NFC Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, then later to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As NFC is based on existing RFID standards, many NFC chipsets support
    reading RFID tags, but many of these are only supported by single
    vendors and not part of the NFC standards. Though certain devices support
    reading and writing to these, it is not a goal of this document to
    support proprietary tags or support interoperability with legacy systems.
  </p>
  <p>
    The NFC Forum has mandated the support of five different tag types to be
    operable with NFC devices. The same is required on operating systems such as
    Android.
    <ol>
      <li>
        <b>NFC Forum Type 1</b>: This tag is based on the ISO/IEC 14443-3A
        (also known as NFC-A, as defined in ISO/IEC 14443-3:2011, Part 3:
        Initialization and anticollision). The tags are rewritable and can be
        configured to become read-only. Memory size can be between `96` bytes and
        `2` Kbytes. Communication speed is `106` kbit/sec.
      </li>
      <li><b>NFC Forum Type 2</b>: This tag is also based on the
        ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
        to become read-only. Memory size can be between `48` bytes and `2` Kbytes.
        Communication speed is `106` kbit/sec. In contrast to Type 1, Type 2 has
        anti-collision protection for dealing with multiple tags within the NFC
        field.
      </li>
      <li><b>NFC Forum Type 3</b>: This tag is based on the Japanese Industrial
        Standard (JIS) X 6319-4, commonly known as FeliCa. The tags are
        preconfigured to be either rewritable or read-only. Memory availability
        is variable, theoretical memory limit is `1` MByte per service.
        Communication speed is `106` kbit/sec. Like Type 2, it supports
        anti-collision protection.
      </li>
      <li><b>NFC Forum Type 4</b> (November 2010): This tag is based on the
        ISO/IEC 14443 like Type 1 and 2, but it supports either NFC-A or NFC-B
        for communication. On top of that the tag may support the Data Exchange
        Protocol (aka ISO-DEP) defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
        Part 4: Transmission protocol). Like Type 3, the tags are preconfigured
        to be either rewritable or read-only. Variable memory, up to `32` KB per
        service. Supports three different communication speeds `106` or `212` or
        `424` Kbits/s.
      </li>
      <li><b>NFC Forum Type 5</b>: This tag is based on the NFC-V RF
        technology which is based on ISO/IEC 15693 and allows reading and
        writing an NDEF message on a ISO/IEC 15693 RF tag that is accessible by
        long range RFID readers as well. The NFC communication is limited to
        short distance and may use the Active Communication Mode of
        ISO/IEC 18092 where the sending peer generates the field which balances
        power consumption and improves link stability.
      </li>
    </ol>
  </p>
  <p>
    In addition to data types standardized for <a>NDEF record</a>s by the NFC
    Forum, many commercial products such as bus cards, door openers etc use
    different card specific data and protocol extensions which require specific
    NFC chips (same vendor of card and reader) in order to function.
  </p>
  <p>
    Card emulation mode capabilities also depend on the NFC chip in the device.
    For payments, a Secure Element is often needed.
  </p>
  <p class="note">
    This document does not aim supporting all possible use cases of NFC
    technology, but only a few use cases which are considered relevant to be
    used by web pages in browsers, using the browser security model.
  </p>
  </section> <!-- Introduction -->

  <!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
  <section class="informative"> <h2>Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>

  <aside title="Push a text string to either a tag or peer"
       class="example">
    <p>
      Pushing a text string to any kind of device is straightforward.
      Options can be left out, as they default to pushing to both tags
      and peers.
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
writer.push(
  "Hello World"
).then(() => {
  console.log("Message pushed.");
}).catch(error => {
  console.log(`Push failed :-( try again: ${error}.`);
});
    </pre>
  </aside>

  <aside title="Push a text string to a peer device" class="example">
    <p>
      It is possible to restrict to which devices (tags or peers) data
      should be pushed. Below we specify to only push to peers,
      and thus, no data is pushed when the user taps a tag.
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
writer.push(
  "Text meant for peers only", { target: "peer" }
).then(() => {
  console.log("Message pushed.");
}).catch(_ => {
  console.log("Push failed :-( try again.");
});
    </pre>
  </aside>

  <aside title="Push a URL to either a tag or peer" class="example">
    <p>
      In order to push an NDEF record of URL type, simply use NDEFMessage.
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
writer.push({
  records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
}).then(() => {
  console.log("Message pushed.");
}).catch(_ => {
  console.log("Push failed :-( try again.");
});
    </pre>
  </aside>

  <aside title="Read data from tag, and write to empty ones" class="example">
    <p>
      Below we read various different kinds of data which can be stored on a tag.
      In the case the tag is empty, we write a text message with the value
      "Hello World".
    </p>
    <pre class="highlight">
const writer = new NFCWriter();
const reader = new NFCReader();

reader.onreading = event => {
  const message = event.message;
  if (message.records[0].recordType == 'empty') {
    writer.push({
      url: "/custom/path",
      records: [{ recordType: "text", data: 'Hello World' }]
    });
    return;
  }

  console.log(`Read message written by ${message.url}`);

  for (let record of message.records) {
    switch (record.recordType) {
      case "text":
        console.log(`Text: ${record.toText()}`);
        break;
      case "url":
        console.log(`URL: ${record.toText()}`);
        break;
      case "json":
        console.log(`JSON: ${record.toJSON().myProperty}`);
        break;
      case "opaque":
        if (record.mediaType.startsWith('image/')) {
          const blob = new Blob([record.toArrayBuffer()], {type: record.mediaType});

          const img = document.createElement("img");
          img.src = URL.createObjectURL(blob);
          img.onload = () => window.URL.revokeObjectURL(this.src);

          document.body.appendChild(img);
        }
        break;
    }
  }
};

reader.scan();
    </pre>
  </aside>

  <aside title="Save and restore game progress with another device"
       class="example">
    <p>
      Filtering of relevant data sources can be done by the use of
      the <a>NFCScanOptions</a>. Below we accept URL with
      "`/mypath/mygame/`" in its path from "`mygame.com`"
      domain and its subdomains. When we read the data, we immediately update
      the game progress by issueing a push with a custom NDEF data layout.
    </p>
    <p>
      The example allows reading and pushing to both peers and tags,
      whichever one is tapped first.
    </p>
    <pre class="highlight">
const reader = new NFCReader();
reader.scan({ url: "https://mygame.com/mypath/mygame" });
reader.onreading = async event => {
  console.log(`Source:     ${ event.message.url }`);
  console.log(`Game state: ${ JSON.stringify(event.message.records) }`);

  const newMessage = {
    url: "/mypath/mygame/update",
    records: [{
      recordType: "json",
      mediaType: "application/json",
      data: { level: 3, points: 4500, lives: 3 }
    }]
  };
  const writer = new NFCWriter();
  await writer.push(newMessage);
  console.log("Pushed message");
};
    </pre>
  </aside>

  <aside title="Push and read JSON (serialized and deserialized)"
       class="example">
    <p>
      Storing and receiving JSON data is easy with serialization and deserialization.
    </p>
    <pre class="highlight">
const reader = new NFCReader();

reader.addEventListener("reading", event => {
  for (let record of event.message.records) {
    const json = record.toJSON();
    const article =/[aeio]/.test(json.title) ? "an" : "a";
    console.log(`${json.name} is ${article} ${json.title}`);
  }
});

reader.scan({ url: document.baseURI, recordType: "json" });

const writer = new NFCWriter();
writer.push({
  records: [
    {
      recordType: "json",
      mediaType: "application/json",
      data: {
        name: "Benny Jensen",
        title: "Banker"
      }
    },
    {
      recordType: "json",
      mediaType: "application/json",
      data: {
        name: "Zoey Braun",
        title: "Engineer"
      }
    }]
});
    </pre>
  </aside>

  <aside title="Write data to tag and print out existing data" class="example">
    <p>
      Pushing data to a tag requires tapping it. If existing data should be
      read during the same tap, we need to set the ignoreRead
      property to `false` for the <a>NFCWriter</a>.
    </p>
    <pre class="highlight">
const reader = new NFCReader();
reader.onreading = event => {
  for (let record of event.message.records) {
    console.log("Record type:  " + record.recordType);
    console.log("MIME type:    " + record.mediaType);
    console.log("=== data ===\n" + record.toText());
  }
};
reader.scan();

const writer = new NFCWriter();
writer.push("Pushing data is fun!", {target: "tag", ignoreRead: false});
    </pre>
  </aside>

  <aside title="Stop listening to NDEF messages" class="example">
    <p>
      Read NDEF messages for 3 seconds by using <a
      href="#dom-nfcscanoptions-signal">signal</a> in the <a>NFCScanOptions</a>.
    </p>
    <pre class="highlight">
const reader = new NFCReader();
reader.onreading = event => {
  console.log("NDEF message read.");
};

const controller = new AbortController();
controller.signal.onabort = event => {
  console.log("We're done waiting for NDEF messages.");
};

reader.scan({ signal: controller.signal });

// Stop listening to NDEF messages after 3s.
setTimeout(() => controller.abort(), 3000);
    </pre>
  </aside>
  </section> <!-- Usage examples -->

  <section class="informative"> <h3>Use Cases</h3>
    <p>
      A few Web NFC user scenarios are described in the
      <a href="https://w3c.github.io/web-nfc/use-cases.html">Use Cases</a>
      document. These user scenarios can be grouped by criteria based on
      security, privacy and feature categories, resulting in generic flows as
      follows.
    </p>
    <section> <h3>Reading an <a>NFC tag</a></h3>
      <ol>
        <li>
          Reading an <a>NFC tag</a> containing a <a>Web NFC message</a>, when the
          {{Document}} of the <a>top-level browsing context</a> using the Web NFC API
          is <a>visible and focused</a>. For instance, a web page instructs the user
          to tap an NFC tag, and then receives information from the tag.
        </li>
        <li>
          Reading an <a>NFC tag</a> containing other than <a>Web NFC message</a>,
          when the {{Document}} of the <a>top-level browsing context</a> using the
          Web NFC API is <a>visible and focused</a>.
        </li>
        <li>
          Reading an <a>NFC tag</a> when no {{Document}} using the Web NFC API is
          <a data-lt="visible and focused">visible or focused</a>.
          <p class="note">
            This use case is not supported in this version of the specification,
            and it has low priority for future versions as well.
          </p>
        </li>
      </ol>
    </section>
    <section> <h3>Writing to an <a>NFC tag</a></h3>
      <p>
        The user opens a web page which can write an <a>NFC tag</a>. The write
        operations may be one of the following:
        <ol>
          <li>
            Writing to an empty <a>NFC tag</a>.
          </li>
          <li>
            Writing to an <a>NFC tag</a> which already contains a
            <a>Web NFC message</a> with a different <a>message author</a>
            (i.e. overwriting a web-specific tag).
          </li>
          <li>
            Writing to an <a>NFC tag</a> which already contains a
            <a>Web NFC message</a> with the same <a>message author</a>
            (i.e. updating own tag).
          </li>
          <li>
            Writing to other, writable <a>NFC tag</a>s (i.e. overwriting a
            generic tag).
          </li>
        </ol>
      </p>
      <p class="note">
        Note that an NFC write operation to an <a>NFC tag</a> always involves
        also a read operation.
      </p>
    </section>
    <section> <h3>Pushing data to an <a>NFC peer</a> device</h3>
      <p>
        In general, pushing data to another Web NFC capable device requires that
        on the initiating device the user would first have to navigate to a web
        site. The user would then touch the device against another Web NFC
        equipped device, and data transfer would occur.
      </p>
      <p>
        On the receiving device the UA will dispatch the content to an application
        registered and eligible to handle the content, and if that application is
        a browser which has a {{Document}} of the <a>top-level browsing context</a>
        <a>visible and focused</a> with active {{NFCReader}},
        then the content is delivered to the page through the <a>NFCReadingEvent</a>.
      </p>
    </section>
    <section> <h3>Handover to another wireless connection type</h3>
      <p>
        NFC supports handover protocols to Bluetooth or WiFi connectivity for
        the purpose of larger volume data transfer. The user touches another
        NFC capable device, and as a result configuration data is sent for a
        new Bluetooth or WiFi connection, which is then established between the
        devices.
      </p>
      <p class="note">
        This use case is not supported in this version of the specification.
      </p>
    </section>
    <section> <h3>Payment scenarios</h3>
      <p>
        Payment scenarios with Web NFC generally do not refer to supporting
        the payment process itself, but associating the payment status with
        a web page in order to have secondary actions. For instance,
        the user buys goods in a store, and payments options include contactless
        payment using NFC technology.
        In general, touching the device to the point of sales terminal receiver
        area will result in a transaction between the secure element from the
        device and the point of sales terminal. With the Web NFC API, if the
        user navigates to a web site before paying, there may be interaction
        with that site regarding the payment, e.g. the user could get points and
        discounts, or get delivered application or service specific data (e.g.
        tickets, keys, etc) to the device.
      </p>
      <p class="note">
        This use case is not supported in this version of the specification.
      </p>
    </section>
    <section> <h3>Support for multiple NFC adapters</h3>
      <p>
        Users may attach one or more external <a>NFC adapter</a>s to their
        devices, in addition to a built-in adapter. Users may use either
        <a>NFC adapter</a>.
      </p>
    </section>
  </section> <!-- Use Cases -->

  <section class="informative"> <h3>Features</h3>
    <p>High level features for the Web NFC specification include the following:
      <ol>
        <li>
          Support devices with single or multiple <a>NFC adapter</a>s.
          If there are multiple adapters present when invoking an NFC function
          then the UA operates all <a>NFC adapter</a>s in parallel.
        </li>
        <li>
          Support communication with active (powered devices such as readers,
          phones) and passive (smart cards, tags, etc) devices.
        </li>
        <li>
          Allow users to act on (e.g. read, write or transceive) discovered
          NFC devices (passive and active), as well as access the payload
          which were read in the process as <a>Web NFC message</a>s.
        </li>
        <li>
          Allow users to write a payload via <a>NDEF record</a>s to compatible
          devices, such as writeable tags, when they come in range, as
          <a>Web NFC message</a>s.
        </li>
        <li>
          [future] Allow manual connection for various technologies such as
          NFC-A and NFC-F depending on the secondary device.
        </li>
        <li>
          [future] Allow <a>NFC handover</a> to Bluetooth or WiFi.
        </li>
        <li>
          [future] Allow card emulation with secure element or host card
          emulation.
        </li>
      </ol>
    </p>
    <p>
      This specification makes a few simplifications in what use cases
      and data types the Web NFC API can handle:
      <ul>
        <li>
          Expose data types already known to web browsers as
          <a>MIME type</a>s.
        </li>
        <li>Use the web security model.</li>
        <li>
          Implementations encapsulate <a>NDEF record</a> handling and the API
          exposes only data and control events.
        </li>
      </ul>
    </p>
  </section> <!-- Features -->
</section> <!-- Introduction -->

<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2 id="security">Security and Privacy</h2>
  <p>
    The trust model, attacker model, threat model and possible mitigation
    proposals for the Web NFC API are presented in the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html">
    Security and Privacy</a> document. This section presents the chosen
    security and privacy model through normative requirements to
    implementations.
  </p>

  <section> <h3>Chain of trust</h3>
  <p>
    Web pages using the Web NFC API are not trusted.
    This means that the user needs to be aware of exactly what a web page is
    intending to do with NFC at any given moment. Implementations need to
    make sure that when the user authorizes a method of this API, then only that
    action is run, without side effects, and exactly in the context and the
    number of times the user allows the execution of NFC related operations,
    according to the algorithmic steps detailed in this specification.
  </p>
  <p>
    The integrity of <a>NFC content</a> SHOULD NOT be trusted when
    used for implementing security policies, for instance the authenticity of
    <a>message author</a>, unless a <a>prearranged trust relationship</a> exists.
  </p>
  </section>

  <section> <h3>Threats</h3>
  <p>
    The main threats are summarized in the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#threats-and-possible-solutions">
    Security and Privacy</a> document.
  </p>
  <p>
    In this specification the following threats are handled with the highest
    priority:
    <ul>
      <li>
        User data privacy: involuntary sharing of user data (such as location,
        contacts, personal data, etc) from an NFC-capable device such as a
        phone, tablet, or PC.
      </li>
      <li>
        Protecting existing <a>NFC tag</a>s from being overwritten by malicious
        web pages.
      </li>
    </ul>
  </p>
  </section>

  <section> <h3>Permissions and user prompts</h3>
  <p>
    This specification attempts to minimize user prompting and uses implicit
    security policies to address the
    <a href="http://w3c.github.io/web-nfc/security-privacy.html#threats-and-possible-solutions">
    threats</a>.
    However, this specification does not describe, nor does it
    mandate specific user prompting policies. The term <a>obtain permission</a>
    is used for acquiring trust for a given operation.
  </p>
  <p class="note">
    The [[[PERMISSIONS]]] API is suggested to be used by
    UAs for implementing NFC related [[[PERMISSIONS]]] in order to minimize
    the need for user prompting.
  </p>
  <p>
    All <a>expressed permission</a>s that are preserved beyond the current
    browsing session MUST be revocable.
  </p>
  </section>

  <section class="informative"> <h3>Security policies</h3>
    <p>
      This section summarizes the security policies which are specified as
      normative requirements in the respective algorithms of this
      specification.
    </p>
    <section> <h4>Secure Context</h4>
      <p>
        Only <a>secure contexts</a> are allowed to access <a>NFC content</a>.
        Browsers may ignore this rule for development purposes only.
      </p>
    </section>
    <section> <h4>Visible and focused document</h4>
      <p>
        Web NFC functionality is allowed only for the {{Document}} of the
        <a>top-level browsing context</a>, which must be <a>visible and focused</a>.
      </p>
      <p>
        To determine if a given |document:Document| is <dfn>visible and focused</dfn>
        the user agent MUST run the following steps:
      </p>
      <ol class=algorithm>
        <li>
          If the <a href="html#currently-focused-area-of-a-top-level-browsing-context">
          currently focused area</a> does not belong to |document|, return false.
        </li>
        <li>
          If |document|'s <a href="page-visibility#dom-visibilitystate">visibilityState</a>
          is "hidden", return false.
        </li>
        <li>
          Return true.
        </li>
      </ol>
      <p>
        This also means that UAs should block access to the NFC radio if
        the display is off or the device is locked.
        For backgrounded web pages, receiving and pushing <a>NFC content</a>
        must be <a id="#nfc-suspended">suspended</a>.
      </p>
    </section>
    <section> <h4>Permissions controls</h4>
      <p>
        Making an <a>NFC tag</a> read-only must <a>obtain permission</a>, or
        otherwise fail.
      </p>
      <p>
        Setting up listeners for reading <a>NFC content</a> should
        <a>obtain permission</a>.
      </p>
      <p>
        The process of reading an <a>NDEF message</a> does not need to
        <a>obtain permission</a>.
      </p>
      <p>
        Pushing <a>NFC content</a> to an <a>NFC peer</a> does not need to
        <a>obtain permission</a>, but the other rules in this section apply.
        See the [[[#writing-or-pushing-content]]] section.
      </p>
      <p>
        Pushing <a>Web NFC content</a> to an <a>NFC tag</a> does not need to
        <a>obtain permission</a>, if the <a>message author host</a> of the
        <a>author type record</a> on that <a>NFC tag</a> is equal to the
        <a data-cite="dom#concept-host-serializer">serialized host</a>
        of the <a>current settings object</a>'s origin.
        Otherwise the UA must <a>obtain permission</a> for pushing
        <a>NFC content</a> which overwrites existing information.
        See also the [[[#writing-or-pushing-content]]] section.
      </p>
      <p>
        Since all local content that a web page has access to can be shared with
        NFC, the user needs to be clearly aware about the permissions granted
        to the web page using the Web NFC API.
      </p>
    </section>
    <section> <h4>Record URL host and path when pushing</h4>
      <p>
        When pushing <a>Web NFC content</a>, the
        <a data-cite="dom#concept-host-serializer">serialized host</a>
        and the URL [= url/path =] of the <a>current settings object</a> when
        requesting the operation must be recorded in each sent <a>NDEF
        message</a>'s <a>author type record</a>. For details see the
        [[[#writing-or-pushing-content]]] section.
      </p>
    </section>
    <section> <h4>Warn risk of physical location leak</h4>
      <p>
        When listening for and pushing <a>NFC content</a>,
        the UA may warn the user that the given <a>origin</a> may be able to
        infer physical location.
      </p>
    </section>
    <section> <h4>Restrict automatic handling</h4>
      <p>
        The payload data on <a>NFC content</a> is untrusted, and must not be used
        by the UA to do automatic handling such as opening a web page
        with a URL found in an <a>NFC tag</a>, unless the user approves that.
      </p>
    </section>
      <!--p>
        For Bluetooth and WiFi handover (supported in later versions),
        the user should have to grant access to the secondary API and must be
        able to properly understand what they are granting.
      </p-->
  </section> <!-- Policies -->
</section> <!-- Security and Privacy  -->

<!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
<section> <h2>Data Representation</h2>
  <section> <h3>The <dfn>NDEFMessage</dfn> interface</h3>
    <p>
      The content of any <a>Web NFC message</a> is exposed by the
      <a>NDEFMessage</a> interface:
    </p>
    <pre class="idl">
      [Constructor(NDEFMessageInit messageInit), Exposed=Window]
      interface NDEFMessage {
        readonly attribute USVString url;
        readonly attribute FrozenArray&lt;NDEFRecord&gt; records;
      };

      dictionary NDEFMessageInit {
        USVString url;
        sequence&lt;NDEFRecordInit&gt; records;
      };
    </pre>
    <p>
      The <dfn data-dfn-for="NDEFMessage">url</dfn>
      property represents the <a>message author</a> of a received
      <a>Web NFC message</a>.
    </p>
    <p>
      The <dfn data-dfn-for="NDEFMessage">records</dfn>
      property represents a <a>list</a> of <a>NDEF record</a>s defining the
      <a>Web NFC message</a>.
    </p>
    <p data-dfn-for="NDEFMessageInit">
      The <dfn>NDEFMessageInit</dfn> dictionary is used to initialize a
      <a>Web NFC message</a>. When used in the <a>NFCWriter.push()</a>
      method, its <dfn>url</dfn> member represents a URL [= url/path =]
      used for constructing the <a>message author</a> of the pushed <a>Web NFC content</a>.
    </p>
  </section>

  <section data-dfn-for="NDEFRecord"> <h3>The <dfn>NDEFRecord</dfn> interface</h3>
    <p>
      The content of any <a>NDEF record</a> is exposed by the
      <a>NDEFRecord</a> interface:
    </p>
    <pre class="idl">
      typedef any NDEFRecordData;

      [Constructor(NDEFRecordInit recordInit), Exposed=Window]
      interface NDEFRecord {
        readonly attribute NDEFRecordType recordType;
        readonly attribute USVString mediaType;

        USVString? toText();
        [NewObject] ArrayBuffer? toArrayBuffer();
        [NewObject] object? toJSON();
      };

      dictionary NDEFRecordInit {
        NDEFRecordType recordType;
        USVString mediaType;

        NDEFRecordData data;
      };
    </pre>

    <p>
      A <a>NDEFRecord</a> object has the following <a data-cite=
      "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal slots</a>:
    </p>
    <table class="simple">
      <thead>
        <tr>
          <th>
            Internal slot
          </th>
          <th>
            Initial value
          </th>
          <th>
            Description (<em>non-normative</em>)
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <dfn>[[\PayloadData]]</dfn>
          </td>
          <td>
            Empty <a>byte sequence</a>.
          </td>
          <td>
            A <a>byte sequence</a> representing the whole or a subset of the
            <a>PAYLOAD field</a> data.
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      The <dfn>NDEFRecordData</dfn> is a union type representing data types allowed
      for <a href="#dom-ndefrecordinit-data">NDEFRecordInit.data</a> property.
    </p>
    <p>
      The <dfn>mediaType</dfn> property represents the <a>MIME type</a> of
      the <a>NDEF record</a> payload.
    </p>
    <p>
      The <dfn>recordType</dfn> property represents the <a>NDEF record</a> types.
    </p>
    <p>
      The <dfn>toText()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object
      and a `text` type.
    </p>
    <p>
      The <dfn>toArrayBuffer()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object
      and an `arrayBuffer` type.
    </p>
    <p>
      The <dfn>toJSON()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.[[\PayloadData]] bytes</a> with an <a>NDEFRecord</a> object
      and a `JSON` type.
    </p>
    <p data-dfn-for="NDEFRecordInit">
      The <dfn>NDEFRecordInit</dfn> dictionary is used to initialize an <a>NDEF record</a>
      with its type, <a>MIME type</a> and payload data via the members of
      <dfn>recordType</dfn>, <dfn>mediaType</dfn>,
      and <dfn>data</dfn>. The mapping from data types of an
      <a>NDEFRecordInit</a> to <a>NDEF record</a> types is presented
      in the algorithmic steps which handle the data and described in the
      [[[#steps-receiving]]] and [[[#writing-or-pushing-content]]] sections.
    </p>
    <p>
      To <dfn>convert NDEFRecord.[[\PayloadData]] bytes</dfn>, pass a |record:NDEFRecord|
      and a |type|, run these steps:
    </p>
    <ol class=algorithm>
      <li>
        Let |bytes:byte sequence| be |record|.[[\PayloadData]].
      </li>
      <li>
        Let |recordType:NDEFRecordType| be the value of |record|'s
        <a data-link-for="NDEFRecord">recordType</a> attribute.
      </li>
      <li>Switch on |type|:
        <dl>
          <dt>text</dt>
          <ol>
            <li>
              If the |recordType| value is equal to "`empty`", return `null`.
            </li>
            <li>
              If the |recordType| value is equal to "`text`", then run the following sub-steps:
              <ol>
                <li>
                  Let |header| be the first <a>byte</a> of |bytes|.
                </li>
                <li>
                  Let |charset| be "`utf-8`" if bit `7` (<a>MB field</a>) of
                  |header| is equal to the value 0, or else "`utf-16be`".
                </li>
                <li>
                  Let |offset| be the value given by bit `5` to bit `0` of the
                  |header|.
                </li>
                <li>
                  Let |buffer| be the |bytes|,
                  from position |offset| + `1` to the end.
                </li>
                <li>
                  If |charset| is equal to "`utf-8`", return the result of
                  running <a>UTF-8 decode</a> on |buffer|.
                </li>
                <li>
                  Otherwise, return the result of running <a>decode</a> on
                  |buffer| with `encoding` set to "`utf-16be`".
                </li>
              </ol>
            </li>
            <li>
              Otherwise, return the result of running <a>UTF-8 decode</a> on |bytes|.
            </li>
          </ol>
          <dt>arrayBuffer</dt>
          <ol>
            <li>
              If the |recordType| value is equal to "`json`" or
              "`opaque`", then return an {{ArrayBuffer}} whose contents are the
              |bytes|. Re-[= exception/throw =] any exceptions.
            </li>
            <li>
              Otherwise, return `null`.
            </li>
          </ol>
          <dt>JSON</dt>
          <ol>
            <li>
              If the |recordType| value is equal to "`json`" or
              "`opaque`", then return the result of running <a>parse JSON from bytes</a>
              on |bytes|. Re-[= exception/throw =] any exceptions.
            </li>
            <li>
              Otherwise, return `null`.
            </li>
          </ol>
        </dl>
      </li>
    </ol>
  </section> <!-- NDEFRecord dictionary -->

  <section data-dfn-for="NDEFRecordType">
    <h2>The <dfn>NDEFRecordType</dfn> string</h2>
      <p>
        This string defines the allowed types for a <a>NDEFRecord</a>. The
        [[[#data-mapping]]] section describes how
        <a>NDEFRecordType</a> is mapped to <a>NDEF record</a> types.
      </p>
      <pre class="idl">
        typedef DOMString NDEFRecordType;
      </pre>
      <p>
        A set of known standardized values exists, but it is also possible
        for organizations to create their own custom <a>external type</a>s.
      </p>
      <dl>
        <dt>The "<dfn>empty</dfn>" string</dt>
        <dd>
          The value representing <a href="#dfn-empty">empty</a> <a>NDEFRecord</a>.
        </dd>
        <dt>The "<dfn>text</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-text">text</a> type.
        </dd>
        <dt>The "<dfn>url</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-url">url</a> type.
        </dd>
        <dt>The "<dfn>smart-poster</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-smart-poster">smart-poster</a> type.
        </dd>
        <dt>The "<dfn>json</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of a <a href="#dfn-json">json</a> type.
        </dd>
        <dt>The "<dfn>opaque</dfn>" string</dt>
        <dd>
          The value representing <a>NDEFRecord</a> of an <a href="#dfn-opaque">opaque</a> type.
        </dd>
        <dt>An <dfn>external type</dfn></dt>
        <dd>
          A {{DOMString}} representing a custom type for the <a>external type record</a>.
          The type must follow the <a>external type</a> ABNF.
          <pre class="abnf">
            ext-type             = reg-name ":" custom-type
            custom-type          = 1*(ALPHA / DIGIT / other)

            DIGIT                = %x30-39
            ALPHA                = %x41-5A / %x61-7A   ; A-Z / a-z
            other                = "(" / ")" / "+" / "," / "-" / ":" / "=" /
                                   "@" / ";" / "$" / "_" / "!" / "*" / "'" / "."
          </pre>
          The `reg-name` value is a [=host/registrable domain=] owned by the issuing organization, a "`:`" and a type, e.g. "`w3.org:A`".
          And additional ABNF exists for <a>well-known type record</a>s:
          <pre class="abnf">
            wkt-type             = (ALPHA / DIGIT) *(ALPHA / DIGIT / other)
          </pre>
          <p class=note>
            The [[[NFC-RTD]]] defines every type in the <a>well-known type record</a>s and <a>external type records</a> in terms of URNs, but only a subset of the URN is actually stored in the <a>NDEF record</a>'s <a>TYPE field</a>, which corresponds to the above two ABNFs.
          </p>
        </dd>
      </dl>
  </section> <!-- NDEFRecordType enum -->

  <section id="data-mapping"><h3>Data mapping</h3>
  <p>
    The mapping from data types of an <a>NDEFRecordInit</a> to
    <a>NDEF record</a> types, as used in the [[[#writing-or-pushing-content]]]
    section is as follows:
  </p>
  <table class="simple">
    <tr>
      <th>NDEFRecordInit recordType</th>
      <th>NDEFRecordInit mediaType</th>
      <th>NDEFRecordInit data</th>
      <th>NDEF record type</th>
    </tr>
    <tr>
      <td><dfn>"`empty`"</dfn></td>
      <td><i>unused</i></td>
      <td><i>unused</i></td>
      <td><a>Empty record</a></td>
    </tr>
    <tr>
      <td><dfn>"`text`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}}</td>
      <td><a>Well-known type record</a> with type "`T`"</td>
    </tr>
    <tr>
      <td><dfn>"`url`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}}</td>
      <td><a>Well-known type record</a> with type "`U`"</td>
    </tr>
    <tr>
      <td><dfn>"`json`"</dfn></td>
      <td><a>JSON MIME type</a></td>
      <td>
        [= JSON type =]
      </td>
      <td><a>MIME type record</a> with type equal to
        <a>MIME type</a>.
      </td>
    </tr>
    <tr>
      <td><dfn>"`opaque`"</dfn></td>
      <td><a>MIME type</a></td>
      <td>{{ArrayBuffer}}</td>
      <td><a>MIME type record</a></td>
    </tr>
    <tr>
      <td><a>external type</a></td>
      <td><i>unused</i></td>
      <td>
        {{ArrayBuffer}} or<br>
        any <a>typed array type</a>
      </td>
      <td><a>External type record</a></td>
    </tr>
  </table>
  <p>
    The mapping from <a>NDEF record</a> types to <a>NDEFRecord</a>,
    as used for incoming <a>NDEF message</a>s described in the
    [[[#steps-receiving]]] section, is as
    follows:
  </p>
  <table class="simple" data-link-for="NDEFRecord">
    <tr>
      <th>NDEF record type</th>
      <th>NDEFRecord recordType</th>
      <th>NDEFRecord mediaType</th>
      <th>NDEFRecord data getters</th>
    </tr>
    <tr>
      <td><a>Empty record</a></td>
      <td>"`empty`"</td>
      <td><i>empty</i></td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>Well-known type record</a> with type "`T`"</td>
      <td>"`text`"</td>
      <td>"`text/plain`"</td>
      <td><a>toText()</a></td>
    </tr>
    <tr>
      <td><a>Well-known type record</a> with type "`U`"</td>
      <td>"`url`"</td>
      <td>"`text/plain`"</td>
      <td><a>toText()</a></td>
    </tr>
    <tr>
      <td><a>Well-known type record</a> with type "`Sp`"</td>
      <td>"`smart-poster`"</td>
      <td>""</td>
      <td>
        toRecord() or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>Absolute-URL record</a></td>
      <td>"`url`"</td>
      <td>"`text/plain`"</td>
      <td><a>toText()</a></td>
    </tr>
    <tr>
      <td><a>MIME type record</a> with
        <a>JSON MIME type</a>
      </td>
      <td>"`json`"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>MIME type record</a></td>
      <td>"`opaque`"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td><a>External type record</a> with type other than
        `w3.org:A`</td>
      <td><a>external type</a></td>
      <td>"`application/octet-stream`"</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
    <tr>
      <td>Any other <a>NDEF record</a> type</td>
      <td>"`opaque`"</td>
      <td>"`application/octet-stream`"</td>
      <td>
        <a>toText()</a> or<br>
        <a>toJSON()</a> or<br>
        <a>toArrayBuffer()</a>
      </td>
    </tr>
  </table>
  <p>
    The <a>author type record</a>s MUST NOT be exposed to client
    <a>browsing context</a>s.
  </p>
  </section>
</section> <!-- Data types and content -->


<section> <h2>The NFCReader and NFCWriter objects</h2>
  The objects provide a way for the <a>browsing context</a> to
  use NFC functionality.
  They allow for pushing <a>Web NFC message</a>s to <a>NFC tag</a>s
  or <a>NFC peer</a>s within range, and to act on incoming
  <a>Web NFC message</a>s either from an <a>NFC tag</a> or an
  <a>NFC peer</a>.
  <pre class="idl">
    typedef (DOMString or ArrayBuffer or NDEFMessageInit) NDEFMessageSource;

    [Constructor, SecureContext, Exposed=Window]
    interface NFCWriter {
      Promise&lt;void&gt; push(NDEFMessageSource message, optional NFCPushOptions options={});
    };

    [Constructor, SecureContext, Exposed=Window]
    interface NFCReader : EventTarget {
      attribute EventHandler onreading;
      attribute EventHandler onerror;

      void scan(optional NFCScanOptions options={});
    };

    [Constructor(DOMString type, NFCReadingEventInit readingEventInitDict), SecureContext, Exposed=Window]
    interface NFCReadingEvent : Event {
      readonly attribute DOMString serialNumber;
      [SameObject] readonly attribute NDEFMessage message;
    };

    dictionary NFCReadingEventInit : EventInit {
      DOMString? serialNumber = "";
      required NDEFMessageInit message;
    };

    [Constructor(DOMString type, NFCErrorEventInit errorEventInitDict), SecureContext, Exposed=Window]
    interface NFCErrorEvent : Event {
      readonly attribute DOMException error;
    };

    dictionary NFCErrorEventInit : EventInit {
      required DOMException error;
    };

  </pre>
  <p>
    The <dfn>NDEFMessageSource</dfn> is a union type representing argument types
    accepted by the <a href="#dom-nfcwriter-push">push()</a> method.
  </p>
  <p data-dfn-for="NFCReadingEvent">
    The <dfn>NFCReadingEvent</dfn> is the event being dispatched on new NFC readings.
    The <dfn>serialNumber</dfn> property represents the serial number of
    the device used for anti-collision and identification, or empty string in case none
    is available. The <dfn>message</dfn> is an <a>NDEFMessage</a> object.
  </p>
  <p data-dfn-for="NFCReadingEventInit">
    <dfn>NFCReadingEventInit</dfn> is used to initialize a new event with a serial number
    and the <a>NDEFMessageInit</a> data via the <dfn>message</dfn> member.
    If <dfn>serialNumber</dfn> is
    [= dictionary member/not present =] or is `null`,
    empty string will be used to init the event.
  </p>
  <p class="note">
    Though most tags will have a stable unique identifier (UID), not all
    have one and some tags even create a random number on each read.
    The serial number usually consists of 4 or 7 numbers, separated by `:`.
  </p>
  <p data-dfn-for="NFCErrorEvent">
    The <dfn>NFCErrorEvent</dfn> is the event being dispatched on errors,
    with the {{DOMException}} object as the <dfn>error</dfn>
    attribute.
  </p>
  <p data-dfn-for="NFCErrorEventInit">
    <dfn>NFCErrorEventInit</dfn> is used in order to initialize a new
    event with a {{DOMException}} data via the <dfn>error</dfn>
    member.
  </p>
  <p>
    The <dfn>NFCWriter</dfn> is an object used for writing data to NFC devices
    such as tags.
  </p>
  <p>
    The <dfn>NFCReader</dfn> is an object used for reading data when a device,
    such as a tag, is within the magnetic induction field.
  </p>
  <p>
    The <dfn data-dfn-for="NFCReader">onreading</dfn> is an {{EventHandler}} which is called to notify
    that new reading is available.
  </p>
  <p>
    The <dfn data-dfn-for="NFCReader">onerror</dfn> is an {{EventHandler}} which is called to notify
    that an error happened.
  </p>
  <section><h3>NFC state associated with the settings object</h3>
  <p>
    The <a>relevant settings object</a> of the <a>active document</a> of a
    <a>browsing context</a> which supports NFC has an associated
    <dfn>NFC state</dfn> record with the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal
    slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>[[\Suspended]]</td>
      <td>
        A boolean flag indicating whether NFC functionality is
        <a href="#nfc-suspended">suspended</a> or not, initially
        `false`.
      </td>
     </tr>
     <tr>
      <td>[[\ActivatedReaderList]]</td>
      <td>
        A <a>set</a> of {{NFCReader}} instances initially set to the empty <a>set</a>.
      </td>
     </tr>
     <tr>
      <td>[[\PendingPush]]</td>
      <td>
        A promise-writer tuple where the promise holds a pending {{Promise}} and
        writer holds a {{NFCWriter}}. Initially the slot is empty.
      </td>
      </tr>
    </tbody>
  </table>
  <p>
    The <dfn>activated reader objects</dfn> is the value of the [[\ActivatedReaderList]] internal slot.
  </p>
  <p>
    The <dfn>pending push tuple</dfn> is the value of the [[\PendingPush]] internal slot.
  </p>
  <p>
    <dfn id="nfc-is-suspended">NFC is suspended</dfn> if the [[\Suspended]] internal slot is `true`.
  </p>
  <p>
    To <dfn id="suspend-nfc">suspend NFC</dfn>, set the [[\Suspended]] internal slot to `true`.
  </p>
  <p>
    To <dfn id="resume-nfc">resume NFC</dfn>, set the [[\Suspended]] internal slot to `false`.
  </p>
  <p class="note">
    Internal slots are used only as a notation in this specification, and
    implementations do not necessarily have to map them to explicit internal
    properties.
  </p>
  </section>

  <section> <h3>Handling NFC adapters</h3>
    Implementations MAY use multiple <a>NFC adapter</a>s
    according to the algorithmic steps described in this specification.
  </section>

  <section><h3>Handling Window visibility and focus</h3>
    <p>
      Each {{Window}} object where the Web NFC API is
      exposed has separate <a>NFCWriter</a> and <a>NFCReader</a> instances.
      The <a>visible and focused</a> state of the
      the <a>top-level browsing context</a>'s {{Document}} determines the
      <a href="#nfc-suspended">suspended</a> state of the associated
      <a>NFCWriter</a> and <a>NFCReader</a> instances.
    </p>
    <p>
      The term <dfn id="nfc-suspended">suspended</dfn> in this specification
      refers to NFC operations being suspended, i.e. no <a>NFC content</a> is
      pushed by <a>NFCWriter</a>s, and no received <a>NFC content</a> is
      presented to any {{NFCReader}} while suspended.

      However, platform level timers for the
      <a>NFCWriter.push()</a> method continue running,
      and if they expire, the event should be recorded and handled
      when execution next resumes, i.e. when the [= Window/focus =]
      event is fired on the {{Window}} object.
    </p>
    <p>
      When the {{Document}} of the <a>top-level browsing context</a>
      using the Web NFC API is <a>visible and focused</a>, <a>resume NFC</a>.
      Otherwise, <a>suspend NFC</a>.
    </p>
  </section> <!-- visibility & focus: the suspended state -->

  <section><h3>Aborting pending push operation</h3>
  <p>
    To attempt to <dfn>abort a pending push operation</dfn> on an
    <a>environment settings object</a>, perform the following steps:
    <ol class=algorithm>
      <li>
        If there is no <a>pending push tuple</a> |tuple|, abort these steps.
      </li>
      <li>
        Let |writer:NFCWriter| be |tuple|'s writer.
      </li>
      <li>
        Let |p:Promise| be |tuple|'s promise.
      </li>
      <li>
        Stop the |writer|'s |timer| if it is active.
      </li>
      <li>
        If the |writer| has already initiated NFC data transfer,
        abort these steps.
      </li>
      <li>
        Clear the <a>pending push tuple</a>.
      </li>
      <li>
        Reject |p| with an {{"AbortError"}} {{DOMException}}
        and abort these steps.
      </li>
    </ol>
    <p class=note>
      Rejecting |p| will clear the <a>pending push tuple</a> and
      remove the <a>async write handlers</a> as it is a transformed promise
      with fulfillment and rejection handlers.
    </p>
  </p>
  </section>

  <section><h3>Releasing NFC</h3>
  <p>
    To <dfn>release NFC</dfn> on an <a>environment settings object</a>,
    perform the following steps:
  </p>
  <ol id="steps-nfc-release">
    <li>
      <a>Suspend NFC</a>.
    </li>
    <li>
      Attempt to <a>abort a pending push operation</a>.
    </li>
    <li>
      Stop the <a>dispatch NFC content</a> steps.
    </li>
    <li>
      Clear the <a>activated reader objects</a>.
    </li>
    <li>
      Release the NFC resources associated with |nfc| on the
      underlying platform.
    </li>
  </ol>
  <p>
    The UA must <a>release NFC</a> given the document's <a>relevant settings object</a> as
    additional <a>unloading document cleanup steps</a>.
  </p>
  </section> <!-- release NFC -->

  <section data-dfn-for="NDEFCompatibility">
      <h3>The <dfn>NDEFCompatibility</dfn> enum</h3>
        <p>
          To describe what NDEF compatible devices are accepted as
          vendor specific tags exist that support NDEF but which
          are not universally supported by all NFC readers, or by
          the NFC standard.
        </p>
        <pre class="idl">
          enum NDEFCompatibility {
            "nfc-forum",
            "vendor",
            "any"
          };
        </pre>
        <p>
          <dl>
            <dt><dfn>nfc-forum</dfn></dt>
            <dd>
              The enum value representing all active and passive NFC
              devices, supported by the NFC standard.
            </dd>
          </dl>
          <dl>
            <dt><dfn>vendor</dfn></dt>
            <dd>
              The enum value representing vendor specific NFC tags
              (passive device) that require specific reader chips.
            </dd>
          </dl>
          <dl>
            <dt><dfn>any</dfn></dt>
            <dd>
              The enum value representing all NDEF compatible devices
              that the reader chip can read.
            </dd>
          </dl>
        </p>
  </section>

  <section data-dfn-for="NFCPushOptions"> <h3>The <dfn>NFCPushOptions</dfn> dictionary</h3>
    <pre class="idl">
      dictionary NFCPushOptions {
        NFCPushTarget target = "any";
        unrestricted double timeout = Infinity;
        boolean ignoreRead = true;
        AbortSignal? signal;
        NDEFCompatibility compatibility = "nfc-forum";
      };
    </pre>
    <p>
      The <dfn>target</dfn> property
      denotes the intended target for the pending
      <a href="#dom-nfcwriter-push">push()</a>
      operation.
    </p>
    <p>
      The <dfn>timeout</dfn> property
      denotes the timeout for the pending
      <a href="#dom-nfcwriter-push">push()</a>
      operation expressed in milliseconds. The default value is
      implementation-dependent. The value `Infinity` means there is
      no timeout, i.e. no timer is started. After the |timeout|
      expires, the message set for pushing is cleared, an error is returned,
      and a new <a>Web NFC message</a> can be set for pushing.
    </p>
    <p>
      When the value of the <dfn>ignoreRead</dfn> property is
      `true`, the <a href="#steps-push">push algorithm</a>
      will skip invoking the <a href="#steps-receiving">
      receiving and parsing steps</a> for an <a>NFC tag</a>.
    </p>
    <p>
      The <dfn>signal</dfn> property allows to abort
      the <a href="#dom-nfcwriter-push">push()</a> operation.
    </p>
    <p>
      The <dfn>compatibility</dfn> property denotes
      the accepted kind of NFC devices.
    </p>
  </section>

  <section data-dfn-for="NFCPushTarget">
    <h2>The <dfn>NFCPushTarget</dfn> enum</h2>
    <p>
      This enum defines the set of intended target values for the
      <a href="#dom-nfcwriter-push">push()</a> operation.
    </p>
    <pre class="idl">
      enum NFCPushTarget {
        "tag",
        "peer",
        "any"
      };
    </pre>
    <dl>
      <dt><dfn>tag</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push">push()</a> operation to be
        a <a>NFC tag</a>.
      </dd>
      <dt><dfn>peer</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push">push()</a> operation to be
        a <a>NFC peer</a>.
      </dd>
      <dt><dfn>any</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        <a href="#dom-nfcwriter-push">push()</a> operation to be
        a <a>NFC tag</a> or a <a>NFC peer</a>.
      </dd>
    </dl>
  </section> <!-- NFCPushTarget enum -->

  <section data-dfn-for="NFCScanOptions">
    <h3>The <dfn>NFCScanOptions</dfn> dictionary</h3>
      <p>
        To describe which messages an application is interested in, the
        <a>NFCScanOptions</a> dictionary is used:
      </p>
      <pre class="idl">
        dictionary NFCScanOptions {
          AbortSignal? signal;
          USVString url = "";
          NDEFRecordType recordType;
          USVString mediaType = "";
          NDEFCompatibility compatibility = "nfc-forum";
        };
      </pre>
      <p>
        The <dfn>signal</dfn> property allows to abort the
        <a href="#dom-nfcreader-scan">scan()</a> operation.
      </p>
      <p>
        The <dfn>url</dfn> property
        denotes the <a>URL pattern</a> which is used for matching the
        <a>message author</a> of <a>Web NFC message</a>s which are being read.
        The default value `""` means that no matching is performed.
      </p>
      <p>
        The <dfn>recordType</dfn> property
        denotes the enum value which is used for matching the
        <a href="#idl-def-ndefrecordtype">recordType</a> property of each
        <a>NDEFRecord</a> object in a <a>Web NFC message</a>.
        If the dictionary member is [= dictionary member/not present =],
        then it will be ignored by the <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>mediaType</dfn> property
        denotes the <a>match pattern</a> which is used for matching the
        <a href="#dom-ndefrecord-mediatype">mediaType</a> property of each
        <a>NDEFRecord</a> object in a <a>Web NFC message</a>.
        The default value `""` means that no matching is performed.
      </p>
      <p>
        The <dfn>compatibility</dfn> property denotes
        the accepted kind of NFC devices.
      </p>
      <pre
        title="Filter accepting only JSON content from https://www.w3.org"
        class="example highlight">
        const options = {
          url: "https://www.w3.org/*",  // any path from the domain is accepted
          recordType: "json",
          mediaType: "application/*+json"  // any JSON-based MIME type
        }
      </pre>
      <pre
        title="Filter which only accepts binary content from a given path for w3 domain and its subdomains"
        class="example highlight">
        const options = {
          url: "https://w3.org/info/restaurant/daily-menu/",
          recordType: "opaque",
          mediaType: "application/octet-stream"
        }
      </pre>
  </section> <!-- NFCScanOptions -->

  <section id="writing-or-pushing-content">
    <h3><dfn>Writing or pushing content</dfn></h3>
    <p>
      This section describes how to write an <a>NDEF message</a>
      to an <a>NFC tag</a> or how to push it to an <a>NFC peer</a>
      device when it is next time in proximity range before a timer expires.
      At any time there is at maximum of two
      <a>Web NFC message</a>s that can be set for pushing for an <a>origin</a>:
      one targeted to <a>NFC tag</a>s and one to <a>NFC peer</a>s, until
      the current message is sent, a timeout happens, or the push is
      aborted.
    </p>
    <section><h3>The <strong>push()</strong> method</h3>
      <p id="steps-push">
        The
        <dfn>NFCWriter.push</dfn> method, when invoked, MUST run the
        <dfn>push a message</dfn> algorithm:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be a new {{Promise}} object.
          </li>
          <li>
            Let |message:NDEFMessageSource| be the first argument.
          </li>
          <li>
            Let |options:NFCPushOptions| be the second argument.
          </li>
          <li>
            Let |signal:AbortSignal| be the |options| dictionary member
            of the same name if present, or `null` otherwise.
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection cannot
            be established, then reject |p| with a
            {{"NotSupportedError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If the UA is not allowed to access the underlying <a>NFC Adapter</a>
            (e.g. a user preference), then reject |p| with a
            {{"NotReadableError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If pushing data is not supported by the underlying <a>NFC Adapter</a>, then reject
            |p| with a {{"NotSupportedError"}}
            {{DOMException}} and return |p|.
          </li>
          <li>
            If |signal|s [= AbortSignal/aborted flag =] is set, then reject |p|
            with an {{"AbortError"}} {{DOMException}} and return |p|.
          </li>
          <li>
            If |signal| is not `null`, then
            <a data-cite="dom#abortsignal-add">add the following abort steps</a> to |signal|:
              <ol>
                <li>
                  If the instance has already initiated NFC data transfer,
                  and it can't be aborted, ignore the abort signal and return.
                </li>
                <li>
                  Stop the instance's |timer| if it is active.
                </li>
                <li>
                  Reject |p| with an {{"AbortError"}}
                  {{DOMException}} and abort these steps.
                </li>
              </ol>
          </li>
          <li>
            Run the following steps <a>in parallel</a>:
            <ol>
              <li>
                An implementation MAY reject |p| with
                a {{"NotSupportedError"}} {{DOMException}}
                and abort these steps.
                <div class="note">
                  The UA might terminate message push at this point. The reasons
                  for terminations are implementation details. For example, the user
                  could have has set a preference to allow a given origin only to
                  read, write, or push data to peers. Also, the implementation might
                  be unable to support the operation requested.
                </div>
              </li>
              <li>
                Let |target:NFCPushTarget| be |options|'s target.
              </li>
              <li>
                Let |timeout:number| be |options|'s timeout.
              </li>
              <li>
                Let |compatibility:NDEFCompatibility| be |options|'s compatibility.
              </li>
              <li>
                If the |message:NDEFMessageSource| parameter is not of type defined by
                the <a>NDEFMessageSource</a> union, reject |p|
                with a {{TypeError}}, and abort these steps.
              </li>
              <li>
                If the |message| parameter is of
                <a>NDEFMessageInit</a> type, and |message|'s records
                [= list/is empty =], reject |p| with
                a {{TypeError}} and abort these steps.
              </li>
              <li>
                If |timeout| value is `NaN` or negative, reject
                |p| with a {{TypeError}} and abort
                these steps.
              </li>
              <li>
                If |timeout| value is not supported by the UA, reject
                |p| with a {{"NotSupportedError"}}
                {{DOMException}} and abort these steps.
              </li>
              <li>
                Let |output| be the notation for the <a>NDEF message</a>
                to be created by UA, as the result of passing
                |message| to <a>create Web NFC message</a>.
                If this throws an exception, reject |p| with that
                exception and abort these steps.
              </li>
              <li>
                If |target| is "`any`", run the following
                steps twice, once with |slot| set to the value
                "`tag`", and once set to the value "`peer`";
                otherwise run the following step once, with
                |slot| set to the value of |target|.
              </li>
              <li>
                Attempt to <a>abort a pending push operation</a>.
              </li>
              <li>
                Associate |output| with |slot|.
              </li>
              </ul>
              <li>
                If |timeout| value is not equal to `Infinity`,
                start a timer |timer| with the timeout value set to
                |timeout|.
              </li>
              <li>
                Add the following <dfn>async write handlers</dfn>:
                <dl>
                  <dt>The |timer| expires</dt>
                  <ol>
                    <li>
                      Reject |p| with {{"TimeoutError"}} {{DOMException}}.
                    </li>
                  </ol>
                  <dt>An <a>NFC device</a> |device| comes within
                    communication range</dt>
                  <ol>
                    <li>
                      Verify the following conditions:
                      <ul>
                        <li>
                          if |device| is not officially supported
                          by the NFC Forum, |compatibility| is
                          "`vendor`" or "`any`".
                        </li>
                        <li>
                          if |device| is an <a>NFC tag</a>, |target|
                          is "`tag`" or "`any`".
                        </li>
                        <li>
                          if |device| is an <a>NFC peer</a>,
                          |target| is "`peer`" or
                          "`any`".
                        </li>
                        <li>
                          <a href="#nfc-is-suspended">NFC is not suspended</a>.
                        </li>
                      </ul>
                      In case of success, run the following sub-steps:
                      <ol>
                        <li>
                          Stop |timer| if active.
                        </li>
                        <li>
                          If |device| is an <a>NFC tag</a>,
                          <ul>
                            <li>Read the tag.</li>
                            <li>
                              If |options|'s ignoreRead is not equal to
                              `true`, run the
                              <a href="#steps-receiving">receiving steps</a>.
                            </li>
                            <li>
                              Let |authorHost| be the <a>message author host</a> of the
                              tag.
                            </li>
                            <li>
                              If |authorHost| is `null`, or different than the
                              <a data-cite="url#concept-host-serializer">
                              serialized host</a> of the
                              <a>current settings object</a>'s origin, and the
                              <a>obtain push permission</a> steps return
                              `false`, then reject |p| with
                              {{"NotAllowedError"}} {{DOMException}}
                              and abort these steps.
                            </li>
                          </ul>
                        </li>
                        <li>
                          Initiate data transfer to |device| using
                          |output| as buffer, using the <a>NFC adapter</a>
                          in communication range with (connected to)
                          |device|.
                        </li>
                        <li>
                          If the transfer fails, reject |p| with
                          {{"NetworkError"}} {{DOMException}}
                          and abort these steps.
                          <p class="note">
                            Multiple adapters should be used sequentially by users.
                            There is very small likelihood that a simultaneous tap
                            will happen on two or multiple different and connected
                            <a>NFC adapter</a>s.
                            If it happens, the user will likely need to repeat the
                            taps until success, preferably one device at a time.
                            The error here gives an indication that the operation
                            needs to be repeated. Otherwise the user may think the
                            operation succeeded on all connected <a>NFC adapter</a>s.
                          </p>
                        </li>
                        <li>
                          When the transfer has completed, clear |output|
                          associated with |target|, resolve
                          |p|.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </dl>
              </li>
              <li>
                Let |transformedPromise| be the result of
                <a data-cite="promises-guide">transforming</a> |p| with a fulfillment
                and rejection handler that:
                <ol>
                  <li>
                    Clears the <a>pending push tuple</a>.
                  </li>
                  <li>
                    Removes <a>async write handlers</a>.
                  </li>
                </ol>
              </li>
              <li>
                Set <a>pending push tuple</a> to (`this`, |transformedPromise|).
              </li>
              <li>
                Return |transformedPromise|.
              </li>
            </ol>
            <p class="note">
              If <a>NFC is suspended</a>,
              continue waiting until |timer| expires (if set), or
              promise is aborted by the user, or until an <a>NFC device</a>
              comes within communication range.
            </p>
          </li>
        </ol>
      </p>

      <section><h3>Obtaining push permission</h3>
      <p>
        To <dfn>obtain push permission</dfn>, run these steps:
        <ol class=algorithm>
          <li>
            If there is a <a>prearranged trust relationship</a>,
            return `true`.
          </li>
          <li>
            Run the
            <a>query a permission</a> steps for the
            <a>Web NFC permission name</a> until completion.
            <ol>
              <li>
                If it resolved with {{PermissionState["granted"]}}
                (i.e. an <a>expressed permission</a> has been granted
                to the <a>origin</a> and <a>global object</a> using
                the [[[PERMISSIONS]]] API), return `true`.
              </li>
              <li>
                Otherwise, if it resolved with {{PermissionState["prompt"]}}, then optionally
                <a data-lt="request permission to use">request permission</a>
                from the user for the <a>Web NFC permission name</a>.
                If that is granted, return `true`.
                <p class="issue">
                  The <a data-lt="request permission to use">request permission</a>
                  steps are not yet clearly defined.
                  At this point the UA asks the user about the policy to be used
                  with the <a>Web NFC permission name</a> for the given
                  <a>origin</a> and <a>global object</a>, if the user grants permission,
                  return `true`.
                </p>
              </li>
            </ol>
          </li>
          <li>
            Return `false`.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating Web NFC message</h3>
        <p>
          To <dfn>create Web NFC message</dfn> given a |message:NDEFMessageSource| run
          these steps:
        </p>
        <ol class=algorithm id="create-web-nfc-message">
          <li>
            Let |output| be the notation for the <a>NDEF message</a>
            to be created by the UA as a result of these steps.
          </li>
          <li>
            [= list/For each =] |record:NDEFRecordInit| in the <a>list</a>
            |message|'s records, run the following steps, or make sure
            that the underlying platform provides equivalent values to
            |ndef|:
            <ol>
              <li>
                If |record|'s recordType is `undefined`:
                <ol> <!-- guess type and mediaType from data -->
                  <li>
                    If |record|'s data is `undefined`, reject |promise|
                    a {{TypeError}} and abort these steps.
                  </li>
                  <li>
                    Otherwise, if the type of |record|'s data is
                    {{DOMString}}, then set |record|'s recordType to "`text`".
                  </li>
                  <li>
                    Otherwise, if the type of |record|'s data is an
                    {{ArrayBuffer}}, then set |record|'s recordType
                    to "`opaque`".
                  </li>
                  <li>
                    Otherwise, set |record|'s recordType to "`json`".
                  </li>
                </ol>
              </li>
              <li>Let |ndef| be the result of passing |record| to the algorithm below
                switching on |record|'s recordType. If the algorithm throws an exception
                |e|, reject |promise| with |e| and abort these steps.
                <dl>
                  <dt>"`empty`"</dt>
                  <ul>
                    <li>
                      <a>map empty record to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`text`"</dt>
                  <ul>
                    <li>
                      <a>map text to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`url`"</dt>
                  <ul>
                    <li>
                      <a>map a URL to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`json`"</dt>
                  <ul>
                    <li>
                      <a>map JSON to NDEF</a>.
                    </li>
                  </ul>
                  <dt>"`opaque`"</dt>
                  <ul>
                    <li>
                      <a>map binary data to NDEF</a>.
                    </li>
                  </ul>
                </dl>
                <li>
                  Add |ndef| to |output|.
                </li>
              </li> <!-- converting each record -->
            </ol>
          </li> <!-- converting message -->
          <li>
            Let |authorRecord| be the result of invoking
            <a>create an author type record</a> given |message|'s url.
            If this throws exception |e|, reject |promise| with |e|
            and abort these steps.
          </li>
          <li>
            Add |authorRecord| to |output|.
            <p class="note">
              Implementations may choose the location of the author type record
              within the <a>NDEF message</a>.
            </p>
          </li>
        </ol>
      </section>

      <section><h3>Mapping empty record to NDEF</h3>
      <p>
        To <dfn>map empty record to NDEF</dfn> given a |record:NDEFRecordInit|, run
        these steps:
        <ol class=algorithm>
          <li>
            Let |ndef| be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>Set the
            |ndef|'s <a>TNF field</a> to `0` (<a>empty record</a>).
          </li>
          <li>Set the
            |ndef|'s <a>IL field</a> to `0`.
          </li>
          <li>Set
            |ndef|'s <a>TYPE LENGTH field</a>,
            and <a>PAYLOAD LENGTH field</a> to `0`,
            and omit <a>TYPE field</a> and <a>PAYLOAD field</a>.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping string to NDEF</h3>
      <p>
        To <dfn>map text to NDEF</dfn> given a |record:NDEFRecordInit|, run these
        steps:
        <p class="note">
          This is useful when clients specifically want to write text in a
          <a>well-known type record</a>.
          Other options would be to use the value "`opaque`"
          with an explicit <a>MIME type</a> text type, which allows for
          better differentiation, e.g. when using "`text/xml`", or
          "`text/vcard`".
        </p>
        <ol class=algorithm>
          <li>
            If the type of a |record|'s data is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on
            |record|'s mediaType.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`text`", and subtype is "`plain`".
              </li>
              <li>
                If |mimeTypeRecord|'s type is not "`text`", then [= exception/throw =] a
                {{"SyntaxError"}} {{DOMException}} and abort these steps.
              </li>
            </ol>
          </li>
          <li>
            Let |language:string| be |mimeTypeRecord|'s parameters["`lang`"] if it
            [= map/exists =], or "`en`".
          </li>
          <li>
            Let |charset:string| be |mimeTypeRecord|'s parameters["`charset`"] if it
            [= map/exists =], or "`utf-8`".
          </li>
          <li>
            If |charset| is not equal to "`utf-8`",
            [= exception/throw =] a {{TypeError}}.
          </li>
          <li>
            Let |header:byte| be a <a>byte</a> constructed the following way:
            <ol>
              <li>
                Set bit `7` to the value `0`
                (meaning <a>UTF-8 encoding</a>).
              </li>
              <li>
                Set bit `6` to the value `0` (reserved).
              </li>
              <li>
                Let |languageLength:octed| be the length of the
                |language| <a>string</a>.
              </li>
              <li>
                If |languageLength| cannot be stored in 6 bit (|languageLength| > 63),
                [= exception/throw =] a {{SyntaxError}}.
              <li>
                Set bit `5` to bit `0` to |languageLength|.
              </li>
            </ol>
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> (position 0) of |data| to |header|.
              </li>
              <li>
                Set position 1 (second <a>byte</a>) to position |languageLength|
                of |data| to |language|.
              </li>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of
                running <a>UTF-8 encode</a> on |record|'s data.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from |stream| into
                |data| (from position |languageLength| + 1) until
                <a data-cite="encoding#concept-stream-read">read</a>
                returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `1` (<a>well-known type record</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to "`T`" (`0x54`).
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      <p class="note">
        The `lang=` parameter is a non-standard parameter
        to <a>MIME type</a>s, but it is used in this specification
        in order to maintain compatibility with [[[NFC-STANDARDS]]].
      </p>
      </section>

      <section><h3>Mapping URL to NDEF</h3>
      <p>
        To <dfn>map a URL to NDEF</dfn> given a |record:NDEFRecordInit|, run these
        steps:
        <ol class=algorithm>
          <li>
            If |record|'s data is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |url:URL| be the result of
            <a data-lt="url parser">parsing</a> |record|'s data.
          </li>
          <li>
            If |url| is failure, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |serializedURL:string| be <a data-cite="url#concept-url-serializer">serialization</a>
            of |url|.
          </li>
          <li>
            Match the URI prefixes as defined in [[[NFC-STANDARDS]]],
            URI Record Type Definition specification, Section 3.2.2, against
            the |serializedURL|.
          </li>
          <li>
            Let |prefixString:string| be the matched prefix or else the
            <a href="#dfn-empty">empty</a> <a>string</a>.
          </li>
          <li>
            Let |prefixByte:byte| be the corresponding prefix number,
            or else `0`.
          </li>
          <li>
            Let |shortenedURL:string| be |serializedURL| with
            |prefixString| removed from the start of the <a>string</a>.
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> of |data| to |prefixByte|.
              </li>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of
                running <a>UTF-8 encode</a> on |shortenedURL|.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from |stream| into
                |data| (from position 1) until <a data-cite="encoding#concept-stream-read">read</a>
                returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `1` (<a>well-known type record</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to "`U`" (`0x55`).
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Mapping JSON to NDEF</h3>
      <p>
        To <dfn>map JSON to NDEF</dfn> given a |record:NDEFRecordInit|,
        run these steps:
        <ol class=algorithm>
          <li>
            If the type of a |record|'s data is not a [= JSON type =],
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on |record|'s mediaType.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`application`", and subtype is "`json`".
              </li>
              <li>
                If |mimeTypeRecord| is not a <a>JSON MIME type</a>,
                then [= exception/throw =] a
                {{"SyntaxError"}} {{DOMException}} and abort these steps.
              </li>
            </ol>
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of executing
                <a>serialize JSON to bytes</a> on |record|'s data.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from |stream| into
                |data| until <a data-cite="encoding#concept-stream-read">read</a> returns
                <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `2` (<a>MIME type</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to the result of
                <a>serialize a MIME type</a> with |mimeTypeRecord| as
                the input.
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      <aside class=note>
        <p>
          JavaScript Object Notation aka JSON can be any of the following [[[ECMASCRIPT]]]
          types: object, array, String, Boolean, Number or null, which covers a lot of
          the [[[WEBIDL]]] types as listed here: [= JSON type =].
        </p>
        <p>
          Serializing JSON to bytes can result in 0 bytes in some cases, like serializing
          the following object, which specifies it own
          <a data-cite="webidl#idl-tojson-operation">toJSON</a> operation:

          <pre class=highlight>
            class ZeroByteJSON {
              toJSON() {
                return undefined;
              }
            }
          </pre>

          This means that the <a>map JSON to NDEF</a> algorithm might result in a
          <a>NDEF record</a> with no <a>PAYLOAD field</a>.
        </p>
      </aside>
      </section>

      <section><h3>Mapping binary data to NDEF</h3>
      <p>
        To <dfn>map binary data to NDEF</dfn> given a |record:NDEFRecordInit|,
        run these steps:
        <ol class=algorithm>
          <li>
            If the type of a |record|'s data is not an
            {{ArrayBuffer}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on |record|'s mediaType.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`application`", and subtype is "`octet-stream`".
              </li>
            </ol>
          </li>
          <li>
            Set |arrayBuffer| to |record|'s data.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Let |ndefRecord| be the notation for the <a>NDEF record</a> to
            be created by the UA.
            <ol>
              <li>
                Set the |ndefRecord|'s <a>TNF field</a> to `2` (<a>MIME type</a>).
              </li>
              <li>
                Set the |ndefRecord|'s <a>TYPE field</a> to the result of
                <a>serialize a MIME type</a> with |mimeTypeRecord| as
                the input.
              </li>
              <li>
                Set the |ndefRecord|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndefRecord|'s <a>PAYLOAD field</a> to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndefRecord|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating an author type record</h3>
      <p>
        To <dfn>create an <a>author type record</a></dfn> given URL [= url/path =] |urlPath:string|,
        run these steps:
        <ol>
          <li>
            Let |ndef| be the notation for the <a>NDEF record</a> to
            be created by the UA.
          </li>
          <li>
            Set |ndef|'s <a>SR field</a> to `1` (short record).
          </li>
          <li>
            Set |ndef|'s <a>IL field</a> to `0` (no <a>ID LENGTH field</a> and <a>ID field</a>).
          </li>
          <li>
            Set |ndef|'s <a>CF field</a> to `0` (no chunked record).
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `4` (<a>external type record</a>).
          </li>
          <li>
            Set |ndef|'s <a>TYPE field</a> to "`w3.org:A`".
          </li>
          <li>
            Set |ndef|'s PAYLOAD to the result of invoking
            <a>create a message author</a> given |urlPath|.
            If this throws an exception, re-[= exception/throw =] it.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </p>
      </section>

      <section><h3>Creating a message author</h3>
      <p>
        To <dfn>create a <a>message author</a></dfn> given URL [= url/path =] |urlPath:string|,
        run these steps:
        <ol class=algorithm>
          <li>
            Let |origin| be the <a>current settings object</a>'s origin.
          </li>
          <li>
            Let |author| be |origin|'s host,
            <a data-cite="url#concept-host-serializer">serialized</a>.
          </li>
          <li>
            Append |urlPath| to |author|.
          </li>
          <li>
            Let |urlRecord| be the result of
            <a data-lt="url parser">parsing</a> |author| with "`https://`" prepended.
          </li>
          <li>
            If |urlRecord| is failure, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Return |author|.
          </li>
        </ol>
      </p>
      </section>
    </section> <!-- push() -->

  </section> <!-- Writing or pushing content -->

  <section> <h3>Listening for content</h3>
    <p>
      To listen for <a>NFC content</a>, the client MUST activate an
      {{NFCReader}} instance by calling <a>NFCReader.scan()</a>. When attaching
      an event listener for the "`reading`" event on it, <a>NFC content</a> is
      accessible to the client.
    </p>
    <p>
      Each {{NFCReader}} can filter the <a>NFC content</a> based on
      data type, and the URL [= url/path =] of the
      <a>browsing context</a> which has been saved to the <a>author type record</a>
      of the <a>NFC content</a>.
    </p>
    <p>
      If you filter by URL [= url/path =], that means it will be matched against
      the <a>author type record</a>, thus the presence of such is required.
      If you don't filter by URL [= url/path =], then all NFC devices are accepted.
    </p>
    <p>
      The latter is matched against the <a>URL pattern</a>s associated with
      the <a>activated reader objects</a>.
    </p>

    <section> <h3>Match patterns</h3>
      <p>
        A <dfn>match pattern</dfn> is defined by the following ABNF:
        <pre class="abnf">
          match-pattern  = top-level-type "/" [ tree "." ] subtype [ "+" suffix ] [ ";" parameters ]
          top-level-type = "*" / &lt; VCHAR except "/" and "*" &gt;
          subtype        = "*" / &lt; VCHAR except "+" &gt;
        </pre>
        A <a>match pattern</a> is a
        <a href="http://pubs.opengroup.org/onlinepubs/007904875/utilities/xcu_chap02.html#tag_02_13_03">
        glob</a> used for matching <a>MIME type</a>s,
        for instance the pattern "`application/*+json`" matches
        "`application/calendar+json`", but does not match
        "`application/json`". The pattern
        "`*/*json`", on the other hand, matches both.
      </p>
    </section>
    <section> <h3>URL patterns</h3>
        A <dfn>URL pattern</dfn> is a <a>URL record</a> that can be used to match
        the <a>message author</a> of a <a>Web NFC message</a>.
        A <dfn>valid URL pattern</dfn> is a valid <a>URL record</a> whose
        [= url/scheme =] component is equal to "`https`".

      <p>
        A <a>URL pattern</a>'s [= url/scheme =], [= url/host =]
        and [= url/path =] components that are used by the
        <a href="#dfn-match-message-author-with-url-pattern">URL pattern match algorithm</a>
        have the following matching rules:

        <table class="simple">
          <tr>
            <th><strong>URL pattern component</strong></th>
            <th><strong>Matching rule for message author</strong></th>
          </tr>
          <tr>
            <td>[= url/host =]</td>
            <td>
              exact match or ends with (<a>URL pattern</a>'s
              [= url/host =] prepended
              with "`.`").
            </td>
          </tr>
          <tr>
            <td>[= url/path =]</td>
            <td>
              If <a>URL pattern</a>'s path is "`/*`", match any
              <a>message author</a> path. Otherwise, begins with <a>URL pattern</a>'s
              [= url/path =].
            </td>
          </tr>
        </table>
      </p>

      <p class="note">
        For example, '`https://mydomain.com/*`' will match
        '`https://service.mydomain.com/myapp/`' and
        '`https://info.mydomain.com/general/`', while
        '`https://app.mydomain.com/contacts`' will match
        '`https://app.mydomain.com/contacts`' and
        '`https://app.mydomain.com/contacts/all`'

        The '`*`' is a valid character for the URL path component,
        therefore,
        '`https://www.mydomain.com/*`' pattern will match both
        '`https://www.mydomain.com/*`' and
        '`https://www.mydomain.com/service`' URLs.
      </p>
    </section>

    <section> <h3>URL pattern match algorithm</h3>
        To <dfn>match message author with URL pattern</dfn> for a given
        <a>message author</a> and <a>URL pattern</a>, run
        these steps:
        <ol class=algorithm>
          <li>
            Let |raw author| be a <a>message author</a> passed to this algorithm.
          </li>
          <li>
            Let |raw pattern| be a <a>URL pattern</a> passed to this algorithm.
          </li>
          <li>
            If |raw author| and |raw pattern| are empty <a>string</a>s,
            return `true`.
          </li>
          <li>
            Let |author| be the result of running the
            <a>basic URL parser</a> on |raw author|.
          </li>
          <li>
            If |author| is failure, return `false`.
          </li>
          <li>
            Let |pattern| be the result of running the
            <a>basic URL parser</a> on |raw pattern|.
          </li>
          <li>
            If |pattern| is failure, return `false`.
          </li>
          <li>
            Let |subdomain pattern| be the result of prepending "`.`"
            to |pattern|'s [= url/host =].
          </li>
          <li>
            If |author|'s [= url/host =] does not end with
            |subdomain pattern| and |author|'s
            [= url/host =] is not equal to |pattern|'s
            [= url/host =], return `false`.
          </li>
          <li>
            If |pattern|'s [= url/path =] is equal to
            "`/*`", return `true`.
          </li>
          <li>
            If |author|'s [= url/path =] begins with
            |pattern|'s [= url/path =],
            return `true`.
          </li>
          <li>
            Otherwise, return `false`.
          </li>
        </ol>
    </section>

    <section> <h3>The <strong>scan()</strong> method</h3>
      <p>
        The section [[[#steps-receiving]]] uses {{NFCReader}} instances to match
        incoming <a>NFC content</a>.
      </p>
      <p>
        Multiple consecutive calls to the <a data-link-for="NFCReader">scan()</a>
        method from the same <a>origin</a> create filters which are in OR relationship.
      </p>
      <p>
        When the <dfn>NFCReader.scan</dfn> method is invoked, the UA
        MUST run the following
        <dfn id="steps-listen">NFC listen algorithm</dfn>:
        <ol class=algorithm>
          <li>
            Let |reader:NFCReader| be the {{NFCReader}} instance.
          </li>
          <li>
            Let |options| be first argument.
          </li>
          <li>
            [= list/For each =] |key|  |value| of |options|:
            <ol>
              <li>
                If |key| equals "`signal`", set
                |reader|.[[\Signal]] to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`url`", set
                |reader|.[[\Url]] to |value|, prepended with "`https://`".
              </li>
              <li>
                Otherwise, if |key| equals "`recordType`", set
                |reader|.[[\RecordType]] to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`mediaType`", set
                |reader|.[[\MediaType]] to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`compatibility`", set
                |reader|.[[\Compatibility]] to |value|.
              </li>
            </ol>
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection cannot
            be established, then
            <ol>
              <li>
                Let |e| be the result of [= exception/create =] a
                {{"NotSupportedError"}} {{DOMException}}.
              </li>
              <li>
                <a>Fire an event</a> named "`error`" at |reader|
                using <a>NFCErrorEvent</a> with its error attribute
                initialized to |e|.
              </li>
              <li>
                Return.
              </li>
            </ol>
          </li>
          <li>
            If the UA is not allowed to access the underlying <a>NFC Adapter</a>
            (e.g. a user preference), then
            <ol>
              <li>
                Let |e| be the result of [= exception/create =] a
                {{"NotReadableError"}} {{DOMException}}.
              </li>
              <li>
                <a>Fire an event</a> named "`error`" at |reader|
                using <a>NFCErrorEvent</a> with its error attribute
                initialized to |e|.
              </li>
              <li>
                Return.
              </li>
            </ol>
          </li>
          <li>
            If |reader|.[[\Signal]]s [= AbortSignal/aborted flag =] is set, then return.
          </li>
          <li>
            If |reader|.[[\Signal]] is not `null`, then
            <a data-cite="dom#abortsignal-add">add the following abort steps</a> to |reader|.[[\Signal]]:
            <ol>
              <li>
                Remove the {{NFCReader}} instance from the <a>activated reader objects</a>.
              </li>
              <li>
                If the <a>activated reader objects</a> [= list/is empty =], then make a request
                to stop listening to <a>NDEF message</a>s on all <a>NFC adapter</a>s.
              </li>
            </ol>
          </li>
          <li>
            Run the following steps <a>in parallel</a>:
            <ol>
              <li>
                If the <a>obtain reading permission</a> steps return
                `false`, then
                <ol>
                  <li>
                    Let |e:DOMException| be the result of [= exception/create =] a
                    {{"NotAllowedError"}} {{DOMException}}.
                  </li>
                  <li>
                    <a>Fire an event</a> named "`error`" at |reader|
                    using <a>NFCErrorEvent</a> with its error attribute
                    initialized to |e|.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                If this is the first listener being set up, then make a request to
                all <a>NFC adapter</a>s to listen to <a>NDEF message</a>s.
              </li>
              <li>
                If the request fails, then the UA may run the following sub-steps:
                <ol>
                  <li>
                    Let |e:DOMException| be the result of [= exception/create =] a
                    {{"NotSupportedError"}} {{DOMException}}.
                  </li>
                  <li>
                    <a>Fire an event</a> named "`error`" at |reader|
                    using <a>NFCErrorEvent</a> with its error attribute
                    initialized to |e|.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                If the |reader|.[[\Url]] is not an empty <a>string</a>
                and it is not a <a>valid URL pattern</a>, then
                <ol>
                  <li>
                    Let |e:DOMException| be the result of [= exception/create =] a
                    {{"SyntaxError"}} {{DOMException}}.
                  </li>
                  <li>
                    <a>Fire an event</a> named "`error`" at |reader|
                    using <a>NFCErrorEvent</a> with its error attribute
                    initialized to |e|.
                  </li>
                  <li>
                    Return.
                  </li>
                </ol>
              </li>
              <li>
                Add |reader| to the <a>activated reader objects</a>.
              </li>
              <li>
                If the {{Document}} of the <a>top-level browsing context</a> is not
                <a>visible and focused</a> (e.g. the user navigated
                to another page), then the registered <a>activated reader objects</a>
                still SHOULD continue to exist, but SHOULD become paused, i.e. the UA
                SHOULD NOT check and use them until the {{Document}} is
                <a>visible and focused</a> again.
              </li>
            </ol>
          </li>
        </ol>
      </p>
      <p>
        To <dfn>obtain reading permission</dfn>, run these steps:
        <ol>
          <li>
            If there is a <a>prearranged trust relationship</a>,
            return `true`.
          </li>
          <li>
            Otherwise, if the user has earlier denied permission for the calling
            <a>origin</a> for all future calls of
            <a data-link-for="NFCReader">scan()</a>
            as well, then return `false`.
          </li>
          <li>
            Otherwise, UAs SHOULD <a>ask for forgiveness</a> with relevant
            information displayed to the user.
            <p class="note">
              The <a>ask for forgiveness</a> interaction
              might show choices like "block now" or "block forever", etc.
              If the user has chosen to "block forever" the given
              <a>origin</a>, it is the responsibility of the UA to remember
              these user choices for each <a>origin</a>, regardless of which
              <a>NFC adapter</a> is used, and consult them on later invocations.
            </p>
            <p class="note">
             In this step UAs are advised to notify users about
             that reading <a>NFC content</a> may indirectly reveal the physical
             location of the user.
            </p>
          </li>
          <li>
            Return `true`.
          </li>
        </ol>
      </p>
    </section>

  </section>

  <section id="steps-receiving">
  <h3>Receiving and parsing content</h3>
  <p>
    If there are any {{NFCReader}} instances in <a>activated reader objects</a>
    then UAs MUST listen to <a>NDEF message</a>s, according to step 3
    of the <a href="#steps-listen">NFC listen algorithm</a>.
  </p>

  <section><h3>Parsing NDEF well-known `T` records</h3>
  <p>
    To <dfn>parse a NDEF text record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Let |header:byte| be the first <a>byte</a> of |ndefRecord|'s
        <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |languageLength:octed| be the value given by bit `5`
        to bit `0` of the |header|.
      </li>
      <li>
        Let |language:string| be the result of running <a>ASCII decode</a>
        on second <a>byte</a> to the |languageLength| + `1` byte, inclusive.
      <li>
        Let |mimeType| be a <a>MIME type</a>
        with type "`text`", subtype "`plain`" and parameters
        equal to an empty ordered map.
      </li>
      <li>
        Set |mimeType|'s parameters["`lang`"] to |language|.
      </li>
      <li>
        Set |record|'s recordType to "`text`".
      </li>
      <li>
        Set |record|'s mediaType to the result of
        <a>serialize a MIME type</a> with |mimeType| as
        the input.
      </li>
      <li>
        Set |record|.[[\PayloadData]] to the
        <a>byte sequence</a> of |ndefRecord|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        return |record|.
      </li>
    </ol> <!-- parsing NDEF text record -->
  </p>
  <p class="note" data-link-for="NDEFRecord">
    Using the <a data-cite="encoding#encoder">encoder</a>, it is only possible
    to encode as UTF-8, unless you do the encoding manually
    and use the "{{opaque}}" {{recordType}}, which
    allows you to write any opaque data.
    <br><br>
    When you write a <a>string</a> to the "{{text}}"
    {{recordType}}, it will be written as UTF-8.
    External applications have the ability to additionally encode
    this field as UTF-16BE, but that is transparent from the use
    of the {{NFCReader}} which will always return the data
    as a <a>string</a>.
    <br><br>
    As external applications may have encoded the "{{opaque}}"
    {{recordType}} using a different
    encoding, which can be decoded using [[[ENCODING]]] if you know
    the encoding.
  </p>
  </section>

  <section><h3>Parsing NDEF well-known `U` records</h3>
  <p>
    To <dfn>parse a NDEF URL record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Set |record|'s recordType to "`url`".
      </li>
      <li>
        Set |record|'s mediaType to "`text/plain`".
      </li>
      <li>
        Let |prefixByte:byte| be the value of the first <a>byte</a> of
        |ndefRecord|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        If |prefixByte| is not `0`, then match the |prefixByte| against
        the prefix codes in [[[NFC-STANDARDS]]],
        URI Record Type Definition specification, Section 3.2.2.
      </li>
      <li>
        Let |prefixString:string| be the matched prefix or else the
        <a href="#dfn-empty">empty</a> <a>string</a>.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a> from the second <a>byte</a>
        to the end.
      </li>
      <li>
        Set |record|.[[\PayloadData]] to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol> <!-- parsing NDEF URL record -->
  </p>
  </section>

  <section><h3>Parsing NDEF well-known `Sp` records</h3>
  <p>
    To <dfn>parse a NDEF smart-poster record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm>
      <li>
        Set |record|'s recordType to "`smart-poster`".
      </li>
      <li>
        Set |record|'s mediaType to "".
      </li>
      <li>
        Set |record|.[[\PayloadData]] to the
        <a>byte sequence</a> of |ndefRecord|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        return |record|.
      </li>
    </ol>  <!-- parsing NDEF smart-poster record -->
  </p>
  </section>

  <section><h3>Parsing NDEF MIME type records</h3>
    <p>
      To <dfn>parse a NDEF MIME type record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Let |mimeType| be the <a>MIME type</a>
          returned by running <a>parse a MIME type</a>
          on |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          If |mimeType| is a <a>JSON MIME type</a>, then
          <ol>
            <li>
              Set |record|'s recordType to "`json`".
            </li>
            <li>
              Set |record|'s mediaType to the result of
              <a>serialize a MIME type</a> with |mimeType| as
              the input.
            </li>
            <li>
              Set |record|.[[\PayloadData]] to the
              <a>byte sequence</a> of |ndefRecord|'s <a>PAYLOAD field</a>.
            </li>
          </ol>
        </li>
        <li>
          Otherwise,
          <ol>
            <li>
              Set |record|'s recordType to "`opaque`".
            </li>
            <li>
              Set |record|'s mediaType to the result of
              <a>serialize a MIME type</a> with |mimeType| as
              the input.
            </li>
            <li>
              Set |record|.[[\PayloadData]] to the
              <a>byte sequence</a> of |ndefRecord|'s <a>PAYLOAD field</a>.
            </li>
          </ol>
        </li>
        <li>
          return |record|.
        </li>
      </ol> <!-- parsing NDEF MIME type record -->
    </p>
  </section>

  <section><h3>Parsing NDEF absolute-URL records</h3>
    <p>
      To <dfn>parse a NDEF absolute-URL record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Set |record|'s recordType to "`url`".
        </li>
        <li>
          Set |record|'s mediaType to "`text/plain`".
        </li>
        <li>
          Set |record|.[[\PayloadData]] to the
          value of |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF absolute URI record -->
    </p>
  </section>

  <section><h3>Parsing NDEF external type records</h3>
    <p>
      To <dfn>parse a NDEF external type record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Set |record|'s recordType to the value of |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          Set |record|'s mediaType to "`application/octet-stream`".
        </li>
        <li>
          Set |record|.[[\PayloadData]] to the
          <a>byte sequence</a> of |ndefRecord|'s <a>PAYLOAD field</a>.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF external type record -->
    </p>
  </section>

  <section><h3>Parsing NDEF unknown type records</h3>
    <p>
      To <dfn>parse a NDEF unknown record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm>
        <li>
          Set |record|'s recordType to "`opaque`".
        </li>
        <li>
          Set |record|.[[\PayloadData]] to the
          <a>byte sequence</a> of |ndefRecord|'s <a>PAYLOAD field</a>.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF unknown record -->
    </p>
  </section>

  <section><h3>The NFC reading algorithm</h3>
    When the <a>UA</a> is to <dfn>receive NFC content</dfn> it MUST run the
    following algorithm:
    <p class="note">
       The UA SHOULD represent an unformatted <a>NFC tag</a> as an
       <a>NDEF message</a> containing a single empty <a>NDEF record</a>.
    </p>
    <ol class=algorithm id="parse-ndef">
      <li>
        If <a>NFC is suspended</a>, abort these steps.
      </li>
      <li>
        Let |compatibility:NDEFCompatibility| be "`vendor`" if the read NDEF
        compatible device is not officially supported by the NFC Forum, or else
        "`nfc-forum`".
      </li>
      <li>
        Let |message:NDEFMessage| be a new <a>NDEFMessage</a> object, with
        |message|'s url set to `null` and
        |message|'s records set to the empty <a>list</a>.
      </li>
      <li>
        Let |serialNumber:serialNumber| be the device identifier as a series of
        numbers, or `null` if unavailable.
      </li>
      <li>
        If |serialNumber| is not `null`, set it to the
        <a>string</a> of U+003A (`:`) concatenating each number represented as
        <a>ASCII hex digit</a>, in the same order.
      </li>
      <li>
        Let |input| be the notation for the <a>NDEF message</a>
        which has been received.
      </li>
      <li>
        [= list/For each =] <a>NDEF record</a> which is part of |input|, run the
        following sub-steps:
        <ol>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a>.
          </li>
          <li>
            Let |record:NDEFRecord| be a new <a>NDEFRecord</a> object.
          </li>
          <li>
            If |ndef|'s <a>TNF field</a> is `0` (<a>empty record</a>), then set
            |record|'s recordType to "`empty`" and set |record|'s mediaType to `""`.
          </li>
          <li>
            If |ndef|'s <a>TNF field</a> is `1` (<a>well-known type record</a>):
            <ol>
              <li>
                Set |record| to the result of the algorithm below switching on |ndef|'s <a>TYPE field</a>:
                <dl>
                  <dt>"`T`" (`0x54`)</dt>
                  <ul>
                    <li>
                      running <a>parse a NDEF text record</a> on |ndef|.
                    </li>
                  </ul>
                  <dt>"`U`" (`0x55`)</dt>
                  <ul>
                    <li>
                      running <a>parse a NDEF URL record</a> on |ndef|
                    </li>
                  </ul>
                  <dt>"`Sp`" (`0x53` `0x70`)</dt>
                  <ul>
                    <li>
                      running <a>parse a NDEF smart-poster record</a> on |ndef|
                    </li>
                  </ul>
                </dl>
              </li>
            </ol>
          </li>
          <li>
            If |ndef|'s <a>TNF field</a> is `2` (<a>MIME type record</a>), then
            set |record| to the result of running <a>parse a NDEF MIME type record</a>
            on |ndef|, or make sure that the underlying platform provides equivalent
            values to the |record| object's properties.
          </li>
          <li>
            If |ndef|'s <a>TNF field</a> is `3` (<a>absolute-URL record</a>), then
            set |record| to the result of running <a>parse a NDEF absolute-URL record</a>
            on |ndef|.
          </li>
          <li>
            If |ndef|'s <a>TNF field</a> is `4` and
            |ndef|'s lowercased <a>TYPE field</a> is "`w3.org:a`" (<a>author type record</a>),
            then set |message|'s url to the |ndef|'s <a>PAYLOAD field</a>.
          </li> <!-- parsing author type record -->
          <li>
            Otherwise, if |ndef|'s <a>TNF field</a> is `4` (<a>external type record</a>),
            then set |record| to the result of running <a>parse a NDEF external type record</a>
            on |ndef|, or make sure that the underlying platform provides equivalent values
            to the |record| object's properties.
          <li>
            Otherwise, if |ndef|'s <a>TNF field</a> is `5` (<a>unknown record</a>)
            then set |record| to the result of running <a>parse a NDEF unknown record</a>
            on |ndef|, or make sure that the underlying platform provides equivalent values
            to the |record| object's properties.
          <li>
            Otherwise, skip to the next <a>NDEF record</a> in |input|.
          </li>
          <li>
            <a>Append</a> |record| to |message|'s records.
          </li>
        </ol>
      </li>
      <li>
        If <a href="#nfc-is-suspended">NFC is not suspended</a> and
        |message|'s records [= list/is not empty =], run the
        <a>dispatch NFC content</a> steps with given |serialNumber|,
        |message| and |compatibility|.
      </li>
    </ol>
    </section>

    <section data-link-for="NFCReadingEvent"><h3>Dispatching NFC content</h3>
    <p>
      To <dfn>dispatch NFC content</dfn> given a |serialNumber:serialNumber|
      of type <a>serialNumber</a>, |message:NDEFMessage|
      of type <a>NDEFMessage</a> and |compatibility:NDEFCompatibility| of type
      <a>NDEFCompatibility</a>, run these steps:
    </p>
    <ol class=algorithm>
      <li>
        [= list/For each =] {{NFCReader}} instance |reader:NFCReader| in
        the <a>activated reader objects</a>, run the following sub-steps:
        <ol>
          <li>
            Let |match:boolean| be the result of running
            <a href="#dfn-match-message-author-with-url-pattern">URL pattern match</a>,
            with |reader|.[[\Url]] as the <a>URL pattern</a> and
            |message|'s url as the <a>message author</a>.
          </li>
          <li>
            If |match| is `false`, [= iteration/continue =].
          </li>
          <li>
            If |reader|.[[\RecordType]] is [= dictionary member/present =]
            and it is not equal to any |record:NDEFRecord|.[[\RecordType]] where |record|
            is an element of |message|, [= iteration/continue =].
          </li>
          <li>
            If |reader|.[[\MediaType]] is not `""` and
            it is not equal to any |record|'s mediaType where |record| is
            an element of |message|, [= iteration/continue =].
          </li>
          <li>
            If |reader|.[[\Compatibility]] is not "`any`", and
            not equal to |compatibility|, [= iteration/continue =].
          </li>
          <li>
            <a>Fire an event</a> named "`reading`" at |reader|
            using <a>NFCReadingEvent</a> with its <a>serialNumber</a> attribute
            initialized to |serialNumber| and <a>message</a> attribute
            initialized to |message|.
          </li>
        </ol>
      </li>
    </ol>
    </section>
  </section> <!-- receiving content -->
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>

<!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
<section> <h2>Acknowledgments</h2>
  <p>
    The editors would like to thank Jeffrey Yasskin, Anne van Kesteren,
    Anssi Kostiainen, Domenic Denicola, Daniel Ehrenberg, Jonas Sicking,
    Don Coleman, Salvatore Iovene, Rijubrata Bhaumik, Wanming Lin, and
    Franois Beaufort for their contributions to this document.
  </p>
  <p>
    Special thanks to Luc Yriarte and Samuel Ortiz for their initial
    <a href="https://github.com/w3c/nfc">work</a>
    on exposing NFC to the web platform, and for their support for the current
    approach.
</section>

</body>
</html>
