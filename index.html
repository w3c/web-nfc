<!DOCTYPE html>
<html>
<head>
  <title>Web NFC</title>
  <meta charset="UTF-8">
  <link href="https://raw.githubusercontent.com/google/material-design-icons/master/device/2x_web/ic_nfc_black_48dp.png" rel="icon">
  <script type="module" src="ndef-record.js"></script>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' async class=
  'remove'></script>
  <script class="remove">
    var respecConfig = {
      specStatus: "CG-DRAFT",
      shortName: "web-nfc",
      editors: [
        {
          name: "Kenneth Rohde Christiansen",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
        {
          name: "Zoltan Kis",
          company: "Intel",
          companyURL: "https://intel.com/"
        },
        {
          name: "Fran√ßois Beaufort",
          company: "Google LLC",
          companyURL: "https://google.com/"
        },
      ],
      formerEditors: [
        {
          name: "Alexander Shalamov",
          company: "Intel",
          companyURL: "https://intel.com/",
        },
      ],
      testSuiteURI: "https://wpt.fyi/web-nfc/",
      wg: "Web NFC Community Group",
      wgURI: "https://www.w3.org/community/web-nfc/",
      github: "w3c/web-nfc",
      xref: "web-platform",
      localBiblio: {
        "NFC-SECURITY": {
          href: "https://github.com/w3c/web-nfc/security-privacy.html",
          title: "Web NFC Security and Privacy",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-USECASES": {
          href: "https://github.com/w3c/web-nfc/use-cases.html",
          title: "Web NFC Use Cases",
          publisher: "W3C",
          date: "25 April 2015",
        },
        "NFC-STANDARDS": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Technical Specifications",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-NDEF": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Data Exchange Format (NDEF) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NFC-RTD": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Record Type Definition (RTD) Technical Specification",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NDEF-TEXT": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Text Record Type Definition",
          publisher: "NFC Forum",
          date: "14 August 2013",
        },
        "NDEF-URI": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum URI Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NDEF-SMARTPOSTER": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Smart Poster Record Type Definition",
          publisher: "NFC Forum",
          date: "24 July 2006",
        },
        "NDEF-SIGNATURE": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Signature Record Type Definition",
          publisher: "NFC Forum",
          date: "18 November 2010",
        },
        "NFC-HANDOVER": {
          href: "http://members.nfc-forum.org/specs/spec_list/",
          title: "NFC Forum Connection Handover Technical Specification",
          publisher: "NFC Forum",
          date: "16 January 2014",
        },
        "ISO-639.2": {
          href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
          title: "Codes for the Representation of Names of Languages",
          publisher: "ISO",
          date: "18 March 2014",
        },
      },
    };
  </script>
  <style>
    table.simple { border: 1px solid #000; }
    table.simple td { border-right: 1px solid #000; }
  </style>
</head>

<body data-cite="MIMESNIFF SECURE-CONTEXTS PERMISSIONS ENCODING PAGE-VISIBILITY">

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz.

    The hardware standard is defined in [[[NFC-STANDARDS]]].
  </p>
  <p>
    This document defines an API to enable selected use-cases based on
    NFC technology. The current scope of the specification is <a>NDEF</a>.
    Other NFC technologies may be supported in the future.
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered
    unstable.
    Implementers who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This document defines conformance criteria that apply to a single
    product: the <dfn>UA</dfn> (user agent) that implements the interfaces it
    contains.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <div>
    NFC user scenarios can be grouped as follows:
    <ul>
      <li>
        Hold a device in close proximity to a passively powered tag, such as
        a plastic card or sticker, in order to read and/or write data.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to push data from one device to the other.
      </li>
      <li>
        Hold two active devices, e.g. phones or tablets, in close proximity
        in order to initiate a connection using another wireless carrier such
        as Bluetooth or WiFi.
      </li>
      <li>Card emulation
       <ol>
        <li>
          With a secure element: make payments by holding a phone close to a
          point-of-sales terminal.
        </li>
        <li>
          With host card emulation (HCE): for allowing use-cases like using a
          phone acting as a hotel room keycard.
        </li>
       </ol>
      </li>
    </ul>
  </div>
  <p>
    NFC works using magnetic induction, meaning that the reader (an active,
    powered device) will emit a
    small electric charge which then creates a magnetic field. This field powers
    the passive device which turns it into electrical impulses to communicate
    data. Thus, when the devices are within range, a read is always performed
    (see NFC Analog Specification and NFC Digital Protocol, NFC Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, then later to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As NFC is based on existing RFID standards, many NFC chipsets support
    reading RFID tags, but some of these are only supported by single
    vendors and not part of the NFC standards. As such, this document
    specifies ways to interact with the NFC Data Exchange Format (NDEF).
  </p>
</section> <!-- Introduction -->

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology and conventions</h2>
  <p>
    The Augmented Backus-Naur Form (ABNF) notation used is specified in
    [[RFC5234]].
  </p>
  <p>
    <b>NFC</b> stands for Near Field Communications, a short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See <a href="https://www.nfc-forum.org/specs/spec_list/">
    NFC Forum Technical Specifications</a> for a complete
    listing.
  </p>
  <p>
    An <dfn>NFC adapter</dfn> is the software entity in the underlying
    platform which provides access to NFC functionality implemented in a
    given hardware element (NFC chip). A device may have multiple NFC
    adapters, for instance a built-in one, and one or more attached via USB.
  </p>
  <div>
    An <dfn>NFC tag</dfn> is a passive NFC device.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. An <a>NFC tag</a> that supports <a>NDEF</a>
    contains a single <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. They may also expose an <a>NDEF</a> message.
    </p>
  </div>
  <p>
    An <dfn>NFC peer</dfn> is an active, powered device which can interact
    with other devices in order to exchange data using NFC.
  </p>
  <p>
    An <dfn>NFC device</dfn> is either an <a>NFC peer</a>, or an <a>NFC tag</a>.
  </p>
  <p>
    <dfn>NDEF</dfn> is an abbreviation for NFC Forum Data Exchange Format, a
    lightweight binary message format that is standardized in [[!NFC-NDEF]].
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. NDEF messages can be stored on an <a>NFC tag</a> or
    exchanged between NFC-enabled devices.
  </p>
  <p>
    The term <dfn>NFC content</dfn> denotes all bytes sent to or received from
    an <a>NFC tag</a> or an <a>NFC peer</a>. In the current API it is synonym
    to <a>NDEF message</a>.
  </p>
</section> <!-- Terminology -->


<section class="informative">
  <h2>The NFC Standard</h2>
  <p>
    NFC is standardized in the NFC Forum and described in [[NFC-STANDARDS]].
  </p>
  <section class="informative"> <h3>NDEF compatible tag types</h3>
    <p>
      The NFC Forum has mandated the support of five different tag types to be
      operable with NFC devices. The same is required on operating systems, such
      as Android.
    </p>
    <p>
      In addition to that, the <a>MIFARE Standard</a> specifies a way
      for NDEF to work on top of the older <a>MIFARE Standard</a>, which may
      be optionally supported by implementers.
    </p>
    <p>
      A note about the NDEF mapping can be found here:
      <a href="https://www.nxp.com/docs/en/application-note/AN1305.pdf">
      MIFARE Classic as NFC Type MIFARE Classic Tag</a>
    </p>
    <div>
      <ol>
        <li>
          <dfn>NFC Forum Type 1</dfn>: This tag is based on the ISO/IEC 14443-3A
          (NFC-A). The tags are rewritable and can be
          configured to become read-only. Memory size can be between `96` bytes and
          `2` Kbytes. Communication speed is `106` kbit/sec. In contrast to all other
          types, these tags have no anti-collision protection for dealing with multiple
          tags within the NFC field.
        </li>
        <li>
          <dfn>NFC Forum Type 2</dfn>: This tag is based on the
          ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
          to become read-only. Memory size can be between `48` bytes and `2` Kbytes.
          Communication speed is `106` kbit/sec.
        </li>
        <li>
          <dfn>NFC Forum Type 3</dfn>: This tag is based on the Japanese Industrial
          Standard (JIS) X 6319-4 (ISO/IEC 18092), commonly known as FeliCa. The tags are
          preconfigured to be either rewritable or read-only. Memory is `2` kbytes.
          Communication speed is `212` kbit/sec or `424` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 4</dfn>: This tag is based on the ISO/IEC 14443-4 A/B
          (NFC A, NFC B) and thus supports either NFC-A or NFC-B
          for communication. On top of that the tag may optionally support ISO-DEP
          (Data Exchange Protocol defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
          Part 4: Transmission protocol). The tags are preconfigured
          to be either rewritable or read-only. Variable memory, up to `32` kbytes.
          Supports three different communication speeds `106` or `212` or
          `424` kbit/s.
        </li>
        <li>
          <dfn>NFC Forum Type 5</dfn>: This tag is based on ISO/IEC 15693 (NFC-V) and
          allows reading and writing an NDEF message on a ISO/IEC 15693 RF tag
          that is accessible by long range RFID readers as well. The NFC communication
          is limited to short distance and may use the <i>Active Communication Mode</i> of
          ISO/IEC 18092 where the sending peer generates the field which balances
          power consumption and improves link stability. Variable memory, up to `64` kbytes.
          Communication speed `26.48` kbit/s
        </li>
        <li>
          <dfn>MIFARE Standard</dfn>: This tag, often sold under the brand names MIFARE
          Classic or MIFARE Mini, is based on the ISO/IEC 14443-3A (also known as NFC-A,
          as defined in ISO/IEC 14443-3:2011, Part 3: Initialization and anticollision).
          The tags are rewritable and can be configured to become read-only. Memory size
          can be between `320` and `4` kbytes. Communication speed is `106` kbit/sec.
          <p class="note">
            <a>MIFARE Standard</a> is a not an NFC Forum type and can only be read by devices
            using NXP hardware. Support for reading and writing to tags based on the
            <a>MIFARE Standard</a> is thus non-nominative, but the type is included
            due to the popularity and use in legacy systems.
          </p>
        </li>
      </ol>
    </div>
    <p>
      In addition to data types standardized for <a>NDEF record</a>s by the NFC
      Forum, many commercial products such as bus cards, door openers may be based
      on the <a>MIFARE Standard</a> which requires specific NFC chips (same vendor of
      card and reader) in order to function.
    </p>
    <p>
      Card emulation mode capabilities also depend on the NFC chip in the device.
      For payments, a Secure Element is often needed.
    </p>
  </section>

  <section>
  <h3>
    The NDEF record and fields
  </h3>
  <p>
    An <dfn>NDEF record</dfn> is a part of an <a>NDEF message</a>. Each record
    is a binary structure that contains a data payload, as well as associated
    type information. In addition to this, it includes information about how
    the data is structured, like payload size, whether the data is chunked over
    multiple records etc.
  </p>
  <div>
    A generic record looks like the following:
    <ndef-record class="ndef"
      header="*,*,*,*,*,*"
      content="*,PAYLOAD LENGTH - 1 (SR) to 4 bytes,ID LENGTH (optional),TYPE (optional),ID (optional),PAYLOAD (optional)">
    </ndef-record>
  </div>
  <p>
    Only the first three bytes (lines in figure) are mandatory. First the
    header byte, followed by the <a>TYPE LENGTH field</a> and <a>PAYLOAD
    LENGTH field</a>, both of which may be zero.
  </p>
  <div>
    The <dfn>TNF field</dfn> (bit `0-2`, type name format) indicates the format
    of the type name and is often exposed by native NFC software stacks. The
    field can take binary values denoting the following NDEF record payload types:
    <table class="simple">
      <tr>
        <th><strong>TNF value</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td><a>Empty record</a></td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum [=well-known type record=]</td>
      </tr>
      <tr>
        <td>2</td>
        <td><a>MIME type record</a></td>
      </tr>
      <tr>
        <td>3</td>
        <td><a>Absolute-URL record</a></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <a>external type record</a></td>
      </tr>
      <tr>
        <td>5</td>
        <td><a>Unknown record</a></td>
      </tr>
      <tr>
        <td>6</td>
        <td><a>Unchanged record</a></td>
      </tr>
      <tr>
        <td>7</td>
        <td>Reserved for future use</td>
      </tr>
    </table>
  </div>
  <p>
    The <dfn>IL field</dfn> (bit `3`, id length) indicates whether an
    <a>ID LENGTH field</a> is present. If the <a>IL field</a> is `0`, then the
    <a>ID field</a> is not present either.
  </p>
  <p>
    The <dfn>SR field</dfn> (bit `4`, short record) indicates a short record,
    one with a payload length <= `255` bytes. Normal records can have payload
    lengths exceeding `255` bytes up to a maximum of `4` GB. Short records only
    use one byte to indicate length, whether as normal records use `4` bytes
    (`2`<sup>`32`</sup>`-1` bytes).
  </p>
  <p>
    The <dfn>CF field</dfn> (bit `5`, chunk flag) indicates whether the payload
    is <a>chunked</a> across multiple records.
  </p>
  <p class="note">
    Web NFC turns all received chunked records into logical records and
    transparently chunks sent payload when that is needed.
  </p>
  <p>
    The <dfn>ME field</dfn> (bit `6`, message end) indicates whether this record
    is the last in the <a>NDEF message</a>.
  </p>
  <p>
    The <dfn>MB field</dfn> (bit `7`, message begin) indicates whether this
    record is the first of the <a>NDEF message</a>.
  </p>
  <p>
    The <dfn>TYPE LENGTH field</dfn> is an unsigned 8-bit integer that denotes
    the byte size of the <a>TYPE field</a>.
  </p>
  <p>
    The <dfn>TYPE field</dfn> is a globally unique and maintained identifier
    that describes the type of the <a>PAYLOAD field</a> in a structure,
    encoding and format dictated by value of the <a>TNF field</a>.
  </p>
  <p class="note">
    The [[[!NFC-RTD]]] requires that the <a>TYPE field</a> names MUST be
    compared in case-insensitive manner.
  </p>
  <p>
    The <dfn>ID LENGTH field</dfn> is an unsigned 8-bit integer that denotes
    the byte size of the <a>ID field</a>.
  </p>
  <p>
    The <dfn>ID field</dfn> is an identifier in the form of a URI reference
    ([[RFC3986]]) that is unique, and can be absolute of relative (in the
    latter case the application must provide a base URI). Middle and terminating
    chunk records MUST NOT have an <a>ID field</a>, other records MAY have it.
  </p>
  <p>
    The <dfn>PAYLOAD LENGTH field</dfn> denotes the byte size of the
    <a>PAYLOAD field</a>. If the <a>SR field</a> is `1`, its size is one byte,
    otherwise 4 bytes, representing an 8-bit or 32-bit unsigned integer,
    respectively.
  </p>
  <p>
    The <dfn>PAYLOAD field</dfn> carries the application bytes. Any internal
    structure of the data is opaque to NDEF. Note that in certain cases
    discussed later, this field MAY contain an <a>NDEF message</a> as data.
  </p>
  </section>

  <section>
  <h3>
    NDEF Record types
  </h3>
    <section> <h4>Empty NDEF record (TNF 0)</h4>
    <p>
      An <dfn>empty record</dfn>'s' <a>TYPE LENGTH field</a>,
      <a>ID LENGTH field</a> and <a>PAYLOAD LENGTH field</a> MUST be `0`, thus
      the <a>TYPE field</a>, <a>ID field</a> and <a>PAYLOAD field</a> MUST NOT
      be present.
    </p>
    <ndef-record
      header="1,1,0,1,0,0 (EMPTY)"
      content="0,0,_,_,_,_"
      short>
    </ndef-record>
    </section>

    <section>
    <h4>
      Well-known type records (TNF 1)
    </h4>
    <p>
      The NFC Forum has standardized a small set of useful sub record types in
      [[NFC-RTD]] (Resource Type Definition specifications) called
      <dfn>well-known type record</dfn>s, for instance text, URL, media and others.
      In addition, there are record types designed for more
      complex interactions, such as smart posters (containing optional embedded
      records for url, text, signature and actions), and handover records.
    </p>
    <p>
      The type information stored in the <a>TYPE field</a> of
      <a>well-known type records</a> can be of two kinds:
      <a href="#well-known-local-types">local types</a>
      and <a href="#well-known-global-types">global types</a>
    </p>

    <section><h4>Well-known local types</h4>
      <p>
        NFC Forum <dfn>local type</dfn> that are defined by the NFC Forum or
        by an application, and always start with lowercase character or a
        number. Those are usually short strings that are unique only within
        the local context of the containing record. They are used when the
        meaning of the types doesn't matter outside of the local context of the
        containing record and when storage usage is a hard constraint. See
        <a>Smart poster</a> for an example on how local types are used.
      </p>
      <p class="note">
        A [=local type=] is thus defined in terms of a containing record type,
        and thus doesn't need any namespacing. For this reason the same local
        type name can be used within another record type with different meaning
        and different payload type.
      </p>
    </section>
    </section>  <!-- Well-known (TNF 1) types -->

    <section><h4>Well-known global types</h4>
      <p>
        NFC Forum <dfn>global type</dfn>s are defined and managed by the
        NFC Forum and usually start with an uppercase character.
        Examples: "`T`" for text, "`U`" for URL, "`Sp`" for smart poster,
        "`Sig`" for signature, "`Hc`" for handover carrier, "`Hr`" for
        handover request, "`Hs`" for handover select, etc.
      </p>

    <section> <h5>Text record</h5>
      <div>
        The <dfn>Text record</dfn> is a [=well-known type record=] that is defined
        in the [[NDEF-TEXT]] specification.
        The <a>TNF field</a> is `1` and the <a>TYPE field</a> is "`T`" (`0x54`).
        The first byte of the <a>PAYLOAD field</a> is a status byte, followed
        by the [=language tag=] in US-ASCII encoding.
        The rest of the payload is the actual text, encoded either in UTF-8 or
        UTF-16, as indicated by the status byte as follows:
        <ul>
          <li>Bits 0 to 5 define the length of the [=language tag=].</li>
          <li>Bit 6 is `0`.</li>
          <li>
            If bit 7 if set, means the payload is encoded in UTF-8, otherwise in
            UTF-16.
          </li>
        </ul>
      </div>
    </section>

    <section> <h5>URI record</h5>
      <p>
        <dfn>URI record</dfn> is defined in [[NDEF-URI]].
        The <a>TNF field</a> is `1` and the <a>TYPE field</a> is "`U`" (`0x55`).
        The first byte of the <a>PAYLOAD field</a> is a URI identifier code,
        in fact an index in an abbreviation table where the values are prepended
        to the rest of the URI. For instance the value `0` denotes no prepending,
        `1` denotes "`http://www.`", `0x04` denotes "`https://`"" and so on.
        The rest of the payload contains the rest of the URI as a UTF-8 string
        (and if the first byte is `0`, then it denotes the whole URI).
      </p>
      <p>
        The URI is defined in [[RFC3987]] and in fact is a UTF-8 encoded IRI
        that can be a URN or a URL.
      </p>
    </section>

    <section> <h5>Smart poster record</h5>
    <div>
      <dfn>Smart poster</dfn> is defined in [[NDEF-SMARTPOSTER]] to describe a
      given web content as an NDEF record that contains an <a>NDEF message</a>
      as payload, including the following records:
      <ul>
        <li>
          A single mandatory <a>URI record</a> that refers to the
          <a>smart poster</a> content.
        </li>
        <li>
          Zero or more <a>Text records</a> that act as a <dfn>title record</dfn>
          related to the content. When there are more than one title record
          present, they MUST be with different <a>language tags</a>.
          Applications SHOULD select one <a>title record</a> for presentation
          to the end user.
        </li>
        <li>
          Zero or more <a>MIME type records</a> that act as <dfn>icon record</dfn>
          related to the content. The <a>MIME type</a> is usually "`image/jpg`",
          "`image/png`", "`image/gif`", or even "`video/mpeg`".
          Applications SHOULD select one <a>icon record</a> for presentation
          to the end user.
        </li>
        <li>
          One optional <dfn>type record</dfn> that has a [=local type name=]
          "`t`" specific to <a>smart poster</a> and the <a>PAYLOAD field</a>
          contains a UTF-8 encoded MIME type for the content referred to by the
          <a>URI record</a>.
        </li>
        <li>
          One optional <dfn>size record</dfn> that has [=local type name=] "`s`"
          specific to <a>smart poster</a> and the <a>PAYLOAD field</a> contains
          a 4-byte 32 bit unsigned integer that denotes the size of the object
          referred to by the URL in the <a>URI record</a> of the
          <a>smart poster</a>.
        </li>
        <li>
          One optional <dfn>action record</dfn> that has a [=local type name=]
          "`act`" specific to <a>smart poster</a> and the <a>PAYLOAD field</a>
          contains a single byte, whose value has the following meaning:
          <table class="simple">
            <tr>
              <th><strong>Value</strong></th>
              <th><strong>Description</strong></th>
            </tr>
            <tr>
              <td>0</td>
              <td>Do the action</td>
            </tr>
            <tr>
              <td>1</td>
              <td>Save for later</td>
            </tr>
            <tr>
              <td>2</td>
              <td>Open for editing</td>
            </tr>
            <tr>
              <td>3..0xFF</td>
              <td>Reserved for future use</td>
            </tr>
          </table>
          There is no default action on the <a>smart poster</a> content if the
          <a>action record</a> is missing.
          <p class="note">
            At the time of NDEF standardization the value `0` ("do the action") was
            intended for use cases like send an SMS, make a call or launch browser.
            Similarly, the value `1`, ("save the content for later processing") was
            intended for use cases like store the SMS in inbox, save the URL in
            bookmarks, or save the phone number to contacts. Also, the value `2`
            ("open for editing") was meant to open the smart poster content with a
            default application for editing.
          </p>
          <p>
            Implementations don't need to implement any standardized behavior for the
            actions defined here. In this API it's up to the applications what actions
            they define (that may include the use cases above). However, Web NFC
            just provides the values.
          </p>
        </li>
      </ul>
    </div>

    <div>
      The example below shows a smart poster record that embeds a text and a
      URL record.
      <ndef-record
        header="1,1,0,1,0,1 (WELL KNOWN)"
        content="*,*,_,'Sp' (0x53 0x70),_,*"
        short>
        <ndef-record slot="payload"
          header="1,0,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'T' (0x54),_,*"
          short noindices>
        </ndef-record>
        <ndef-record slot="payload"
          header="0,1,0,1,0,1 (WELL KNOWN)"
          content="TYPE LENGTH (1 byte),*,_,'U' (0x55),_,*"
          short noindices>
        </ndef-record>
      </ndef-record>
    </div>
    </section>

    <section> <h5>Signature records</h5>
    <p>
      <dfn>NDEF Signature</dfn> is defined [[NDEF-SIGNATURE]].
      Its <a>TYPE field</a> contains "`Sig`" (`0x53`, `0x69`, `0x67`) and its
      <a>PAYLOAD field</a> contains version, signature and a certificate chain.
      In this version of the API, Web NFC only provides the raw byte content
      of the payload (see this
      <a href="https://github.com/w3c/web-nfc/issues/363">issue</a>).
    </p>
    </section>

    <section> <h5>Handover records</h5>
    <p>
      <dfn>NFC handover</dfn> is defined [[NFC-HANDOVER]] and the
      corresponding message structure that allows negotiation and activation of
      an alternative communication carrier, such as Bluetooth or WiFi.
      The negotiated communication carrier would then be used (separately) to
      perform certain activities between the two devices, such as sending photos
      to the other device, printing to a Bluetooth printer or streaming video to
      a television set. Web NFC does not support this at the moment (see this
      <a href="https://github.com/w3c/web-nfc/issues/364">issue</a>.
    </p>
    </section>
    </section> <!-- well-known global types -->

    <section>
    <h4>
      MIME type records (TNF 2)
    </h4>
    <div>
      The <dfn>MIME type record</dfn>s are records that store binary
      data with associated <a>MIME type</a>.
      <ndef-record
        header="*,*,*,*,*,2 (MIME)"
        content="*,*,*,SERIALIZED MIME TYPE,*,MIME TYPE PAYLOAD"
        short>
      </ndef-record>
    </div>
    </section>

    <section>
    <h4>
      Absolute-URL records (TNF 3)
    </h4>
    <p>
      In <dfn>absolute-URL record</dfn>s the <a>TYPE field</a> contains the
      <a>absolute-URL string</a>, and not the payload.
    </p>
    <p class=note>
      NOTE: Some platforms, like Windows Phone have stored additional data
      in the payload, but any payload data in these records are ignored by
      other platforms such as Android. On Android, reading such a record,
      will attempt to load the URL in Chrome and it is as such not intended
      for client applications.
    </p>
    <div>
      <ndef-record
        header="*,*,*,*,*,3 (ABSOLUTE URL)"
        content="*,*,*,ABSOLUTE URL STRING,*,PAYLOAD (optional/ignored)"
        short>
      </ndef-record>
    </div>
    </section>

    <section>
    <h4>
      External type records (TNF 4)
    </h4>
    <p>
      The NFC Forum <dfn data-no-export="">external type record</dfn>s are for
      application specified data types and are defined in [[[NFC-RTD]]].
    </p>
    <p>
      The <dfn>external type</dfn> is a URN with the prefix `"urn:nfc:ext:"` followed by
      the name of the owner [=domain=], adding a `U+003A` (`:`), then a non-zero
      type name, for instance `"urn:nfc:ext:w3.org:atype"`, stored as
      `"w3.org:atype"` in the <a>TYPE field</a>.
    </p>
    <div>
      <ndef-record
        header="*,*,*,*,*,4 (EXTERNAL)"
        content="*,*,*,EXTERNAL TYPE (eg. w3.org:member),*,*"
        short>
      </ndef-record>
    </div>
    </section>

    <section>
    <h4>
      Unknown type records (TNF 5)
    </h4>
    <p>
      The <dfn>unknown record</dfn>s are records that store
      opaque data without associated <a>MIME type</a>, meaning that the
      `application/octet-stream` default <a>MIME type</a> MAY be assumed.
      The [[NFC-NDEF]] specification recommends that <a>NDEF</a> parsers store
      or forward the payload without processing it.
    </p>
    <div>
      <ndef-record
        header="*,*,*,*,*,5 (UNKNOWN)"
        content="0,*,*,_,*,*"
        short>
      </ndef-record>
    </div>
  </section>
  <section>
    <h4>
      Unchanged type records (TNF 6)
    </h4>
    <div>
      The <dfn>unchanged record</dfn>s are record chunks of
      a chunked data set, and is used for any, but the first record.
      A <dfn>chunked</dfn> payload is spread across multiple <a>NDEF record</a>s
      that undergo the following rules:
      <ul>
        <li>
          The initial chunk record has the <a>CF field</a> set, its
          <a>TYPE field</a> set to the type of the whole chunked payload and
          its <a>ID field</a> MAY be set to an identifier used for the whole
          chunked payload. Its <a>PAYLOAD LENGTH field</a> denotes the size of
          the payload chunk in this record only.
        </li>
        <li>
          The middle chunk records have the <a>CF field</a> set, have the
          same <a>ID field</a> as the first chunk, their
          <a>TYPE LENGTH field</a> and <a>IL field</a> MUST be `0` and their
          <a>TNF field</a> MUST be `6` (unchanged).
        </li>
        <li>
          The terminating chunk record has this flag cleared, and in rest
          undergo the same rules as the middle chunk records.
        </li>
        <li>
          A chunked payload MUST be contained in a single <a>NDEF message</a>,
          therefore the initial and middle chunk records cannot have the
          <a>ME field</a> set.
        </li>
      </ul>
    </div>
    <div>
      First record:
      <ndef-record
        header="1,0,1,1,0,*"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Intermediate record:
      <ndef-record
        header="0,0,1,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
      <br>
      Last record:
      <ndef-record
        header="0,1,0,1,0,6 (UNCHANGED)"
        content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
        short>
      </ndef-record>
    </div>
    <p>
      Any implementation of Web NFC MUST transparently expose chunked records
      as single logical records.
    </p>
    </section>
  </section>
</section>  <!-- NFC Standard -->

<section class="informative"> <h3>Use Cases</h3>
  <p>
    A few NFC user scenarios have been enumerated
    <a href="http://www.w3.org/2009/dap/wiki/Near_field_communications_%28NFC%29#Use_cases_submitted_to_DAP_mailing_list">
    here</a> and in the
    <a href="https://w3c.github.io/web-nfc/use-cases.html">Web NFC Use Cases</a>
    document. The basic NFC interactions are the following.
  </p>

  <section> <h3>Reading an <a>NFC tag</a></h3>
    <ol>
      <li>
        Reading an <a>NFC tag</a> containing an <a>NDEF message</a>, when the
        {{Document}} of the <a>top-level browsing context</a> using Web NFC
        is <a>visible</a>. For instance, a web page instructs the user
        to tap an NFC tag, and then receives information from the tag.
      </li>
      <li>
        Reading an <a>NFC tag</a> with non-<a>NDEF</a> technology, e.g. the
        <a>MIFARE Standard</a>, when the {{Document}} of the <a>top-level
        browsing context</a> using Web NFC is <a>visible</a>.
        <p class="note">
          This use case is not supported in this version of the specification.
        </p>
      </li>
      <li>
        Reading an <a>NFC tag</a> when no {{Document}} using Web NFC is
        <a>visible</a>.
        <p class="note">
          This use case is not supported in this version of the specification.
        </p>
      </li>
    </ol>
  </section>

  <section> <h3>Writing to an <a>NFC tag</a></h3>
    <div>
      The user opens a web page which can write an <a>NFC tag</a>. The write
      operations may be one of the following:
      <ol>
        <li>
          Writing to a non-formatted <a>NFC tag</a>.
        </li>
        <li>
          Writing to an empty, but formatted <a>NFC tag</a>.
        </li>
        <li>
          Writing to an <a>NFC tag</a> which already contains a
          <a>NDEF message</a>.
        </li>
        <li>
          Writing to other, writable <a>NFC tag</a>s (i.e. overwriting a
          generic tag).
        </li>
      </ol>
    </div>
    <p class="note">
      Note that an NFC write operation to an <a>NFC tag</a> always involves
      also a read operation.
    </p>
  </section>

  <section> <h3>Pushing data to an <a>NFC peer</a> device</h3>
    <p>
      In general, pushing data to another NFC capable device requires that
      on the initiating device the user would first have to navigate to a web
      site. The user would then touch the device against another Web NFC
      equipped device, and data transfer would occur.
    </p>
    <p>
      On the receiving device the UA will dispatch the content to an application
      registered and eligible to handle the content, and if that application is
      a browser which has a {{Document}} of the <a>top-level browsing context</a>
      <a>visible</a> with active {{NDEFReader}},
      then the content is delivered to the page through the <a>NDEFReadingEvent</a>.
    </p>
  </section>

  <section> <h3>Handover to another wireless connection type</h3>
    <p>
      NFC supports handover protocols to Bluetooth or WiFi connectivity for
      the purpose of larger volume data transfer. The user touches another
      NFC capable device, and as a result configuration data is sent for a
      new Bluetooth or WiFi connection which is then established between the
      devices.
    </p>
    <p class="note">
      This use case is not supported in this version of the specification.
    </p>
  </section>

  <section> <h3>Payment scenarios</h3>
    <p>
      Payment scenarios with Web NFC generally do not refer to supporting
      the payment process itself, but associating the payment status with
      a web page in order to have secondary actions. For instance,
      the user buys goods in a store, and payment options include contactless
      payment using NFC technology.
      In general, touching the device to the point of sales terminal receiver
      area will result in a transaction between the secure element from the
      device and the point of sales terminal. With Web NFC, if the
      user navigates to a web site before paying, there may be interaction
      with that site regarding the payment, e.g. the user could get points and
      discounts, or get delivered application or service specific data (e.g.
      tickets, keys, etc) to the device.
    </p>
    <p class="note">
      This use case is not supported in this version of the specification.
    </p>
  </section>

  <section> <h3>Support for multiple NFC adapters</h3>
    <p>
      Users may attach one or more external <a>NFC adapter</a>s to their
      devices, in addition to a built-in adapter. Users may use either
      <a>NFC adapter</a>.
    </p>
  </section>
</section> <!-- Use Cases -->

<section class="informative"> <h3>Features</h3>
  <div>
    High level features for the Web NFC specification include the following:
    <ol>
      <li>
        Support devices with single or multiple <a>NFC adapter</a>s.
        If there are multiple adapters present when invoking an NFC function
        then the UA operates all <a>NFC adapter</a>s in parallel.
      </li>
      <li>
        Support communication with active (powered devices such as readers,
        phones) and passive (smart cards, tags, etc) devices.
      </li>
      <li>
        Allow users to act on (e.g. read, write or transceive) discovered
        NFC devices (passive and active), as well as access the payload
        which were read in the process as <a>NDEF message</a>s.
      </li>
      <li>
        Allow users to write a payload via <a>NDEF record</a>s to compatible
        devices, such as writable tags, when they come in range, as
        <a>NDEF message</a>s.
      </li>
      <li>
        [future] Allow manual connection for various technologies such as
        NFC-A and NFC-F depending on the secondary device.
      </li>
      <li>
        [future] Allow <a>NFC handover</a> to Bluetooth or WiFi.
      </li>
      <li>
        [future] Allow card emulation with secure element or host card
        emulation.
      </li>
    </ol>
  </div>
</section> <!-- Features -->

<!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>

  <section><h3>Feature support</h3>
    <p>
      Detecting if Web NFC is supported can be done by checking NDEFReader
      and/or NDEFWriter objects. Note that this does not guarantee that NFC
      hardware is available.
    </p>
    <pre class="example">
      if ('NDEFReader' in window) { /* ... Scan NDEF Tags */ }
      if ('NDEFWriter' in window) { /* ... Write NDEF Tags */ }
    </pre>
  </section>

  <section><h3>Push a text string to either a tag or peer</h3>
    <p>
      Pushing a text string to any kind of device is straightforward.
      Options can be left out, as they default to pushing to both tags
      and peers.
    </p>
    <pre class="example">
      const writer = new NDEFWriter();
      writer.push(
        "Hello World"
      ).then(() => {
        console.log("Message pushed.");
      }).catch(error => {
        console.log(`Push failed :-( try again: ${error}.`);
      });
    </pre>
  </section>

  <section><h3>Push a text string to a peer device</h3>
    <p>
      It is possible to restrict to which devices (tags or peers) data
      should be pushed. Below push is specified only to peers,
      and thus, no data is pushed when the user taps a tag.
    </p>
    <pre class="example">
      const writer = new NDEFWriter();
      writer.push(
        "Text intended for peers only", { target: "peer" }
      ).then(() => {
        console.log("Message pushed.");
      }).catch(_ => {
        console.log("Push failed :-( try again.");
      });
    </pre>
  </section>

  <section> <h3>Push a URL to either a tag or peer</h3>
    <p>
      In order to push an NDEF record of URL type, simply use NDEFMessage.
    </p>
    <pre class="example">
      const writer = new NDEFWriter();
      writer.push({
        records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
      }).then(() => {
        console.log("Message pushed.");
      }).catch(_ => {
        console.log("Push failed :-( try again.");
      });
    </pre>
  </section>


  <section> <h3>Handle scanning errors</h3>
    <p>
      This example shows what happens when [=NDEFReader/scan=] promise rejects and
      [=NDEFReader/onerror=] is fired.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      reader.scan().then(() => {
        console.log("Scan started successfully.");
        reader.onerror = event => {
          console.log("Error! Cannot read data from the NFC tag. Try a different one?");
        };
        reader.onreading = event => {
          console.log("NDEF message read.");
        };
      }).catch(error => {
        console.log(`Error! Scan failed to start: ${error}.`);
      });
    </pre>
  </section>

  <section> <h3>Read data from tag, and write to empty ones</h3>
    <p>
      This example shows reading various different kinds of data which can be
      stored on a tag. If the tag is unformatted or contains an empty record,
      a text message is written with the value "Hello World".
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan();
      reader.onreading = event => {
        const message = event.message;

        if (message.records.length == 0 ||     // unformatted tag
            message.records[0].recordType == 'empty' ) {  // empty record
          const writer = new NDEFWriter();
          writer.push({
            records: [{ recordType: "text", data: 'Hello World' }]
          });
          return;
        }

        const decoder = new TextDecoder();
        for (const record of message.records) {
          switch (record.recordType) {
            case "text":
              const textDecoder = new TextDecoder(record.encoding);
              console.log(`Text: ${textDecoder.decode(record.data)} (${record.lang})`);
              break;
            case "url":
              console.log(`URL: ${decoder.decode(record.data)}`);
              break;
            case "mime":
              if (record.mediaType === "application/json") {
                console.log(`JSON: ${JSON.parse(decoder.decode(record.data))}`);
              }
              else if (record.mediaType.startsWith('image/')) {
                const blob = new Blob([record.data], {type: record.mediaType});

                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                img.onload = () => window.URL.revokeObjectURL(this.src);

                document.body.appendChild(img);
              }
              else {
                console.log(`Media not handled`);
              }
              break;
          }
        }
      };
    </pre>
  </section>

  <section> <h3>Save and restore game progress with another device</h3>
    <p>
      Filtering of relevant data sources can be done by the use of
      the <a>NDEFScanOptions</a>. Below we use the custom record identifier
      "`my-game-progress`" as a relative URL so that when we read the data, we
      immediately update the game progress by issuing a push with a custom NDEF
      data layout.
    </p>
    <p>
      The example allows reading and pushing to both peers and tags,
      whichever one is tapped first.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({ id: "my-game-progress" });
      reader.onreading = async event => {
        console.log(`Game state: ${ JSON.stringify(event.message.records) }`);

        const encoder = new TextEncoder();
        const newMessage = {
          records: [{
            id: "my-game-progress",
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              level: 3,
              points: 4500,
              lives: 3
            }))
          }]
        };
        const writer = new NDEFWriter();
        await writer.push(newMessage);
        console.log("Pushed message");
      };
    </pre>
  </section>

  <section> <h3>Push and read JSON (serialized and deserialized)</h3>
    <p>
      Storing and receiving JSON data is easy with serialization and deserialization.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({
        mediaType: "application/*json"
      });
      reader.onreading = event => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          if (record.mediaType === 'application/json') {
            const json = JSON.parse(decoder.decode(record.data));
            const article =/^[aeio]/i.test(json.title) ? "an" : "a";
            console.log(`${json.name} is ${article} ${json.title}`);
          }
        }
      };

      const writer = new NDEFWriter();
      const encoder = new TextEncoder();
      writer.push({
        records: [
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Benny Jensen",
              title: "Banker"
            }))
          },
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Zoey Braun",
              title: "Engineer"
            }))
          }]
      });
    </pre>
  </section>

  <section> <h3>Write data to tag and print out existing data</h3>
    <p>
      Pushing data to a tag requires tapping it. If existing data should be
      read during the same tap, we need to set the [=NDEFPushOptions/ignoreRead=]
      property to `false`.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      reader.scan().then(() => {

        reader.onreading = event => {
          const decoder = new TextDecoder();
          for (const record of event.message.records) {
            console.log("Record type:  " + record.recordType);
            console.log("MIME type:    " + record.mediaType);
            console.log("=== data ===\n" + decoder.decode(record.data));
          }
        };

        const writer = new NDEFWriter();
        return writer.push("Pushing data is fun!", { target: "tag", ignoreRead: false });

      }).catch(error => {
        console.log(`Push failed :-( try again: ${error}.`);
      });
    </pre>
  </section>

  <section> <h3>Stop listening to NDEF messages</h3>
    <p>
      Read NDEF messages for 3 seconds by using [=NDEFScanOptions/signal=].
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      const controller = new AbortController();

      await reader.scan({ signal: controller.signal });
      reader.onreading = event => {
        console.log("NDEF message read.");
      };

      controller.signal.onabort = event => {
        console.log("We're done waiting for NDEF messages.");
      };

      // Stop listening to NDEF messages after 3s.
      setTimeout(() => controller.abort(), 3000);
    </pre>
  </section>

  <section> <h3>Push a smart poster message</h3>
    <pre class="example">
      const writer = new NDEFWriter();
      const encoder = new TextEncoder();
      writer.push({ records: [
        {
          recordType: "smart-poster",  // Sp
          data: { records: [
            {
              recordType: "url",  // URL record for the Sp content
              data: "https://my.org/content/19911"
            },
            {
              recordType: "text",  // title record for the Sp content
              data: "Funny dance"
            },
            {
              recordType: "t",  // type record, a local type to Sp
              isLocal: true,
              data: encoder.encode("image/gif") // MIME type of the Sp content
            },
            {
              recordType: "s",  // size record, a local type to Sp
              isLocal: true,
              data: new Uint32Array([4096]) // byte size of Sp content
            },
            {
              recordType: "act",  // action record, a local type to Sp
              isLocal: true,
              // do the action, in this case open in the browser
              data: new Uint8Array([0])
            },
            {
              recordType: "mime" // icon record, a MIME type record
              mediaType: "image/png",
              data: await (await fetch("icon1.png")).arrayBuffer()
            },
            {
              recordType: "mime" // another icon record
              mediaType: "image/jpg",
              data: await (await fetch("icon2.jpg")).arrayBuffer()
            }
          ]}
        }
      ]});
    </pre>
  </section>

  <section> <h3>Read an external record with an NDEF message as payload</h3>
    <p>
      External type records can be used to create application defined records.
      These records may contain an <a>NDEF message</a> as payload,
      with its own <a>NDEF records</a>, including <a>local types</a> that are
      used in the context of the application.
    </p>
    <p>
      Note that the <a>smart poster</a> record type also contains an
      <a>NDEF message</a> as payload.
    </p>
    <p>
      As NDEF gives no guarantee on the ordering of records, using
      an external type record with an <a>NDEF message</a> as payload,
      can be useful for encapsulating related data.
    </p>
    <p>
      This example shows how to read an external record for social posts,
      which contains an <a>NDEF message</a>, containing a text record and
      a record with the <a>local type</a> "act" (action), with definition
      borrowed from <a>smart poster</a>, but used in local application context.
    </p>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({ recordType: "example.com:smart-poster" });
      reader.onreading = event => {
        const externalRecord = event.message.records.find(
          record => record.type == "example.com:smart-poster"
        );

        let action, text;

        for (const record of externalRecord.toRecords()) {
          if (record.recordType == "text" && !record.isLocal) {
            const decoder = new TextDecoder(record.encoding);
            text = decoder.decode(record.data);
          } else if (record.recordType == "act") {
            action = record.data.getUint8(0);
          }
        }

        switch (action) {
          case 0: // do the action
            console.log(`Post "${text}" to timeline`);
            break;
          case 1: // save for later
            console.log(`Save "${text}" as a draft`);
            break;
          case 2: // open for editing
            console.log(`Show editable post with "${text}"`);
            break;
        }
      };
    </pre>
  </section>

  <section> <h3>Push an external record with an NDEF message as payload</h3>
    <p>
      External type records can be used to create application defined records
      that may even contain an <a>NDEF message</a> as payload.
    </p>
    <pre class="example">
      const writer = new NDEFWriter();
      writer.push({ records: [
        {
          recordType: "example.game:a",
          data: {
            records: [
              {
                recordType: "url",
                data: "https://example.game/42"
              },
              {
                recordType: "text",
                data: "Game context given here"
              },
              {
                recordType: "mime",
                mediaType: "image/png"
                data: getImageBytes(fromURL);
              }
            ]
          }
        }
      ]});
    </pre>
  </section>

  <section> <h3>Push and read unknown records inside an external record</h3>
    <p>
      Unknown type records may be useful inside external type records as
      developers know what they represent and therefore can avoid specifying the
      mime type.
    </p>
    <pre class="example">
      const encoder = new TextEncoder();
      const writer = new NDEFWriter();
      writer.push({ records: [
        {
          recordType: "example.com:shoppingItem", // External record
          data: {
            records: [
              {
                recordType: "unknown", // Shopping item name
                data: encoder.encode("Food")
              },
              {
                recordType: "unknown", // Shopping item description
                data: encoder.encode("Provide nutritional support for an organism.")
              }
            ]
          }
        }
      ]});
    </pre>
    <pre class="example">
      const reader = new NDEFReader();
      await reader.scan({ recordType: "example.com:shoppingItem" });
      reader.onreading = event => {
        const shoppingItemRecord = event.message.records[0];
        if (!shoppingItemRecord) {
          return;
        }

        const [nameRecord, descriptionRecord] = shoppingItemRecord.toRecords();

        const decoder = new TextDecoder();
        console.log("Item name: " + decoder.decode(nameRecord.data));
        console.log("Item description: " + decoder.decode(descriptionRecord.data));
      };
    </pre>
  </section>
</section> <!-- Usage examples -->

<!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
<section> <h2>Data Representation</h2>
  <section> <h3>The <dfn>NDEFMessage</dfn> interface</h3>
    <p>
      The content of any <a>NDEF message</a> is exposed by the
      <a>NDEFMessage</a> interface:
    </p>
    <pre class="idl">
      [SecureContext, Exposed=Window]
      interface NDEFMessage {
        constructor(NDEFMessageInit messageInit);
        readonly attribute FrozenArray&lt;NDEFRecord&gt; records;
      };

      dictionary NDEFMessageInit {
        required sequence&lt;NDEFRecordInit&gt; records;
      };
    </pre>
    <p>
      The <dfn data-dfn-for="NDEFMessage">records</dfn>
      property represents a <a>list</a> of <a>NDEF record</a>s defining the
      <a>NDEF message</a>.
    </p>
    <p data-dfn-for="NDEFMessageInit">
      The <dfn>NDEFMessageInit</dfn> dictionary is used to initialize a
      <a>NDEF message</a>.
    </p>
  </section>

  <section data-dfn-for="NDEFRecord"> <h3>The <dfn>NDEFRecord</dfn> interface</h3>
    <p>
      The content of any <a>NDEF record</a> is exposed by the
      <a>NDEFRecord</a> interface:
    </p>
    <pre class="idl">
      typedef (DOMString or BufferSource or NDEFMessageInit) NDEFRecordDataSource;

      [SecureContext, Exposed=Window]
      interface NDEFRecord {
        constructor(NDEFRecordInit recordInit);

        readonly attribute USVString recordType;
        readonly attribute USVString? mediaType;
        readonly attribute USVString? id;
        readonly attribute boolean isLocal;
        readonly attribute DataView? data;

        readonly attribute USVString? encoding;
        readonly attribute USVString? lang;

        sequence&lt;NDEFRecord&gt;? toRecords();
      };

      dictionary NDEFRecordInit {
        required USVString recordType;
        USVString mediaType;
        USVString id;
        boolean isLocal = false;

        USVString encoding;
        USVString lang;

        NDEFRecordDataSource data;
      };
    </pre>
    <p>
      The <dfn>mediaType</dfn> property represents the <a>MIME type</a> of
      the <a>NDEF record</a> payload.
    </p>
    <p>
      The <dfn>recordType</dfn> property represents the <a>NDEF record</a> types.
    </p>
    <div>
      The <dfn>id</dfn> property represents the <dfn>record identifier</dfn>,
      which is an absolute or relative URL. The required uniqueness of the
      identifier is guaranteed only by the generator, not by this specification.
      <p class=note>
        The NFC NDEF specifications uses the terms "message identifier" and "payload identifier"
        instead of <a>record identifier</a>, but the identifier is tied to each record and not
        the message (collection of records), and it may be present when no payload is.
      </p>
    </div>
    <p>
      The <dfn>isLocal</dfn> property represents whether or not the <a>NDEF
      record</a> is of <a>local type</a>.
    </p>
    <p>
      The <dfn>encoding</dfn> attribute represents the
      [=encoding/name|encoding name=] used for encoding the payload in the
      case it is textual data.
    </p>
    <p>
      The <dfn>lang</dfn> attribute represents the [=language tag=]
      of the payload in the case that was encoded.
    </p>
    <p>
      A <dfn>language tag</dfn> is a <a>string</a> that matches the
      production of a <code>Language-Tag</code> defined in the [[BCP47]]
      specifications (see the <a href=
      "https://www.iana.org/assignments/language-subtag-registry">IANA
      Language Subtag Registry</a> for an authoritative list of possible
      values). That is, a language range is composed of one or more
      <dfn>subtags</dfn> that are delimited by a U+002D HYPHEN-MINUS ("-").
      For example, the '<code>en-AU</code>' language range represents
      English as spoken in Australia, and '<code>fr-CA</code>' represents
      French as spoken in Canada. Language tags that meet the validity
      criteria of [[RFC5646]] section 2.2.9 that can be verified without
      reference to the IANA Language Subtag Registry are considered
      structurally valid.
    </p>
    <p>
      The <dfn>data</dfn> property represents the <a>PAYLOAD field</a> data.
    </p>
    <p>
      The <dfn>toRecords()</dfn> method, when invoked, MUST return the result of
      running <a>convert NDEFRecord.data bytes</a> with the <a>NDEF Record</a>.
    </p>
    <p data-dfn-for="NDEFRecordInit">
      The <dfn>NDEFRecordInit</dfn> dictionary is used to initialize an
      <a>NDEF record</a> with its <a>record type</a> <dfn>recordType</dfn>,
      <a>local type</a> <dfn>isLocal</dfn>, and optional <a>record
      identifier</a> <dfn>id</dfn> and payload data <dfn>data</dfn>.
    </p>
    <div data-dfn-for="NDEFRecordInit">
      Additionally, there are additional optional fields that are only applicable
      for certain <a>record types</a>:
      <ul>
        <li data-dfn-for="NDEFRecordInit">
          "<a>mime</a>": Optional <a>MIME type</a> <dfn>mediaType</dfn>.
        </li>
        <li data-dfn-for="NDEFRecordInit">
          "<a>text</a>": Optional [=encoding/label|encoding label=]
          <dfn>encoding</dfn> and [=language tag=] <dfn>lang</dfn>.
        </li>
      </ul>
    </div>
    <p>
      The mapping from data types of an
      <a>NDEFRecordInit</a> to <a>NDEF record</a> types is presented
      in the algorithmic steps which handle the data and described in the
      [[[#steps-receiving]]] and [[[#writing-or-pushing-content]]] sections.
    </p>
    <p>
      To <dfn>convert NDEFRecord.data bytes</dfn>
      given a |record:NDEFRecord|, run these steps:
    </p>
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Let |bytes:byte sequence| be the value of record's <a>data</a> attribute.
      </li>
      <li>
        Let |recordType:record type| be the value of |record|'s
        <a>recordType</a> attribute.
      </li>
      <li>
        If the |recordType| value is "`smart-poster`", or if running
        <a>validate external type</a> on |recordType| returns `true`,
        then return the result of running <a>parse records from bytes</a> on |bytes|.
      </li>
      <li>
        Otherwise, [= exception/throw =] a
        {{"NotSupportedError"}} {{DOMException}} and abort these steps.
      </li>
    </ol>
  </section> <!-- NDEFRecord dictionary -->

  <section>
    <h2>The <dfn>record type</dfn> string</h2>
      <p>
        This string defines the allowed record types for a <a>NDEFRecord</a>. The
        [[[#data-mapping]]] section describes how it is mapped to
        <a>NDEF record</a> types.
      </p>
      <p>
        A standardized <dfn>well known type name</dfn> can be one of the
        following:
      </p>
      <dl>
        <dt>The "<dfn>empty</dfn>" string</dt>
        <dd>
          The value representing an <a href="#empty-ndef-record-tnf-0">empty</a>
          <a>NDEFRecord</a>.
        </dd>
        <dt>The "<dfn>text</dfn>" string</dt>
        <dd>
          The value representing a <a>Text record</a>.
        </dd>
        <dt>The "<dfn>url</dfn>" string</dt>
        <dd>
          The value representing a <a>URI record</a>.
        </dd>
        <dt>The "<dfn>smart-poster</dfn>" string</dt>
        <dd>
          The value representing a <a>Smart poster</a> record.
        </dd>
        <dt>The "<dfn>absolute-url</dfn>" string</dt>
        <dd>
          The value representing an <a>absolute-URL record</a>.
        </dd>
        <dt>The "<dfn>mime</dfn>" string</dt>
        <dd>
          The value representing a <a>MIME type record</a>.
        </dd>
        <dt>The "<dfn>unknown</dfn>" string</dt>
        <dd>
          The value representing an <a>unknown record</a>.
        </dd>
      </dl>
      <p>
        In addition to [=well known type names=] it is also possible for
        organizations to create a custom <dfn>external type name</dfn>,
        which is a string consisting of a [=domain=] name and a custom type name,
        separated by a colon `U+003A` (`:`).
      </p>
      <p>
        Applications MAY also use a <dfn>local type name</dfn>, which is a
        string that MUST start with lowercase character or a number,
        representing a type for a NFC Forum [=local type=]. It is
        typically used in a record of an <a>NDEFMessage</a> that is the payload
        of a parent <a>NDEFRecord</a>, for instance in a <a>smart poster</a>.
        The context of the <a>local type</a> is the parent record whose payload
        is the <a>NDEFMessage</a> to which this record belongs and the
        <a>local type name</a> SHOULD NOT conflict with any other type names
        used in that context.
      </p>
      <p>
        Any implementation of Web NFC MUST transparently expose chunked records
        as single logical records, therefore <a>unchanged record</a>s are not
        explicitly represented.
      </p>
      <p>
        Two <a>well-known type records</a> (including any NFC Forum
        <a>local type</a> and any NFC Forum <a>global type</a>) MUST be compared
        character by character in case-sensitive manner.
      </p>
      <p>
        Two external types MUST be compared character by character, in
        case-insensitive manner.
      </p>
      <p>
        The binary representation of any <a>well-known type record</a> and
        <a>external type</a> MUST be written as a relative URI (RFC 3986),
        omitting the namespace identifier (NID) "`nfc`" and namespace specific
        string (NSS) "`wkt`" and "`ext`", respectively, i.e. omitting the
        "`urn:nfc:wkt:`" and "`urn:nfc:ext:`" prefixes.
        For instance, "`urn:nfc:ext:company.com:a" is stored as "`company.com:a`"
        and the <a>well-known type records</a> of a <a>Text record</a> is
        "`urn:nfc:wkt:T`", but it is stored as "`T`".
      </p>

  </section>

  <section id="data-mapping"><h3>Data mapping</h3>
  <p>
    The mapping from data types of an <a>NDEFRecordInit</a> to
    <a>NDEF record</a> types, as used in the [[[#writing-or-pushing-content]]]
    section is as follows:
  </p>
  <table class="simple" data-link-for="NDEFRecordInit">
    <tr>
      <th>[=recordType=]</th>
      <th>[=mediaType=]</th>
      <th>[=data=]</th>
      <th><a href="#ndef-record-types">record type</a></th>
      <th nowrap>[=TNF field=]</th>
      <th>[=TYPE field=]</th>
    </tr>
    <tr>
      <td><dfn>"`empty`"</dfn></td>
      <td><i>unused</i></td>
      <td><i>unused</i></td>
      <td><a>Empty record</a></td>
      <td>0</td>
      <td><i>unused</i></td>
    </tr>
    <tr>
      <td><dfn>"`text`"</dfn></td>
      <td><i>unused</i></td>
      <td>
        {{BufferSource}} or<br>
        {{DOMString}}
      </td>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`T`"</td>
    </tr>
    <tr>
      <td><dfn>"`url`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}}</td>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`U`"</td>
    </tr>
    <tr>
      <td nowrap><dfn>"`smart-poster`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{NDEFMessageInit}}</td>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`Sp`"</td>
    </tr>
    <tr>
      <td><i>[=local type name=]</i></td>
      <td><i>unused</i></td>
      <td>
        {{BufferSource}}
      </td>
      <td>[=Local type=] record*</td>
      <td>1</td>
      <td>[=local type name=]</td>
    </tr>
    <tr>
      <td><dfn>"`mime`"</dfn></td>
      <td>[= MIME type =]</a></td>
      <td>{{BufferSource}}</td>
      <td><a>MIME type record</a></td>
      <td>2</td>
      <td>[= MIME type =]</td>
    </tr>
    <tr>
      <td nowrap><dfn>"`absolute-url`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{DOMString}} <i>url</i></td>
      <td><a>Absolute-URL record</a></td>
      <td>3</td>
      <td>[=Absolute-URL=]</td>
    </tr>
    <tr>
      <td><i>[=external type name=]</i></td>
      <td><i>unused</i></td>
      <td>
        {{BufferSource}} or<br>
        {{NDEFMessageInit}}
      </td>
      <td><a>External type record</a></td>
      <td>4</td>
      <td>[=external type name=]</td>
    </tr>
    <tr>
      <td><dfn>"`unknown`"</dfn></td>
      <td><i>unused</i></td>
      <td>{{BufferSource}}</td>
      <td>[=Unknown record=]</td>
      <td>5</td>
      <td><i>unused</i></td>
    </tr>
  </table>
  <p>
    * A [=local type=] record has to be embedded with the <a>NDEFMessage</a>
    payload of another record.
  </p>
  <p>
    The mapping from <a>NDEF record</a> types to <a>NDEFRecord</a>,
    as used for incoming <a>NDEF message</a>s described in the
    [[[#steps-receiving]]] section, is as follows.
  </p>
  <table class="simple" data-link-for="NDEFRecord">
    <tr>
      <th><a href="#ndef-record-types">record type</a></th>
      <th nowrap>[=TNF field=]<br></th>
      <th nowrap>[=TYPE field=]</th>
      <th>[=recordType=]</th>
      <th>[=mediaType=]</th>
      <th>[=isLocal=]</th>
    </tr>
    <tr>
      <td>[=Empty record=]</td>
      <td>0</td>
      <td><i>unused</i></td>
      <td>"`empty`"</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`T`"</td>
      <td>"`text`"</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`U`"</td>
      <td>"`url`"</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[=Well-known type record=]</td>
      <td>1</td>
      <td>"`Sp`"</td>
      <td nowrap>"`smart-poster`"</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[=Local type=] record*</td>
      <td>1</td>
      <td>[=local type name=]</td>
      <td>[=local type name=]</td>
      <td>`null`</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[=MIME type record=]</td>
      <td>2</td>
      <td>[=MIME type=]</td>
      <td>"`mime`"</td>
      <td>The <a>MIME type</a> used in the NDEF record</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[=Absolute-URL record=]</td>
      <td>3</td>
      <td>URL</td>
      <td>"`absolute-url`"</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[=External type record=]</a></td>
      <td>4</td>
      <td>[=external type name=]</td>
      <td>[=external type name=]</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td><a>Unknown record</a></td>
      <td>5</td>
      <td><i>unused</i></td>
      <td>"`unknown`"</td>
      <td>`null`</td>
      <td>`false`</td>
    </tr>
  </table>
  </section>
</section> <!-- Data types and content -->


<section> <h2>The NDEFReader and NDEFWriter objects</h2>
  The objects provide a way for the <a>browsing context</a> to
  use NFC functionality.
  They allow for pushing <a>NDEF message</a>s to <a>NFC tag</a>s
  or <a>NFC peer</a>s within range, and to act on incoming
  <a>NDEF message</a>s either from an <a>NFC tag</a> or an
  <a>NFC peer</a>.
  <pre class="idl">
    typedef (DOMString or BufferSource or NDEFMessageInit) NDEFMessageSource;

    [SecureContext, Exposed=Window]
    interface NDEFWriter {
      constructor();

      Promise&lt;void&gt; push(NDEFMessageSource message, optional NDEFPushOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NDEFReader : EventTarget {
      constructor();

      attribute EventHandler onerror;
      attribute EventHandler onreading;

      Promise&lt;void&gt; scan(optional NDEFScanOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NDEFReadingEvent : Event {
      constructor(DOMString type, NDEFReadingEventInit readingEventInitDict);

      readonly attribute DOMString serialNumber;
      [SameObject] readonly attribute NDEFMessage message;
    };

    dictionary NDEFReadingEventInit : EventInit {
      DOMString? serialNumber = "";
      required NDEFMessageInit message;
    };
  </pre>
  <p>
    The <dfn>NDEFMessageSource</dfn> is a union type representing argument types
    accepted by the [=NDEFWriter/push()=] method.
  </p>
  <p data-dfn-for="NDEFReadingEvent">
    The <dfn>NDEFReadingEvent</dfn> is the event being dispatched on new NFC readings.
    The <dfn>serialNumber</dfn> property represents the serial number of
    the device used for anti-collision and identification, or empty string in case none
    is available. The <dfn>message</dfn> is an <a>NDEFMessage</a> object.
  </p>
  <p data-dfn-for="NDEFReadingEventInit">
    <dfn>NDEFReadingEventInit</dfn> is used to initialize a new event with a serial number
    and the <a>NDEFMessageInit</a> data via the <dfn>message</dfn> member.
    If <dfn>serialNumber</dfn> is
    [= dictionary member/not present =] or is `null`,
    empty string will be used to init the event.
  </p>
  <p class="note">
    Though most tags will have a stable unique identifier (UID), not all
    have one and some tags even create a random number on each read.
    The serial number usually consists of 4 or 7 numbers, separated by `:`.
  </p>
  <p>
    The <dfn>NDEFWriter</dfn> is an object used for writing data to NFC devices
    such as tags.
  </p>
  <p>
    An {{NDEFWriter}} object has the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
    internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody data-link-for="NDEFWriter">
     <tr>
      <td><dfn>[[\PushOptions]]</dfn></td>
      <td>`null`</td>
      <td>
        The {{NDEFPushOptions}} value for writer.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\PushMessage]]</dfn></td>
      <td>`null`</td>
      <td>
        The {{NDEFMessage}} to be written.
        It is initially unset.
      </td>
     </tr>
    </tbody>
  </table>

  <p>
    The <dfn>NDEFReader</dfn> is an object used for reading data when a device,
    such as a tag, is within the magnetic induction field.
  </p>
  <p>
    An {{NDEFReader}} object has the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
    internal slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody data-link-for="NDEFScanOptions">
     <tr>
      <td><dfn>[[\Id]]</dfn></td>
      <td>An empty <a>string</a>.</td>
      <td>
        The {{NDEFScanOptions}}.<a>id</a> value.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\RecordType]]</dfn></td>
      <td>`undefined`</td>
      <td>
        The {{NDEFScanOptions}}.<a>recordType</a> value.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\MediaType]]</dfn></td>
      <td>An empty <a>string</a>.</td>
      <td>
        The {{NDEFScanOptions}}.<a>mediaType</a> value.
      </td>
      </tr>
      <tr>
        <td><dfn>[[\Signal]]</dfn></td>
        <td>`undefined`</td>
        <td>
          The {{NDEFScanOptions}}.<a>signal</a> to abort the operation.
        </td>
      </tr>
    </tbody>
  </table>

  <p class="note">
    Note that the internal slots of {{NDEFReader}} come from the
    |options:NDEFScanOptions| passed to <a>NDEFReader.scan()</a>.
    Therefore there is maximum one filter associated with any given
    {{NDEFReader}} object and successive invocations of <a>NDEFReader.scan()</a>
    with new |options:NDEFScanOptions| will replace existing filters.
  </p>
  <p>
    The <dfn data-dfn-for="NDEFReader">onreading</dfn> is an {{EventHandler}}
    which is called to notify that new reading is available.
  </p>
  <p>
    The <dfn data-dfn-for="NDEFReader">onerror</dfn> is an {{EventHandler}}
    which is called to notify that an error happened during reading.
  </p>
  <section><h3>NFC state associated with the settings object</h3>
  <p>
    The <a>relevant settings object</a> of the <a>active document</a> of a
    <a>browsing context</a> which supports NFC has an associated
    <dfn>NFC state</dfn> record with the following <a data-cite=
    "ECMASCRIPT#sec-object-internal-methods-and-internal-slots">internal
    slots</a>:
  </p>
  <table class="simple">
    <thead>
     <tr>
      <th>Internal Slot</th>
      <th>Initial value</th>
      <th>Description (<em>non-normative</em>)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><dfn>[[\Suspended]]</dfn></td>
      <td>`false`</td>
      <td>
        A boolean flag indicating whether NFC functionality is
        <a href="#nfc-suspended">suspended</a> or not, initially
        `false`.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\ActivatedReaderList]]</dfn></td>
      <td>empty <a>set</a></td>
      <td>
        A <a>set</a> of {{NDEFReader}} instances.
      </td>
     </tr>
     <tr>
      <td><dfn>[[\PendingPush]]</dfn></td>
      <td>empty</td>
      <td>
        A &lt;|promise:Promise|, |writer:NDEFWriter|&gt; tuple where |promise|
        holds a pending {{Promise}} and |writer| holds an {{NDEFWriter}}.
      </td>
      </tr>
    </tbody>
  </table>
  <p>
    The <dfn>activated reader objects</dfn> is the value of the
    <a>[[\ActivatedReaderList]]</a> internal slot.
  </p>
  <p>
    The <dfn>pending push tuple</dfn> is the value of the
    <a>[[\PendingPush]]</a> internal slot.
  </p>
  <p>
    <dfn id="nfc-is-suspended">NFC is suspended</dfn> if the
    <a>[[\Suspended]]</a> internal slot is `true`.
  </p>
  <p>
    To <dfn id="suspend-nfc">suspend NFC</dfn>, set the <a>[[\Suspended]]</a>
    internal slot to `true`.
  </p>
  <p>
    To <dfn id="resume-nfc">resume NFC</dfn>, set the <a>[[\Suspended]]</a>
    internal slot to `false`.
  </p>
  <p class="note">
    Internal slots are used only as a notation in this specification, and
    implementations do not necessarily have to map them to explicit internal
    properties.
  </p>
  </section>

  <section> <h3>Handling NFC adapters</h3>
    Implementations MAY use multiple <a>NFC adapter</a>s
    according to the algorithmic steps described in this specification.
  </section>

  <section><h3>Obtaining permission</h3>
    <p>
      The
      <a href="https://www.w3.org/TR/permissions/#dictdef-permissiondescriptor">
      <dfn>Web NFC permission name</dfn></a> is
      <a href="https://github.com/w3c/permissions/issues/47">defined</a> as
      "`nfc`".
    </p>
    <div>
      To <dfn>obtain permission</dfn>, run these steps:
      <ol class=algorithm>
        <li>
          Run the
          <a>query a permission</a> steps for the
          <a>Web NFC permission name</a> until completion.
          <ol>
            <li>
              If it resolved with {{PermissionState["granted"]}}
              (i.e. permission has been granted to the <a>origin</a> and
              <a>global object</a> using the [[[PERMISSIONS]]] API),
              return `true`.
            </li>
            <li>
              Otherwise, if it resolved with {{PermissionState["prompt"]}},
              then optionally
              <a data-lt="request permission to use">request permission</a>
              from the user for the <a>Web NFC permission name</a>.
              If that is granted, return `true`.
              <p class="issue">
                The <a data-lt="request permission to use">request permission</a>
                steps are not yet clearly defined.
                At this point the UA asks the user about the policy to be used
                with the <a>Web NFC permission name</a> for the given
                <a>origin</a> and <a>global object</a>, if the user grants
                permission, return `true`.
              </p>
            </li>
          </ol>
        </li>
        <li>
          Return `false`.
        </li>
      </ol>
    </div>
  </section>

  <section><h3>Handling visibility change</h3>
    <p>
      When the user agent determines that the
      <dfn data-cite="PAGE-VISIBILITY#dfn-visibility-states">visibility
      state</dfn> of the [=environment settings object / responsible document=]
      of the <a>current settings object</a> changes, it must run these steps:
    </p>
    <ol class="algorithm">
      <li>Let |document:Document| be the [=environment settings object /
      responsible document=] of the <a>current settings object</a>.
      </li>
      <li>
        If |document|'s <a>visibility state</a> is `"visible"`,
        <a>resume NFC</a> and abort these steps.
      </li>
      <li>
        Otherwise, <a>suspend NFC</a> and attempt to <a>abort a pending
        push operation</a>.
      </li>
    </ol>
    <p>
      The term <dfn id="nfc-suspended">suspended</dfn> refers to NFC
      operations being suspended, which means that no <a>NFC content</a> is
      pushed by <a>NDEFWriter</a>s, and no received <a>NFC content</a> is
      presented to any {{NDEFReader}} while being suspended.
    </p>
  </section>

  <section><h3>Aborting pending push operation</h3>
  <div>
    To attempt to <dfn>abort a pending push operation</dfn> on an
    <a>environment settings object</a>, perform the following steps:
    <ol class=algorithm>
      <li>
        If there is no <a>pending push tuple</a> |tuple|, abort these steps.
      </li>
      <li>
        If |tuple|'s writer has already initiated an ongoing NFC data transfer,
        abort these steps.
      </li>
      <li>
        Reject |tuple|'s promise with an {{"AbortError"}} {{DOMException}}
        and abort these steps.
        <p class=note>
          Rejecting the promise will clear the <a>pending push tuple</a>.
        </p>
      </li>
    </ol>
  </div>
  </section>

  <section><h3>Releasing NFC</h3>
  <p>
    To <dfn>release NFC</dfn> on an <a>environment settings object</a>,
    perform the following steps:
  </p>
  <ol id="steps-nfc-release">
    <li>
      <a>Suspend NFC</a>.
    </li>
    <li>
      Attempt to <a>abort a pending push operation</a>.
    </li>
    <li>
      Stop the <a>dispatch NFC content</a> steps.
    </li>
    <li>
      Clear the <a>activated reader objects</a>.
    </li>
    <li>
      Release the NFC resources associated with |nfc| on the
      underlying platform.
    </li>
  </ol>
  <p>
    The UA must <a>release NFC</a> given the document's
    <a>relevant settings object</a> as additional
    <a>unloading document cleanup steps</a>.
  </p>
  </section> <!-- release NFC -->

  <section data-dfn-for="NDEFPushOptions">
    <h3>The <dfn>NDEFPushOptions</dfn> dictionary</h3>
    <pre class="idl">
      dictionary NDEFPushOptions {
        NDEFPushTarget target = "any";
        boolean ignoreRead = true;
        boolean overwrite = true;
        AbortSignal? signal;
      };
    </pre>
    <p>
      The <dfn>target</dfn> property
      denotes the intended target for the pending
      [=NDEFWriter/push()=]
      operation.
    </p>
    <p>
      When the value of the <dfn>ignoreRead</dfn> property is
      `true`, the <a href="#steps-push">push algorithm</a>
      will skip invoking the <a>NFC reading algorithm</a> for an <a>NFC tag</a>.
    </p>
    <p>
      When the value of the <dfn>overwrite</dfn> property is
      `false`, the <a href="#steps-push">push algorithm</a>
      will read the <a>NFC tag</a> regardless of the `ignoreRead` value
      to determine if it has <a>NDEF</a> records on it, and if yes, it will not
      execute any pending push.
    </p>
    <p>
      The <dfn>signal</dfn> property allows to abort
      the [=NDEFWriter/push()=] operation.
    </p>
  </section>

  <section data-dfn-for="NDEFPushTarget">
    <h2>The <dfn>NDEFPushTarget</dfn> enum</h2>
    <p>
      This enum defines the set of intended target values for the
      [=NDEFWriter/push()=] operation.
    </p>
    <pre class="idl">
      enum NDEFPushTarget {
        "tag",
        "peer",
        "any"
      };
    </pre>
    <dl>
      <dt><dfn>tag</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        [=NDEFWriter/push()=] operation to be
        a <a>NFC tag</a>.
      </dd>
      <dt><dfn>peer</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        [=NDEFWriter/push()=] operation to be
        a <a>NFC peer</a>.
      </dd>
      <dt><dfn>any</dfn></dt>
      <dd>
        The enum value representing the intended target for the
        [=NDEFWriter/push()=] operation to be
        a <a>NFC tag</a> or a <a>NFC peer</a>.
      </dd>
    </dl>
  </section> <!-- NDEFPushTarget enum -->

  <section data-dfn-for="NDEFScanOptions">
    <h3>The <dfn>NDEFScanOptions</dfn> dictionary</h3>
      <p>
        To describe which messages an application is interested in, the
        <a>NDEFScanOptions</a> dictionary is used:
      </p>
      <pre class="idl">
        dictionary NDEFScanOptions {
          USVString id;
          USVString recordType;
          USVString mediaType = "";
          AbortSignal? signal;
        };
      </pre>
      <p>
        The <dfn>signal</dfn> property allows to abort the
        [=NDEFReader/scan()=] operation.
      </p>
      <p>
        The <dfn>id</dfn> property
        denotes the string value which is used for matching the
        <a>record identifier</a> of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        If the dictionary member is [= dictionary member/not present =],
        then it will be ignored by the
        <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>recordType</dfn> property
        denotes the string value which is used for matching the
        <a>record type</a> of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        If the dictionary member is [= dictionary member/not present =],
        then it will be ignored by the
        <a href="#steps-listen">NFC listen algorithm</a>.
      </p>
      <p>
        The <dfn>mediaType</dfn> property
        denotes the <a>match pattern</a> which is used for matching the
        [=NDEFRecord/mediaType=] property of each
        <a>NDEFRecord</a> object in an <a>NDEF message</a>.
        The default value `""` means that no matching is performed.
      </p>
      <pre
        title="Filter accepting only JSON content"
        class="example highlight">
        const options = {
          mediaType: "application/*json"  // any JSON-based MIME type
        }
      </pre>
      <pre
        title="Filter which only accepts binary content for a custom record identifier"
        class="example highlight">
        const options = {
          id: "my-restaurant-daily-menu",
          mediaType: "application/octet-stream"
        }
      </pre>
  </section> <!-- NDEFScanOptions -->

  <section id="writing-or-pushing-content">
    <h3><dfn>Writing or pushing content</dfn></h3>
    <p>
      This section describes how to write an <a>NDEF message</a>
      to an <a>NFC tag</a> or how to push it to an <a>NFC peer</a>
      device when it is next time in proximity range before a timer expires.
      At any time there is a maximum of two
      <a>NDEF message</a>s that can be set for pushing for an <a>origin</a>:
      one targeted to <a>NFC tag</a>s and one to <a>NFC peer</a>s, until
      the current message is sent or the push is aborted.
    </p>
    <section><h3>The <strong>push()</strong> method</h3>
      <div id="steps-push">
        The
        <dfn>NDEFWriter.push</dfn> method, when invoked, MUST run the
        <dfn>push a message</dfn> algorithm:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be a new {{Promise}} object.
          </li>
          <li>
            Let |message:NDEFMessageSource| be the first argument.
          </li>
          <li>
            Let |options:NDEFPushOptions| be the second argument.
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection
            cannot be established, then reject |p| with a
            {{"NotSupportedError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If the UA is not allowed to access the underlying <a>NFC Adapter</a>
            (e.g. a user preference), then reject |p| with a
            {{"NotReadableError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If pushing data is not supported by the underlying
            <a>NFC Adapter</a>, then reject |p| with a {{"NotSupportedError"}}
            {{DOMException}} and return |p|.
          </li>
          <li>
            Let |signal:AbortSignal| be the |options|‚Äô dictionary member
            of the same name if present, or `null` otherwise.
          </li>
          <li>
            If |signal|‚Äôs [= AbortSignal/aborted flag =] is set, then reject |p|
            with an {{"AbortError"}} {{DOMException}} and return |p|.
          </li>
          <li>
            If |signal| is not `null`, then
            <a data-cite="dom#abortsignal-abort-algorithms">
            add the following abort steps</a> to |signal|:
              <ol>
                <li>
                  Run the <a>abort a pending push operation</a> on the
                  <a>environment settings object</a>.
                </li>
              </ol>
          </li>
          <li>
            [=promise/React=] to |p|:
            <ol>
              <li>
                If |p| was settled (fulfilled or rejected), then clear the
                <a>pending push tuple</a> if it exists.
              </li>
            </ol>
          </li>
          <li>
            Return |p| and run the following steps <a>in parallel</a>:
            <ol>
              <li>
                An implementation MAY reject |p| with
                a {{"NotSupportedError"}} {{DOMException}}
                and abort these steps.
                <p class="note">
                  The UA might abort message push at this point. The reasons
                  for termination are implementation details. For example, the
                  user could have has set a preference to allow a given
                  <a>origin</a> only to read, write, or push data to peers.
                  Also, the implementation might be unable to support the
                  requested operation.
                </p>
              </li>
              <li>
                Let |output| be the notation for the <a>NDEF message</a>
                to be created by UA, as the result of passing
                |message| to <a>create NDEF message</a>.
                If this throws an exception, reject |p| with that
                exception and abort these steps.
              </li>
              <li>
                Attempt to <a>abort a pending push operation</a>.
                <p class="note">
                  A push replaces all previously configured push operations.
                </p>
              </li>
              <li>
                Set `this`.[[\PushOptions]] to |options|.
              </li>
              <li>
                Set `this`.[[\PushMessage]] to |output|.
              </li>
              <li>
                Set <a>pending push tuple</a> to (`this`, |p|).
              </li>
              <li>
                Run the <a>start the NFC push</a> steps whenever an
                <a>NFC device</a> |device| comes within communication range.
                <p class="note">
                  If <a>NFC is suspended</a>, continue waiting until promise is
                  aborted by the user or an <a>NFC device</a> comes within
                  communication range.
                </p>
              </li>
            </ol>
            </li>
          </li>
        </ol>
      </div>

      <div id="steps-start-nfc-push">
        To <dfn>start the NFC push</dfn>, run these steps:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be the <a>pending push tuple</a>'s promise.
          </li>
          <li>
            Let |writer| be the <a>pending push tuple</a>'s writer.
          </li>
          <li>
            Let |options:NDEFPushOptions| be |writer|.[[\PushOptions]].
          </li>
          <li>
            Let |target:NDEFPushTarget| be |options|' target.
          </li>
          <li>
            If the <a>NFC device</a> in proximity range does not expose
            <a>NDEF</a> technology for formatting or writing, then
            reject |p| with a {{"NotSupportedError"}} {{DOMException}} and
            return |p|.
          </li>
          <li>
            Verify the following conditions:
            <ul>
              <li>
                if |device| is an <a>NFC tag</a>, |target| is
                "`tag`" or "`any`".
              </li>
              <li>
                if |device| is an <a>NFC peer</a>, |target| is
                "`peer`" or "`any`".
              </li>
              <li>
                <a href="#nfc-is-suspended">NFC is not suspended</a>.
              </li>
            </ul>
          </li>
          <li>
            In case of success, run the following steps:
            <ol>
              <li>
                If |device| is an <a>NFC tag</a>,
                <ul>
                  <li>
                    If |options|'s ignoreRead is not equal to
                    `true`, run the <a>NFC reading algorithm</a>.
                  </li>
                  <li>
                    Otherwise, if |options|'s overwrite is `false`, read the tag
                    to check whether there are <a>NDEF</a> records on the tag.
                    If yes, then reject |p| with a {{"NotAllowedError"}}
                    {{DOMException}} and return |p|.
                  </li>
                </ul>
              </li>
              <li>
                Let |output:NDEFMessage| be |writer|.[[\PushMessage]].
              </li>
              <li>
                Initiate data transfer to |device| using
                |output| as buffer, using the <a>NFC adapter</a>
                in communication range with |device|.
                <p class="note">
                  If the <a>NFC device</a> in proximity range is an unformatted
                  <a>NFC tag</a> that is <a>NDEF</a>-formatable, format it and
                  write |output| as buffer.
                </p>
                <p class="note">
                  Multiple adapters should be used sequentially by users.
                  There is very little likelihood that a simultaneous tap
                  will happen on two or multiple different and connected
                  <a>NFC adapter</a>s.
                  If it happens, the user will likely need to repeat the
                  taps until success, preferably one device at a time.
                  The error here gives an indication that the operation
                  needs to be repeated. Otherwise the user may think the
                  operation succeeded on all connected <a>NFC adapter</a>s.
                </p>
              </li>
              <li>
                If the transfer fails, reject |p| with
                {{"NetworkError"}} {{DOMException}}
                and abort these steps.
              </li>
              <li>
                When the transfer has completed, resolve |p|.
              </li>
            </ol>
          </li>
        </ol>
      </div>
    </section>
  </section> <!-- Writing or pushing content -->

  <section><h3>Creating NDEF message</h3>
    <div>
      To <dfn>create NDEF message</dfn> given a
      |source:NDEFMessageSource| run these steps:
      <ol class=algorithm id="create-web-nfc-message">
        <li>Switch on |source:NDEFMessageSource|'s type:
          <dl>
            <dt>{{DOMString}}</dt>
            <ul>
              <li>
                Let |textRecord| be an <a>NDEFrecord</a> initialized with its
                |recordType| set to "`text`" and |data| set to |source|.
              </li>
              <li>
                Let |records| be the list ¬´ |textRecord| ¬ª.
              </li>
              <li>
                Set |source|'s records to |records|.
              </li>
            </ul>
            <dt>{{BufferSource}}</dt>
            <ul>
                <li>
                  Let |mimeRecord| be an <a>NDEFrecord</a> initialized with its
                  |recordType| set to "`mime`", |data| set to |source|, and
                  |mediaType| set to "`application/octet-stream`".
                </li>
                <li>
                  Let |records| be the list ¬´ |mimeRecord| ¬ª.
                </li>
                <li>
                  Set |source|'s records to |records|.
                </li>
            </ul>
            <dt>{{NDEFMessageInit}}</dt>
            <ul>
              <li>
                If |source|'s records [= list/is empty =], throw a
                {{TypeError}} and abort these steps.
              </li>
            </ul>
            <dt>unmatched type</dt>
            <ul>
              <li>
                [= exception/throw =] a {{TypeError}} and abort these steps.
              </li>
            </ul>
          </dl>
        </li>
        <li>
          Let |output| be the notation for the <a>NDEF message</a>
          to be created by the UA as a result of these steps.
        </li>
        <li>
          [= list/For each =] |record:NDEFRecordInit| in the <a>list</a>
          |source|'s records, run the following steps:
          <ol>
            <li>
              Let |ndef| be the result of running <a>create NDEF record</a>
              given |record:NDEFRecordInit|, or make sure the underlying
              platform provides equivalent values to |ndef|.
              If the algorithm throws an exception |e|, reject |promise| with
              |e| and abort these steps.
            </li>
            <li>
              Add |ndef| to |output|.
            </li>
          </ol>
        </li>
        <li>
          Return |output|.
        </li>
      </ol>
    </div>

    <section><h3>Creating NDEF record</h3>
      <div>
        To <dfn>create NDEF record</dfn> given |record:NDEFRecordInit|, run
        these steps:
        <ol data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>recordType</a> is `undefined`:
            <ol> <!-- guess type and mediaType from data -->
              <li>
                If |record|'s <a>data</a> is `undefined`, reject |promise| with
                a {{TypeError}} and abort these steps.
              </li>
              <li>
                Otherwise, if the type of |record|'s <a>data</a> is
                {{DOMString}}, then set |record|'s <a>recordType</a> to
                "`text`".
              </li>
              <li>
                Otherwise, set |record|'s <a>recordType</a> to "`mime`".
              </li>
            </ol>
          </li>
          <li>
            Let |ndef| be the representation of an <a>NDEF record</a> to be
            created by the UA.
          </li>
          <li>
            If |record|'s <a>id</a> is not `undefined`:
            <ul>
              <li>
                Let |identifier| be |record|'s <a>id</a>.
              </li>
              <li>
                Set |ndef|'s <a>IL field</a> to `1`.
              </li>
              <li>
                Set |ndef|'s <a>ID LENGTH field</a> to the length of
                |identifier|.
              </li>
              <li>
                Set |ndef|'s <a>ID field</a> to |identifier|.
              </li>
            </ul>
          </li>
          <li>
            If |record|'s <a>isLocal</a> is `true` and |record| is not a payload
            to another <a>NDEF record</a>, reject |promise| with a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Switching on |record|'s <a>recordType</a>, pass |record| and |ndef|
            to one of the following algorithms and return the result.
            If the algorithm throws an exception |e|, reject |promise| with |e|
            and abort these steps.
            <dl>
              <dt>"`empty`"</dt>
              <ul>
                <li>
                  Return <a>map empty record to NDEF</a> given |record| and |ndef|.
                </li>
              </ul>
              <dt>"`text`"</dt>
              <ul>
                <li>
                  Return <a>map text to NDEF</a> given |record| and |ndef|.
                </li>
              </ul>
              <dt>"`url`"</dt>
              <ul>
                <li>
                  Return <a>map a URL to NDEF</a> given |record| and |ndef|.
                </li>
              </ul>
              <dt>"`mime`"</dt>
              <ul>
                <li>
                  Return <a>map binary data to NDEF</a> given |record| and |ndef|.
                </li>
              </ul>
              <!-- TODO: "smart-poster", "absolute-url" -->
            </dl>
          </li>
          <li>
            If running <a>validate external type</a> on |record|'s
            <a>recordType</a> returns `true`,
            <ul>
              <li>
                If |record|'s <a>data</a> is of type
                {{NDEFMessageInit}}, then return the result of running
                the <a>create NDEF message</a> given |record|'s
                <a>data</a>.
              </li>
              <li>
                Otherwise, return <a>map external data to NDEF</a> given
                |record| and |ndef|.
              </li>
            </ul>
          </li>
          <li>
            If |record| is a payload to another <a>NDEF record</a> and if
            running the <a>validate local type</a> steps on |record|'s
            <a>recordType</a> returns `true`,
            <ul>
              <li>
                If |record|'s <a>data</a> is of type
                {{NDEFMessageInit}}, then return the result of running
                the <a>create NDEF message</a> given |record|'s
                <a>data</a>.
              </li>
              <li>
                Otherwise, return the result of running
                <a>map local type to NDEF</a> given |record| and |ndef|.
              </li>
            </ul>
          </li>
          <li>
            Otherwise, [= exception/throw =] a {{TypeError}} and abort
            these steps.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Validating external type</h3>
      <div>
        The [[NFC-RTD]] specifies that external types MUST contain
        the [=domain=] name of the issuing organization, a colon `U+003A` (`:`)
        and a type name that is at least one character long, for instance
        "`w3.org:member`".
      </div>
      <p>
        The [[NFC-RTD]] specifies the URN prefix ‚Äú`urn:nfc:ext:`‚Äù as well, but
        it is not stored in the <a>NDEF record</a>, therefore Web NFC
        applications SHOULD NOT specify the URN prefix when creating
        <a>external type records</a>.
      </p>
      <p class="note">
        The [[NFC-RTD]] requires that external type names are represented
        with the URN prefix ‚Äú`urn:nfc:ext:`‚Äù, e.g. when reading
        <a>NDEF messages</a>. However, since <a>external type records</a> are
        distinguished by having the <a>TNF FIELD</a> set to `0x04`, there is
        no risk seen for type name clashing. Also, there are
        <a href="https://www.w3.org/2001/tag/doc/URNsAndRegistries-50.html">
        W3C TAG recommendations</a> to avoid using URNs in the Web.
        Therefore, Web NFC does not use the URN prefix neither when reading
        or writing <a>NDEF messages</a>.
      </p>
      <p>
        To <dfn>validate external type</dfn> given |input:USVString|, run
        these steps:
      </p>
      <ol class=algorithm id="validate-external-type">
        <li>
          If |input:string| is not a {{USVString}} or it is empty, or its
          length exceeds 255 bytes, return `false`.
        </li>
        <li>
          Let |domain| be the |input| from the start of |input| up to but
          excluding the last occurrence of U+003A (`:`), or `null` if that is
          not found.
        </li>
        <li>
          Let |type| be the |input| after the last occurrence, if any, of
          `U+003A` (`:`) up to the end of |input|, or `null` if that is
          not found.
        </li>
        <li>
          If |domain| or |type| is `null`, return `false`.
        </li>
        <li>
          Run the following sub-steps of
          <a href="https://url.spec.whatwg.org/#host-parsing">host parsing</a>
          on |domain|:
          <ul>
            <li>
              Let |asciiDomain| be the result of running
              <a href="https://url.spec.whatwg.org/#concept-domain-to-ascii">
              domain to ASCII</a> on |domain|.
            </li>
            <li>
              If |asciiDomain| is failure, return `false`.
            </li>
            <li>
              If |asciiDomain| contains a [=forbidden host code point=],
              return `false`.
            </li>
          </ul>
        </li>
        <li>
          If |type| is empty, return `false`.
        </li>
        <li>
          If |type| contains [=code points=] that are not
          [=ASCII alphanumeric=], or `U+0024` (`$`), `U+0027` (`'`),
          `U+0028` `LEFT PARENTHESIS` (`(`), `U+0029` `RIGHT PARENTHESIS` (`)`),
          `U+002A` (`*`), `U+002B` (`+`), `U+002C` (`,`), `U+002D` (`-`),
          `U+002E` (`.`), `U+003B` (`;`), `U+003D` (`=`), `U+0040` (`@`),
          `U+005F` (`_`), return `false`.
        </li>
        <li>
          Return `true`.
        </li>
      </ol>
    </section>

    <section><h3>Validating local type</h3>
      <p>
        To <dfn>validate local type</dfn> given a |input:USVString| run
        these steps:
      </p>
      <ol class=algorithm id="validate-local-type">
        <li>
          If |input| is not a {{USVString}} or its length exceeds 255 bytes,
          return `false` and abort these steps.
        </li>
        <li>
          If |input| does not start with a lowercase character or a number,
          return `false`.
        </li>
        <li>
          If |input| is equal to the <a>record type</a> of any <a>NDEF record</a>
          defined in its containing <a>NDEF message</a>, return `false`.
        </li>
        <li>
          Return `true`.
        </li>
      </ol>
    </section>

    <section><h3>Mapping empty record to NDEF</h3>
      <div>
        To <dfn>map empty record to NDEF</dfn> given a |record:NDEFRecordInit|
        and |ndef|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If |record|'s <a>id</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>Set the
            |ndef|'s <a>TNF field</a> to `0` (<a>empty record</a>).
          </li>
          <li>Set the
            |ndef|'s <a>IL field</a> to `0`.
          </li>
          <li>Set
            |ndef|'s <a>TYPE LENGTH field</a>,
            and <a>PAYLOAD LENGTH field</a> to `0`,
            and omit <a>TYPE field</a> and <a>PAYLOAD field</a>.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping string to NDEF</h3>
      <div>
        To <dfn>map text to NDEF</dfn> given a |record:NDEFRecordInit| and
        |ndef|, run these steps:
        <p class="note">
          This is useful when clients specifically want to write text in a
          [=well-known type record=].
          Other options would be to use the value "`mime`"
          with an explicit <a>MIME type</a> text type, which allows for
          better differentiation, e.g. when using "`text/xml`", or
          "`text/vcard`".
        </p>
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of |record|'s <a>data</a> is not a {{DOMString}} or a
            {{BufferSource}}, [= exception/throw =] a {{TypeError}} and abort
            these steps.
          </li>
          <li>
            Let |documentLanguage:string| be the [=document element=]'s
            <a>lang</a> attribute.
          </li>
          <li>
            If |documentLanguage| is the empty string, set it to "`en`".
          </li>
          <li>
            Let |language:string| be |record|'s <a>lang</a> if it [= map/exists =],
            or else to |documentLanguage|.
          </li>
          <li>
            Let |encoding label:string| be |record|'s <a>encoding</a> if it
            [= map/exists =], or "`utf-8`".
          </li>
          <li>
            If |encoding label| is not equal to "`utf-8`", "`utf-16`",
            "`utf-16le`" or "`utf-16be`" [= exception/throw =] a {{TypeError}}.
          </li>
          <li>
            Let |encoding name| be the [=encoding/name|name=]
            <a data-cite="encoding#concept-encoding-get">obtained</a>
            from |encoding label|.
          </li>
          <li>
            Let |header:byte| be a <a>byte</a> constructed the following way:
            <ol>
              <li>
                If |encoding name| is equal to UTF-8, set bit `7` to the value
                `0`, or else set the value to `1`.
              </li>
              <li>
                Set bit `6` to the value `0` (reserved).
              </li>
              <li>
                Let |languageLength:octet| be the length of the
                |language| <a>string</a>.
              </li>
              <li>
                If |languageLength| cannot be stored in 6 bit
                (|languageLength| > 63), [= exception/throw =] a {{SyntaxError}}.
              </li>
              <li>
                Set bit `5` to bit `0` to |languageLength|.
              </li>
            </ol>
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> (position 0) of |data| to |header|.
              </li>
              <li>
                Set position 1 (second <a>byte</a>) to position |languageLength|
                of |data| to |language|.
              </li>
              <li>Switch on the type of |record|'s <a>data</a>:
                <dl>
                  <dt>{{DOMString}}</dt>
                  <ol>
                    <li>
                      Let |stream:byte stream| be the resulting
                      <a data-cite="encoding#concept-stream">byte stream</a> of
                      running <a>UTF-8 encode</a> on |record|'s <a>data</a>.
                    </li>
                    <li>
                      <a data-cite="encoding#concept-stream-read">Read</a> bytes
                      from |stream| into |data| (from position |languageLength| + 1)
                      until <a data-cite="encoding#concept-stream-read">read</a>
                      returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
                    </li>
                  </ol>
                  <dt>{{BufferSource}}</dt>
                  <ol>
                    <li>
                      Set bytes from |record|'s <a>data</a> into |data|
                      (from position |languageLength| + 1) .
                    </li>
                    </ol>
                </dl>
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            <ol>
              <li>
                Set the |ndef|'s <a>TNF field</a> to `1` (
                [=well-known type record=]).
              </li>
              <li>
                Set the |ndef|'s <a>TYPE field</a> to "`T`" (`0x54`).
              </li>
              <li>
                Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
              </li>
              <li>
                If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
                to |data|.
              </li>
            </ol>
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping URL to NDEF</h3>
      <div>
        To <dfn>map a URL to NDEF</dfn> given a |record:NDEFRecordInit| and
        |ndef|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If |record|'s <a>data</a> is not a {{DOMString}},
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |url:URL| be the result of
            <a data-lt="url parser">parsing</a> |record|'s <a>data</a>.
          </li>
          <li>
            If |url| is failure, [= exception/throw =] a
            {{TypeError}} and abort these steps.
          </li>
          <li>
            Let |serializedURL:string| be
            <a data-cite="url#concept-url-serializer">serialization</a> of |url|.
          </li>
          <li>
            Match the URI prefixes as defined in [[[NFC-STANDARDS]]],
            URI Record Type Definition specification, Section 3.2.2, against
            the |serializedURL|.
          </li>
          <li>
            Let |prefixString:string| be the matched prefix or else the
            <a href="#dfn-empty">empty</a> <a>string</a>.
          </li>
          <li>
            Let |prefixByte:byte| be the corresponding prefix number,
            or else `0`.
          </li>
          <li>
            Let |shortenedURL:string| be |serializedURL| with
            |prefixString| removed from the start of the <a>string</a>.
          </li>
          <li>
            Let |data:byte sequence| be an empty [= byte sequence =].
            <ol>
              <li>
                Set the first <a>byte</a> of |data| to |prefixByte|.
              </li>
              <li>
                Let |stream:byte stream| be the resulting
                <a data-cite="encoding#concept-stream">byte stream</a> of
                running <a>UTF-8 encode</a> on |shortenedURL|.
              </li>
              <li>
                <a data-cite="encoding#concept-stream-read">Read</a> bytes from
                |stream| into |data| (from position 1) until
                <a data-cite="encoding#concept-stream-read">read</a>
                returns <a data-cite="encoding#end-of-stream">end-of-stream</a>.
              </li>
            </ol>
          </li>
          <li>
            Set |length:unsigned long| to the [=byte sequence/length=]
            of |data|.
          </li>
          <li>
            Set the |ndef|'s <a>TNF field</a> to `1`
            ([=well-known type record=]).
          </li>
          <li>
            Set the |ndef|'s <a>TYPE field</a> to "`U`" (`0x55`).
          </li>
          <li>
            Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
          </li>
          <li>
            If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
            to |data|.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping binary data to NDEF</h3>
      <div>
        To <dfn>map binary data to NDEF</dfn> given a |record:NDEFRecordInit|
        and |ndef|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecord">
          <li>
            If the type of a |record|'s <a>data</a> is not a
            {{BufferSource}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Let |mimeTypeRecord| be the <a>MIME type</a>
            returned by running <a>parse a MIME type</a> on
            |record|'s <a>mediaType</a>.
            <ol>
              <li>
                If |mimeTypeRecord| is failure, let |mimeTypeRecord| be a new
                <a>MIME type record</a> whose type is "`application`", and
                subtype is "`octet-stream`".
              </li>
            </ol>
          </li>
          <li>
            Set |arrayBuffer| to |record|'s <a>data</a>.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Set the |ndef|'s <a>TNF field</a> to `2` (<a>MIME type</a>).
          </li>
          <li>
            Set the |ndef|'s <a>TYPE field</a> to the result of
            <a>serialize a MIME type</a> with |mimeTypeRecord| as
            the input.
          </li>
          <li>
            Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
          </li>
          <li>
            If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
            to |data|.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping external data to NDEF</h3>
      <div>
        To <dfn>map external data to NDEF</dfn> given a |record:NDEFRecordInit|
        and |ndef|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is not a
            {{BufferSource}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Set |arrayBuffer| to |record|'s <a>data</a>.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `4`
            (<a>external type record</a>).
          </li>
          <li>
            Set the |ndef|'s <a>TYPE field</a> to |record|'s
            <a>recordType</a>.
          </li>
          <li>
            Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
          </li>
          <li>
            If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
            to |data|.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>

    <section><h3>Mapping local type to NDEF</h3>
      <div>
        To <dfn>map local type to NDEF</dfn> given a |record:NDEFRecordInit| and
        |ndef|, run these steps:
        <ol class=algorithm data-link-for="NDEFRecordInit">
          <li>
            If |record|'s <a>mediaType</a> is not `undefined`,
            [= exception/throw =] a {{TypeError}} and abort these steps.
          </li>
          <li>
            If the type of a |record|'s <a>data</a> is not a
            {{BufferSource}}, [= exception/throw =] a {{TypeError}}
            and abort these steps.
          </li>
          <li>
            Set |arrayBuffer| to |record|'s <a>data</a>.
          </li>
          <li>
            Set |length:unsigned long| to |arrayBuffer|.[[\ArrayBufferByteLength]].
          </li>
          <li>
            Set |data:byte sequence| to |arrayBuffer|.[[\ArrayBufferData]].
          </li>
          <li>
            Set |ndef|'s <a>TNF field</a> to `1`
            ([=well-known type record=]).
          </li>
          <li>
            Set |ndef|'s <a>TYPE field</a> to |record|'s
            <a>recordType</a>, representing the <a>local type</a> name.
          </li>
          <li>
            Set the |ndef|'s <a>PAYLOAD LENGTH field</a> to |length|.
          </li>
          <li>
            If |length| > `0`, set the |ndef|'s <a>PAYLOAD field</a>
            to |data|.
          </li>
          <li>
            Return |ndef|.
          </li>
        </ol>
      </div>
    </section>
  </section>

  <section> <h3>Listening for content</h3>
    <p>
      If there are any {{NDEFReader}} instances in <a>activated reader objects</a>
      then the <a>UA</a> MUST listen to <a>NDEF message</a>s on all connected
      NFC adapters.
    </p>
    <p>
      To listen for <a>NFC content</a>, the client MUST activate an
      {{NDEFReader}} instance by calling <a>NDEFReader.scan()</a>. When attaching
      an event listener for the "`reading`" event on it, <a>NFC content</a> is
      accessible to the client.
    </p>
    <p>
      Each {{NDEFReader}} can accept <a>NDEF message</a>s based on
      data type, and record identifier filters.
    </p>

    <section> <h3>Match patterns</h3>
      <div>
        A <dfn>match pattern</dfn> is defined by the following ABNF:
        <pre class="abnf">
          match-pattern  = top-level-type "/" [ tree "." ] subtype [ "+" suffix ] [ ";" parameters ]
          top-level-type = "*" / &lt; VCHAR except "/" and "*" &gt;
          subtype        = "*" / &lt; VCHAR except "+" &gt;
        </pre>
        A <a>match pattern</a> is a
        <a href="http://pubs.opengroup.org/onlinepubs/007904875/utilities/xcu_chap02.html#tag_02_13_03">
        glob</a> used for matching <a>MIME type</a>s,
        for instance the pattern "`application/*+json`" matches
        "`application/calendar+json`", but does not match
        "`application/json`". The pattern
        "`*/*json`", on the other hand, matches both.
      </div>
    </section>

    <section> <h3>The <strong>scan()</strong> method</h3>
      <p>
        Incoming <a>NFC content</a> is matched using {{NDEFReader}} instances.
      </p>
      <div>
        When the <dfn>NDEFReader.scan</dfn> method is invoked, the UA
        MUST run the following
        <dfn id="steps-listen">NFC listen algorithm</dfn>:
        <ol class=algorithm>
          <li>
            Let |p:Promise| be a new {{Promise}} object.
          </li>
          <li>
            Let |reader:NDEFReader| be the {{NDEFReader}} instance.
          </li>
          <li>
            Let |options| be first argument.
          </li>
          <li>
            [= list/For each =] |key| ‚Üí |value| of |options|:
            <ol>
              <li>
                If |key| equals "`signal`" and |value| is not `undefined`, set
                |reader|.<a>[[\Signal]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`id`", set
                |reader|.<a>[[\Id]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`recordType`", set
                |reader|.<a>[[\RecordType]]</a> to |value|.
              </li>
              <li>
                Otherwise, if |key| equals "`mediaType`", set
                |reader|.<a>[[\MediaType]]</a> to |value|.
              </li>
            </ol>
          </li>
          <li>
            If there is no underlying <a>NFC Adapter</a>, or if a connection
            cannot be established, then reject |p| with a
            {{"NotSupportedError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If the UA is not allowed to access the underlying <a>NFC Adapter</a>
            (e.g. a user preference), then reject |p| with a
            {{"NotReadableError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If |reader|.<a>[[\Signal]]</a>'s [= AbortSignal/aborted flag =] is
            set, then reject |p| with a {{"AbortError"}} {{DOMException}}
            and return |p|.
          </li>
          <li>
            If |reader|.<a>[[\Signal]]</a> is not `null`, then
            <a data-cite="dom#abortsignal-abort-algorithms">add the following
            abort steps</a> to |reader|.<a>[[\Signal]]</a>:
            <ol>
              <li>
                Remove the {{NDEFReader}} instance from the
                <a>activated reader objects</a>.
              </li>
              <li>
                If the <a>activated reader objects</a> [= list/is empty =],
                then make a request to stop listening to <a>NDEF message</a>s
                on all <a>NFC adapter</a>s.
              </li>
            </ol>
          </li>
          <li>
            Return |p| and run the following steps <a>in parallel</a>:
            <ol>
              <li>
                If the <a>obtain permission</a> steps return `false`, then
                reject |p| with a {{"NotAllowedError"}} {{DOMException}} and
                abort these steps.
              </li>
              <li>
                Add |reader| to the <a>activated reader objects</a>.
              </li>
              <li>
                Resolve |p|.
              </li>
              <li>
                Whenever the <a>UA</a> detects NFC technology, run the
                <a>NFC reading algorithm</a>.
              </li>
            </ol>
          </li>
        </ol>
      </div>
    </section>

    <section><h3>The NFC reading algorithm</h3>
    To receive <a>NDEF</a> content, run the <dfn>NFC reading algorithm</dfn>:
    <ol class=algorithm id="parse-ndef">
      <li>
        If <a>NFC is suspended</a>, abort these steps.
      </li>
      <li>
        If the <a>NFC device</a> in proximity range does not expose <a>NDEF</a>
        technology for reading or formatting, run the following sub-steps:
        <ol>
          <li>[= list/For each =]
            {{NDEFReader}} instance |reader:NDEFReader| in the
            <a>activated reader objects</a>, run the following sub-steps:
            <ol>
              <li>
                <a>Fire an event</a> named "`error`" at |reader|.
              </li>
            </ol>
          </li>
          <li>
            Abort these steps.
          </li>
        </ol>
      </li>
      <li>
        Let |serialNumber:serialNumber| be the device identifier as a series of
        numbers, or `null` if unavailable.
      </li>
      <li>
        If |serialNumber| is not `null`, set it to the
        <a>string</a> of U+003A (`:`) concatenating each number represented as
        <a>ASCII hex digit</a>, in the same order.
      </li>
      <li>
        Let |message:NDEFMessage| be a new <a>NDEFMessage</a> object, with
        |message|'s records set to the empty <a>list</a>.
      </li>
      <li>
        If the <a>NFC device</a> in proximity range is an unformatted
        <a>NFC tag</a> that is NDEF-formattable, let |input| be `null`.
        Otherwise, let |input| be the notation for the <a>NDEF message</a>
        which has been received.
        <p class="note">
           The UA SHOULD represent an unformatted <a>NFC tag</a> as an
           <a>NDEF message</a> containing no <a>NDEF record</a>s, i.e. an empty
           array for its [=NDEFMessage/records=] property.
        </p>
      </li>
      <li>
        [= list/For each =] <a>NDEF record</a> which is part of |input|, run the
        following sub-steps:
        <ol>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a> with
            |typeNameField:number| corresponding to the <a>TNF field</a> and
            |payload:byte sequence| corresponding to the <a>PAYLOAD field</a>
            data.
          </li>
          <li>
            Let |record:NDEFRecord| be the result of <a>parse an NDEF record</a>
            on |ndef|.
          </li>
          <li>
             If |record| is not `null`, <a>append</a> |record| to |message|'s
             records.
          </li>
        </ol>
      </li>
      <li>
        If <a href="#nfc-is-suspended">NFC is not suspended</a>, run the
        <a>dispatch NFC content</a> steps with given |serialNumber|
        and |message|.
      </li>
    </ol>
    </section>

    <section data-link-for="NDEFReadingEvent"><h3>Dispatching NFC content</h3>
    <p>
      To <dfn>dispatch NFC content</dfn> given a |serialNumber:serialNumber|
      of type <a>serialNumber</a> and a |message:NDEFMessage|
      of type <a>NDEFMessage</a>, run these steps:
    </p>
    <ol class=algorithm>
      <li>
        [= list/For each =] {{NDEFReader}} instance |reader:NDEFReader| in
        the <a>activated reader objects</a>, run the following sub-steps:
        <ol>
          <li>
            [= list/For each =] |record:NDEFRecord| in |message:NDEFMessage|,
            <ol>
              <li>
                Let |matched:boolean| be `false`.
              </li>
              <li>
                If |reader|.<a>[[\Id]]</a> is not empty string and is equal to
                |record|'s <a href="#dom-ndefrecord-id">id</a>,
                [= iteration/continue =].
                If it is equal, set |matched| to `true`.
              </li>
              <li>
                If |reader|.<a>[[\RecordType]]</a> is
                [= dictionary member/present =] and it is not equal to
                |record|'s <a href="#dom-ndefrecord-recordtype">recordType</a>,
                [= iteration/continue =].
                If it is equal, set |matched| to `true`.
              </li>
              <li>
                If |reader|.<a>[[\MediaType]]</a> is not empty string and is not
                equal to
                |record|'s <a href="#dom-ndefrecord-mediatype">mediaType</a>,
                [= iteration/continue =].
                If it is equal, set |matched| to `true`.
              </li>
              <li>
                If |matched| is `true`,
                <ol>
                  <li>
                    <a>fire an event</a> named "`reading`"
                    at |reader| using <a>NDEFReadingEvent</a> with its
                    <a>serialNumber</a> attribute initialized to |serialNumber|
                    and <a>message</a> attribute initialized to |message|.
                  </li>
                  <li>
                    [= iteration/Break =].
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    </section>
  </section>

  <section id="steps-receiving">
  <h3>Parsing content</h3>

  <section><h3>Parsing records from bytes</h3>
    To <dfn>parse records from bytes</dfn> given |bytes:byte sequence|,
    run these steps:
    <ol class=algorithm>
      <li>
        If the length of |bytes| is `0`, return `null` and abort these steps.
      </li>
      <li>
        Let |records| be the empty list.
      </li>
      <li>
        As long as there are unread bytes of |bytes|, run the following
        sub-steps:
        <ol>
          <li>
            If the remaining length of |bytes| is less than `3`, return `null`
            and abort these sub-steps.
          </li>
          <li>
            If any of the following steps requires reading bytes beyond the
            remaining length of |bytes|, return `null` and abort these
            sub-steps.
          </li>
          <li>
            Let |ndef| be the notation for the current <a>NDEF record</a>.
          </li>
          <li>
            Let |header:byte| be the next byte of |bytes|.
            <ol>
              <li>
                Let |messageBegin:boolean| (<a>MB field</a>) be the left most
                bit (bit 7) of |header|.
              </li>
              <li>
                If this is the first iteration of these sub-steps and
                |messageBegin| is `false`, return `null` and abort these
                sub-steps.
              </li>
              <li>
                Let |messageEnd:boolean| (<a>ME field</a>) be bit 6 of |header|.
              </li>
              <p class=note>
                As chunked records are not allowed as sub records, ignore bit 5
                (<a>CF field</a>) is ignored.
              </p>
              <li>
                Let |shortRecord:boolean| (<a>SR field</a>) be bit 4 of |header|.
              </li>
              <li>
                Let |hasIdLength:boolean| (<a>IL field</a>) be bit 3 of |header|.
              </li>
              <li>
                Let |ndef|'s |typeNameField:number| (<a>TNF field</a>) be the
                integer value of bit 2-0 of |header|.
              </li>
            </ol>
          </li>
          <li>
            Let |typeLength:number| be the integer value of next byte
            (<a>TYPE LENGTH field</a>) of |bytes|.
          </li>
          <li>
            If |shortRecord| is `true`, let |payloadLength:number|
            be the integer value of next byte (<a>PAYLOAD LENGTH field</a>) of
            |bytes|.
          </li>
          <li>
            Otherwise, let |payloadLength| be the integer value of the next 4
            bytes of |bytes|.
          </li>
          <li>
            If |hasIdLength| is `true`, let |idLength:number| be
            the integer value of next byte (<a>ID LENGTH field</a>) of |bytes|,
            otherwise let it be `0`.
          </li>
          <li>
            If |typeLength| > 0, let |ndef|'s |type:string| be result of
            running <a>UTF-8 decode</a> on the next |typeLength|
            (<a>TYPE field</a>) bytes, or else let |type| be the empty string.
          </li>
          <li>
            If |idLength| > 0, let |ndef|'s |id:string| be result of
            running <a>UTF-8 decode</a> on the next |idLength| (<a>ID field</a>)
            bytes, or else let |ndef|'s |id| be the empty string.
          </li>
          <li>
            Let |ndef|'s |payload| be the <a>byte sequence</a> of the last
            |payloadLength| (<a>PAYLOAD field</a>) bytes, which may be `0` bytes.
          </li>
          <li>
            Let |record:NDEFRecord| be the result of <a>parse an NDEF record</a>
            on |ndef|.
          </li>
          <li>
            If |record| is not `null`, <a>append</a> |record| to |records|.
          </li>
          <li>
            If |messageEnd| is `true`, abort these sub-steps.
          </li>
        </ol>
      </li>
      <li>
        Return |records|.
      </li>
    </ol>
  </section>

  <section><h3>Parsing NDEF records</h3>
  <div>
    To <dfn>parse an NDEF record</dfn> given |ndef| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>id</a> to |ndef|'s |id:string|.
      </li>
      <li>
        Set |record|'s <a>isLocal</a> to `true` if |ndef| is a payload
        to another <a>NDEF record</a>, or otherwise `false`.
      </li>
      <li>
        Set |record|'s <a>lang</a> to `null`.
      </li>
      <li>
        Set |record|'s <a>encoding</a> to `null`.
      </li>
      <li>
        If |ndef|'s |typeNameField:number| (<a>TNF field</a>) is `0`
        (<a>empty record</a>):
        <ol>
          <li>
            Set |record|'s <a>id</a> to `null`.
          </li>
          <li>
            Set |record|'s <a>recordType</a> to "`empty`".
          </li>
          <li>
            Set |record|'s <a>mediaType</a> to `null`.
          </li>
          <li>
            Set |record|'s <a>data</a> to `null`.
          </li>
        </ol>
      </li>
      <li>
        If |ndef|'s |typeNameField| is `1` ([=well-known type record=]):
        <ol>
          <li>
            Set |record| to the result of the algorithm below switching on
            |ndef|'s |type:string|:
            <dl>
              <dt>"`T`" (`0x54`)</dt>
              <ul>
                <li>
                  running <a>parse an NDEF text record</a> on |ndef|.
                </li>
              </ul>
              <dt>"`U`" (`0x55`)</dt>
              <ul>
                <li>
                  running <a>parse an NDEF URL record</a> on |ndef|
                </li>
              </ul>
              <dt>"`Sp`" (`0x53` `0x70`)</dt>
              <ul>
                <li>
                  running <a>parse an NDEF smart-poster record</a> on |ndef|
                </li>
              </ul>
            </dl>
          </li>
        </ol>
      </li>
      <li>
        If |ndef|'s |typeNameField| is `2` (<a>MIME type record</a>), then
        set |record| to the result of running <a>parse an NDEF MIME type record</a>
        on |ndef|, or make sure that the underlying platform provides equivalent
        values to the |record| object's properties.
      </li>
      <li>
        Otherwise, if |ndef|'s |typeNameField| is `3` (<a>absolute-URL record</a>),
        then set |record| to the result of running
        <a>parse an NDEF absolute-URL record</a> on |ndef|.
      </li>
      <li>
        Otherwise, if |ndef|'s |typeNameField| is `4` (<a>external type record</a>),
        then set |record| to the result of running
        <a>parse an NDEF external type record</a> on |ndef|, or make sure that
        the underlying platform provides equivalent values to the |record|
        object's properties.
      </li>
      <li>
        Otherwise, if |ndef|'s |typeNameField| is `5` (<a>unknown record</a>)
        then set |record| to the result of running
        <a>parse an NDEF unknown record</a> on |ndef|, or make sure that the
        underlying platform provides equivalent values to the |record| object's
        properties.
      </li>
    </ol>
  </div>
  </section>

  <section><h3>Parsing NDEF well-known `T` records</h3>
  <div>
    To <dfn>parse an NDEF text record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`text`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present, set
        |record|'s <a>data</a> to `null` and return |record|.
      </li>
      <li>
        Let |header:byte| be the first <a>byte</a> of |ndefRecord|'s
        <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |languageLength:octet| be the value given by bit `5`
        to bit `0` of the |header|.
      </li>
      <li>
        Let |language:string| be the result of running <a>ASCII decode</a>
        on second <a>byte</a> to the |languageLength| + `1` byte, inclusive.
      </li>
      <li>
        Set |record|'s <a>lang</a> to |language|.
      </li>
      <li>
        Set |record|'s <a>encoding</a> be "`utf-8`" if bit `7` ([=MB field=]) of
        |header| is equal to the value `0`, or else "`utf-16be`".
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol> <!-- parsing NDEF text record -->
  </div>
  <aside class="note" data-link-for="NDEFRecord">
    <p>
      The Unicode standard defines multiple encodings like UTF-8, UTF-16 and UTF-32.
      UTF-8 is the preferred encoding on the web, and it has the advantage
      that it is endianness agnostic, as [=code points=] are represented in single bytes.
    </p>
    <p>
      The NDEF text records allow the text to be encoded as either UTF-8 or UTF-16.
      Generally, it is preferred to use UTF-8 encoding on the web, but integration
      with existing systems may require UTF-16.
    </p>
    <p>
      The data transmission order and thus the byte order of NDEF is
      defined as big endian (BE) in [[[NFC-NDEF]]], which means that everything is read back with big endian byte ordering.
    </p>
    <p>
      For UTF-16, byte order matters as it might differ between reading and writing
      due to each [=code point=] spanning two bytes. For this reason UTF-16 encoded text
      usually contains a byte order mark (also known as BOM), which is written as
      `0xFEFF`. This means that if the byte order differs between host machine and
      NDEF, then the value will be read back as `0xFFFE`, indicating that the byte
      order should be swapped. The [[[ENCODING]]] differentiates UTF-16 as UTF-16BE
      (big endian) and UTF-16LE (little endian) depending on the byte order.
    </p>
    <p>
      In the case that no byte order mark is present, UTF-16BE encoding should be assumed.
    </p>
    <p>
      Using the <a data-cite="encoding#decoder">decoder</a> with `encoding` set to
      `utf-16`, it will automatically detect whether bytes should be swapped in
      case the byte order mark is present. `utf-16be` can be used to read as big
      endian in case there is no byte order mark.
    </p>
    <p>
      Using the <a data-cite="encoding#encoder">encoder</a>, it is only possible
      to encode as UTF-8, so if UTF-16 is needed, it will have to be encoded
      manually or by using a library.
    </p>
  </aside>
  </section>

  <section><h3>Parsing NDEF well-known `U` records</h3>
  <div>
    To <dfn>parse an NDEF URL record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`url`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present,
        set |record|'s <a>data</a> to `null` and return |record|.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Let |prefixByte:byte| be the value of the first <a>byte</a> of
        |buffer|.
      </li>
      <li>
        If the value of |prefixByte| matches the URL expansion codes in the
        [[[NFC-STANDARDS]]] URI Record Type Definition specification,
        Section 3.2.2, Table 3, then
        <ol>
          <li>
            Let |prefixString:string| be the <a>byte sequence</a> value
            corresponding to the value of |prefixByte|.
          </li>
          <li>
            Set |record|'s <a>data</a> to |prefixString| appended to |buffer|.
          </li>
        </ol>
      </li>
      <li>
        Otherwise, if there is no match for |prefixByte|, set
        |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol> <!-- parsing NDEF URL record -->
  </div>
  </section>

  <section><h3>Parsing NDEF well-known `Sp` records</h3>
  <div>
    To <dfn>parse an NDEF smart-poster record</dfn> given a |ndefRecord| into a
    |record:NDEFRecord|, run these steps:
    <ol class=algorithm data-link-for="NDEFRecord">
      <li>
        Set |record|'s <a>recordType</a> to "`smart-poster`".
      </li>
      <li>
        Set |record|'s <a>mediaType</a> to `null`.
      </li>
      <li>
        If |ndefRecord|'s <a>PAYLOAD field</a> is not present, set
        |record|'s <a>data</a> to `null` and return |record|.
      </li>
      <li>
        Let |buffer:byte sequence| be the <a>byte sequence</a> of
        |ndefRecords|'s <a>PAYLOAD field</a>.
      </li>
      <li>
        Set |record|'s <a>data</a> to |buffer|.
      </li>
      <li>
        return |record|.
      </li>
    </ol>  <!-- parsing NDEF smart-poster record -->
  </div>
  </section>

  <section><h3>Parsing NDEF MIME type records</h3>
    <div>
      To <dfn>parse an NDEF MIME type record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to "`mime`".
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to the
          result of <a>serialize a MIME type</a> with |mimeType| as
          the input.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise
          `null`.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol> <!-- parsing NDEF MIME type record -->
    </div>
  </section>

  <section><h3>Parsing NDEF absolute-URL records</h3>
    <div>
      To <dfn>parse an NDEF absolute-URL record</dfn> given a |ndefRecord| into
      a |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to "`absolute-url`".
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to `null`.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>TYPE field</a>.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF absolute URI record -->
    </div>
  </section>

  <section><h3>Parsing NDEF external type records</h3>
    <div>
      To <dfn>parse an NDEF external type record</dfn> given a |ndefRecord| into
      a |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to the
          value of |ndefRecord|'s <a>TYPE field</a>.
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to `null`.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise
          `null`.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF external type record -->
    </div>
  </section>

  <section><h3>Parsing NDEF unknown type records</h3>
    <div>
      To <dfn>parse an NDEF unknown record</dfn> given a |ndefRecord| into a
      |record:NDEFRecord|, run these steps:
      <ol class=algorithm data-link-for="NDEFRecord">
        <li>
          Set |record|'s <a>recordType</a> to "`unknown`".
        </li>
        <li>
          Set |record|'s <a>mediaType</a> to `null`.
        </li>
        <li>
          Let |buffer:byte sequence| be the <a>byte sequence</a> of
          |ndefRecords|'s <a>PAYLOAD field</a> if that exists, or otherwise
          `null`.
        </li>
        <li>
          Set |record|'s <a>data</a> to |buffer|.
        </li>
        <li>
          return |record|.
        </li>
      </ol>  <!-- parsing NDEF unknown record -->
    </div>
  </section>
</section>
</section>

<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2 id="security">Security and Privacy</h2>
  <p>
    NFC technology involves multiple levels of security. Payments done with NFC
    are considered to be secure at hardware level, but the whole software stack
    needs to be security hardened.
    However, NFC data transfers involve additional threats. In order to mitigate
    these, the NFC Forum introduced [[NDEF-SIGNATURE]].
  </p>

  <section> <h3>Chain of trust</h3>
    <p>
      Web sites and applications using Web NFC are not trusted.
      This means that the user needs to be made aware of what NFC functionality
      a web page intends to do. Implementations need to
      make sure that when the user authorizes a method of this API, only
      that action is run, without side effects, and exactly in the context and
      the number of times the user allows the execution of NFC related
      operations, according to the algorithmic steps detailed in this
      specification.
    </p>
    <p>
      Web NFC does not sign <a>NFC content</a>. Using <a>NDEF signature</a> and
      key management is the responsibility of the application.
    </p>
    <p>
      For trusting the <strong>confidentiality</strong> of the data exchanged
      via NFC, applications may use encrypted <a>NFC content</a>.
    </p>
    <p>
      For trusting the <strong>integrity</strong> of the data exchanged via NFC,
      applications may use an <a>NDEF signature</a>, with key management based
      on Public Key Infrastructure (PKI).
    </p>
    <p>
      Security considerations for MIME types in general are discussed in
      [[RFC2048]] and [[RFC2046]].
    </p>
  </section>

  <section class="informative"> <h2>Assets</h2>
    <div>
      Assets to be protected include the following:
      <ul>
        <li>
          <strong>NDEF message</strong> as a whole,
          <strong>NDEF records</strong> (including payload and header) in
          particular, either in-transfer or in-storage state,
          when they are being overwritten by a Web NFC triggered operation,
          against data disclosure and data modification.
          This also includes Denial of Service attacks against a solution
          deployed with NFC tags (e.g. a malicious actor destroying tags linked
          to a solution).
        </li>
        <li>
          <strong>User identity or other privacy sensitive attributes</strong>
          that can be directly or indirectly determined by using Web NFC, by the
          <a>NFC content</a> creator by a web site using Web NFC.
          This data could be used directly or leaked forward to third parties.
          Examples are user location, device identifiers and user identifiers.
        </li>
        <li>
          <strong>User data</strong> exposed to a web page using Web NFC.
          While a web page might collect user data using other means than
          Web NFC, it might embed this data into NDEF records and share via
          Web NFC.
        </li>
        <li>
          <strong>Integrity of user device</strong>.
          A read of an NFC tag might result in a user device compromise
          that can further lead to loss of other web NFC or platform assets.
        </li>
      </ul>
    </div>
  </section>

  <section class="informative"> <h2>Attacker model</h2>
    <p>
      The following attacker patterns have been considered:
      <ul>
        <li>
          <strong>Malicious web page creator</strong>: phishing user data,
          identity or other privacy sensitive attributes, destroying or
          modifying NFC tags to cause further damage through fake identities
          and attack vectors.
        </li>
        <li>
          <strong>Malicious NFC tag creator</strong>: same as malicious web page
          owner, but it has a possibility to create, delete or modify the NFC
          tags locally.
          As a result can compromise integrity of user device, cause data
          injection, redirect to malicious web page, phishing user location,
          causing side actions such as installing applications, trigger
          automated dispatching or other actions.
        </li>
        <li>
          <strong>Malicious man-in-the-middle (MITM) user</strong>: any MITM
          style attack between Web NFC implementation and an <a>NFC adapter</a>
          in a user device, including attempts to interact with a web site using
          Web NFC by presenting modified or replayed NDEF records.
        </li>
      </ul>
    </p>
  </section>

  <section class="informative"> <h3>Threats</h3>
    <p>
      An introduction to NFC security is found <a href="https://resources.infosecinstitute.com/near-field-communication-nfc-technology-vulnerabilities-and-principal-attack-schema/">here</a>.
      Potential threats for Web NFC are given below.
    </p>

    <section> <h4>Fingerprinting and data collection</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          Malicious web page collects user data, identity or other privacy
          sensitive attributes (such as location) without user consent and
          exposes it to third parties (writing it to NFC tags, pushing to NFC
          peers).
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          User data, user identity or other privacy sensitive attributes
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious web page owner using Web NFC, malicious tag owner.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          The user SHOULD be able to be aware of what data can be shared using
          NFC from the given web page.
          Use permissions and user prompts for accessing personal data,
          minimize user data exposed to NFC.
          A NFC tag SHOULD NOT ever trigger a user‚Äôs device to navigate
          to a web site without asking permission, unless the site has been in
          the foreground or has been brought to the foreground and has been
          granted permission. User agents SHOULD take into account the
          security and privacy measures listed in the
          <a href="http://dev.w3.org/geo/api/spec-source.html#security">
          Geolocation API</a>.
        </dd>
      </dl>
    </section>

    <section> <h4>NFC tag modification</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          An NFC tag is being modified without user consent.
          This might enable further attacks using a malicious tag
          or can be a Denial of Service attack to make one or more tags
          unusable.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          NDEF message records, including payload and header in-storage.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious web page creator, malicious user.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          Require permission and user prompt needed for writing tags.
          Or, control what tags can be written by a given web page, for instance
          a web page can write only a tag that can be connected to its
          <a>origin</a>.
          Or, allow overwriting since tags not meant to be written can be
          protected by making them read only.
          Use <a>NDEF signature</a> to detect a modification of NFC tags.
        </dd>
      </dl>
    </section>

    <section> <h4>NDEF record modification in-transit</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          <a>NDEF record</a>s transferred between Web NFC and the
          <a>NFC adapter</a> and user device are modified to cause various
          man-in-the-middle attacks or denial-of-service (DoS) attacks.
          Also, <a>NDEF signature</a> records can be removed or
          replaced along with changed content.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          <a>NDEF record</a>s in-transfer.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious man-in-the-middle user.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          This threat is out of scope for Web NFC implementations.
          Applications can use <a>NDEF signature</a>s and appropriate tools
          (signature algorithm, certificates, security policies) to protect the
          <a>NFC content</a>. Additionally, harden the platform stack.
        </dd>
      </dl>
    </section>

    <section> <h4>NDEF record payload disclosure</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          Confidential payload of <a>NDEF record</a> in-storage (stored
          on a NFC tag) or in-transfer between Web NFC and the
          <a>NFC adapter</a> are read by unauthorized parties.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          Confidential NDEF message payload in-transfer and in-storage.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious man-in-the-middle user, malicious web page creator.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          To ensure confidentiality, use payload encryption and secure
          communication for data exchange, authentication and authorization
          between Web NFC and <a>NFC adapter</a>s.
        </dd>
      </dl>
    </section>

    <section> <h4>Active attack via malicious NFC tag</h4>
      <dl>
        <dt><strong>Threat description</strong></dt>
        <dd>
          Malicious tag may be involuntarily or voluntarily read by devices
          and the data read may constitute an attack vector on the user agent.
          For example it can attempt to trigger an action on
          the device, which may be a threat, for instance launching a malicious
          web site, or opening an image prepared for attacking the device.
        </dd>
        <dt><strong>Affected assets</strong></dt>
        <dd>
          Integrity of user device, all other Web NFC assets.
        </dd>
        <dt><strong>Actors</strong></dt>
        <dd>
          Malicious tag creator.
        </dd>
        <dt><strong>Mitigation, comments</strong></dt>
        <dd>
          This is a generic problem with all existing NFC tags.
          The data is considered application specific.
          Implementations need security hardening.
          Involuntary touch is low probability due to short range and critical
          angle for reading, and due to the focus requirements.
          Automatic actions for smart posters and other tags should not be
          allowed. The user must be made aware and given the ability to control
          what is happening during the NFC communication. For instance, opening
          content from <a>smart poster</a>, automatic connection to (possibly
          malicious) WiFi via <a>NFC handover</a>, etc.
          Do no allow actions from untrusted NFC tags, trust can be established
          via the <a>NDEF signature</a> check.
        </dd>
      </dl>
    </section>
  </section>

  <section class="informative"> <h2>Security mechanisms for implementations</h2>
    <section> <h3><dfn>Obtaining permission</dfn></h3>
      <p>
        Implementations SHOULD use a mechanism to <a>obtain permission</a>,
        for instance an explicit permission given by the user.
        The [[[PERMISSIONS]]] API is suggested to be used by UAs
        for implementing NFC related permissions.
      </p>
    </section>
  </section>
  <section class="informative"> <h2>Security mechanisms for applications</h2>
    <section> <h3>Encrypting <a>NFC content</a></h3>
      <p>
        For trusting the confidentiality of the data exchanged via NFC,
        applications may use encrypted <a>NFC content</a> with key management
        based on Public Key Infrastructure (PKI).
        Key management is out of the scope of Web NFC.
      </p>
    </section>

    <section> <h3>Signing NDEF records</h3>
      <p>
        For trusting the integrity of the data exchanged via NFC, user agents
        MAY use an <a>NDEF signature</a> with a Public Key Infrastructure
        for key management.
      </p>
      <p>
        For tags signed with <a>NDEF signature</a> version 1.0 ([[NFC-SECURITY]]),
        the signature is applied only to the <a>TYPE field</a>, <a>ID field</a>
        and <a>PAYLOAD field</a>, leaving out the first byte of the NDEF header,
        allowing surface to attacks. Version 2.0 of [[NFC-SECURITY]] included
        tag hardware attributes in the signature and allowed for shorter
        certificates.
      </p>
      <p>
        An <a>NDEF signature</a> covers the preceding records until another
        <a>NDEF signature</a> or the beginning of the <a>NDEF message</a> is
        reached.
      </p>
      <p>
        In order to mitigate <a href="https://www.researchgate.net/publication/224227216_Security_Vulnerabilities_of_the_NDEF_Signature_Record_Type">
        known vulnerabilities</a> of <a>NDEF signature</a>, it is recommended
        that applications always sign a full <a>NDEF message</a> with a single
        <a>NDEF signature</a>, and use the right tool chain and security
        policies for creating and verifying signatures.
      </p>
    </section>

  </section>

  <section> <h3>Security policies</h3>
    <p>
      This section lists the normative security policies for implementations.
    </p>

    <section> <h4>Secure Context</h4>
      <p>
        Only <a>secure contexts</a> are allowed to access <a>NFC content</a>.
        Browsers MAY ignore this rule for development purposes only.
      </p>
    </section>

    <section> <h4>Visible document</h4>
      <p>
        Web NFC functionality is allowed only for the {{Document}} of the
        <a>top-level browsing context</a>, which must be
        <dfn data-cite="PAGE-VISIBILITY#dom-visibilitystate-visible">visible</dfn>.
      </p>
      <p>
        This also means that UAs should block access to the NFC radio if
        the display is off or the device is locked.
        For backgrounded web pages, receiving and pushing <a>NFC content</a>
        must be <a id="#nfc-suspended">suspended</a>.
      </p>
    </section>

    <section> <h4>Permissions controls</h4>
      <p>
        Making an <a>NFC tag</a> read-only MUST <a>obtain permission</a>, or
        otherwise fail.
      </p>
      <p>
        Setting up listeners for reading <a>NFC content</a> SHOULD
        <a>obtain permission</a>.
      </p>
      <p>
        Pushing <a>NFC content</a> to an <a>NFC peer</a> MUST
        <a>obtain permission</a>.
        See the [[[#writing-or-pushing-content]]] section.
      </p>
      <p>
        All permission that are preserved beyond the current
        browsing session MUST be revocable.
      </p>
    </section>

    <section> <h4>Warn about risk of physical location leak</h4>
      <p>
        When listening for and pushing <a>NFC content</a>,
        the UA MAY warn the user that the given <a>origin</a> may be able to
        infer physical location.
      </p>
    </section>

    <section> <h4>Restrict automatic handling</h4>
      <p>
        When the payload data on <a>NFC content</a> is untrusted, it MUST NOT
        be used by the UA to do automatic handling of the content, such as
        opening a web page with a URL found in an <a>NFC tag</a>, or installing
        an application, or other actions, unless the user approves that.
      </p>
    </section>

    <section> <h4>Signing <a>NFC content</a></h4>
      <div>
        The following policies are recommended to be implemented by applications.
        <ul>
          <li>
            A <a>smart poster</a> MAY be trusted only if signed by using
            a single <a>NDEF signature</a> record by the same issuer and
            it is either the first record in a message, or it is preceded by
            another <a>NDEF signature</a>.
          </li>
          <li>
            An <a>NDEF message</a> MAY be trusted only if signed by
            a single <a>NDEF signature</a> record by the same issuer.
          </li>
          <li>
            User agents expose <a>NDEF signature</a> records without verifying
            them. It is applications' responsibility to verify signatures and
            to sign <a>NFC content</a>.
          </li>
          <li>
            Applications SHOULD use appropriate signature algorithms,
            certificates and security policies for <a>NDEF signature</a>
            creation and verification. Also, take into account the known
            attacks agains <a>NDEF signature</a>s, for instance removing
            <a>NDEF signature</a>, replacing <a>NDEF signature</a> along with
             modifying the <a>NFC content</a>, reordering records by changing
             the record <a>PAYLOAD LENGTH field</a>, etc.
          </li>
        </ul>
      </div>
    </section>
    <!-- TODO: add later
    <p class="note">
      For Bluetooth and WiFi handover (supported in later versions),
      the user should have to grant access to the secondary API and must be
      able to properly understand what they are granting.
    </p>
    -->
  </section> <!-- Policies -->
</section> <!-- Security and Privacy  -->

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>

<!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
<section> <h2>Acknowledgments</h2>
  <p>
    The editors would like to thank Jeffrey Yasskin, Anne van Kesteren,
    Anssi Kostiainen, Domenic Denicola, Daniel Ehrenberg, Jonas Sicking,
    Don Coleman, Salvatore Iovene, Rijubrata Bhaumik, Wanming Lin, and Han Leon
    for their contributions to this document.
  </p>
  <p>
    Special thanks to Luc Yriarte and Samuel Ortiz for their initial
    <a href="https://github.com/w3c/nfc">work</a>
    on exposing NFC to the web platform, and for their support for the current
    approach. Also, special thanks to Elena Reshetova for the contributions to
    the Security and Privacy section.
  </p>
</section>

</body>
</html>
